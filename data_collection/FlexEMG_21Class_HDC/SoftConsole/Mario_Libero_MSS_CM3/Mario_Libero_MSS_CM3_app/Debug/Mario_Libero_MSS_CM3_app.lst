
Mario_Libero_MSS_CM3_app:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .vector_table 00000190  20000000  20000000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .init         00000360  20000190  20000190  00008190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000037a0  200004f0  200004f0  000084f0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .data         00000090  20003c90  20003c90  0000bc90  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          000003e0  20003d20  20003d20  0000bd20  2**2
                  ALLOC
  5 .heap         00008f00  20004100  20004100  0000bd20  2**0
                  ALLOC
  6 .stack        00003000  2000d000  2000d000  0000bd20  2**0
                  ALLOC
  7 .comment      000001d9  00000000  00000000  0000bd20  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000518  00000000  00000000  0000bef9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 00000ca9  00000000  00000000  0000c411  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0000800e  00000000  00000000  0000d0ba  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00000fae  00000000  00000000  000150c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000475c  00000000  00000000  00016076  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00001074  00000000  00000000  0001a7d4  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00002bda  00000000  00000000  0001b848  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00001aec  00000000  00000000  0001e422  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macinfo 0005fc4a  00000000  00000000  0001ff0e  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .ARM.attributes 00000025  00000000  00000000  0007fb58  2**0
                  CONTENTS, READONLY
 18 .debug_ranges 000004c0  00000000  00000000  0007fb7d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .init:

20000190 <Reset_Handler>:
20000190:	f04f 0b00 	mov.w	fp, #0
20000194:	f8df 021a 	ldr.w	r0, [pc, #538]	; 200003b2 <SF2_MDDR_MODE_CR>
20000198:	6800      	ldr	r0, [r0, #0]
2000019a:	f8df 1212 	ldr.w	r1, [pc, #530]	; 200003ae <SF2_EDAC_CR>
2000019e:	6809      	ldr	r1, [r1, #0]
200001a0:	f001 0103 	and.w	r1, r1, #3
200001a4:	f000 001c 	and.w	r0, r0, #28
200001a8:	2814      	cmp	r0, #20
200001aa:	d101      	bne.n	200001b0 <check_esram_edac>
200001ac:	f04b 0b02 	orr.w	fp, fp, #2

200001b0 <check_esram_edac>:
200001b0:	2900      	cmp	r1, #0
200001b2:	d001      	beq.n	200001b8 <check_stack_init>
200001b4:	f04b 0b01 	orr.w	fp, fp, #1

200001b8 <check_stack_init>:
200001b8:	f1bb 0f00 	cmp.w	fp, #0
200001bc:	d00d      	beq.n	200001da <system_init>

200001be <clear_stack>:
200001be:	487e      	ldr	r0, [pc, #504]	; (200003b8 <SF2_MDDR_MODE_CR+0x6>)
200001c0:	497e      	ldr	r1, [pc, #504]	; (200003bc <SF2_MDDR_MODE_CR+0xa>)
200001c2:	f8df 21ce 	ldr.w	r2, [pc, #462]	; 20000392 <RAM_INIT_PATTERN>
200001c6:	f8df 31ca 	ldr.w	r3, [pc, #458]	; 20000392 <RAM_INIT_PATTERN>
200001ca:	f8df 41c6 	ldr.w	r4, [pc, #454]	; 20000392 <RAM_INIT_PATTERN>
200001ce:	f8df 51c2 	ldr.w	r5, [pc, #450]	; 20000392 <RAM_INIT_PATTERN>

200001d2 <clear_stack_loop>:
200001d2:	4288      	cmp	r0, r1
200001d4:	bf18      	it	ne
200001d6:	c03c      	stmiane	r0!, {r2, r3, r4, r5}
200001d8:	d1fb      	bne.n	200001d2 <clear_stack_loop>

200001da <system_init>:
200001da:	4879      	ldr	r0, [pc, #484]	; (200003c0 <SF2_MDDR_MODE_CR+0xe>)
200001dc:	4780      	blx	r0
200001de:	f00b 0a02 	and.w	sl, fp, #2
200001e2:	f1ba 0f00 	cmp.w	sl, #0
200001e6:	d00c      	beq.n	20000202 <remap_memory>
200001e8:	f8df 01ba 	ldr.w	r0, [pc, #442]	; 200003a6 <SF2_DDRB_NB_SIZE>
200001ec:	f8df 11ba 	ldr.w	r1, [pc, #442]	; 200003aa <SF2_DDRB_CR>
200001f0:	6802      	ldr	r2, [r0, #0]
200001f2:	680b      	ldr	r3, [r1, #0]
200001f4:	b40f      	push	{r0, r1, r2, r3}
200001f6:	f04f 0200 	mov.w	r2, #0
200001fa:	f04f 03ff 	mov.w	r3, #255	; 0xff
200001fe:	6002      	str	r2, [r0, #0]
20000200:	600b      	str	r3, [r1, #0]

20000202 <remap_memory>:
20000202:	4870      	ldr	r0, [pc, #448]	; (200003c4 <SF2_MDDR_MODE_CR+0x12>)
20000204:	4a70      	ldr	r2, [pc, #448]	; (200003c8 <SF2_MDDR_MODE_CR+0x16>)
20000206:	4b71      	ldr	r3, [pc, #452]	; (200003cc <SF2_MDDR_MODE_CR+0x1a>)
20000208:	2802      	cmp	r0, #2
2000020a:	d108      	bne.n	2000021e <check_esram_remap>
2000020c:	f8df 118a 	ldr.w	r1, [pc, #394]	; 2000039a <SF2_ESRAM_CR>
20000210:	600a      	str	r2, [r1, #0]
20000212:	f8df 118e 	ldr.w	r1, [pc, #398]	; 200003a2 <SF2_ENVM_REMAP_CR>
20000216:	600a      	str	r2, [r1, #0]
20000218:	f8df 1182 	ldr.w	r1, [pc, #386]	; 2000039e <SF2_DDR_CR>
2000021c:	600b      	str	r3, [r1, #0]

2000021e <check_esram_remap>:
2000021e:	2801      	cmp	r0, #1
20000220:	d108      	bne.n	20000234 <check_mirrored_nvm>
20000222:	f8df 117a 	ldr.w	r1, [pc, #378]	; 2000039e <SF2_DDR_CR>
20000226:	600a      	str	r2, [r1, #0]
20000228:	f8df 1176 	ldr.w	r1, [pc, #374]	; 200003a2 <SF2_ENVM_REMAP_CR>
2000022c:	600a      	str	r2, [r1, #0]
2000022e:	f8df 116a 	ldr.w	r1, [pc, #362]	; 2000039a <SF2_ESRAM_CR>
20000232:	600b      	str	r3, [r1, #0]

20000234 <check_mirrored_nvm>:
20000234:	4866      	ldr	r0, [pc, #408]	; (200003d0 <SF2_MDDR_MODE_CR+0x1e>)
20000236:	2800      	cmp	r0, #0
20000238:	d109      	bne.n	2000024e <copy_data>
2000023a:	4866      	ldr	r0, [pc, #408]	; (200003d4 <SF2_MDDR_MODE_CR+0x22>)
2000023c:	4966      	ldr	r1, [pc, #408]	; (200003d8 <SF2_MDDR_MODE_CR+0x26>)
2000023e:	4a67      	ldr	r2, [pc, #412]	; (200003dc <SF2_MDDR_MODE_CR+0x2a>)
20000240:	f000 f83a 	bl	200002b8 <block_copy>

20000244 <copy_text>:
20000244:	4866      	ldr	r0, [pc, #408]	; (200003e0 <SF2_MDDR_MODE_CR+0x2e>)
20000246:	4967      	ldr	r1, [pc, #412]	; (200003e4 <SF2_MDDR_MODE_CR+0x32>)
20000248:	4a67      	ldr	r2, [pc, #412]	; (200003e8 <SF2_MDDR_MODE_CR+0x36>)
2000024a:	f000 f835 	bl	200002b8 <block_copy>

2000024e <copy_data>:
2000024e:	4867      	ldr	r0, [pc, #412]	; (200003ec <SF2_MDDR_MODE_CR+0x3a>)
20000250:	4967      	ldr	r1, [pc, #412]	; (200003f0 <SF2_MDDR_MODE_CR+0x3e>)
20000252:	4a68      	ldr	r2, [pc, #416]	; (200003f4 <SF2_MDDR_MODE_CR+0x42>)
20000254:	f000 f830 	bl	200002b8 <block_copy>

20000258 <clear_bss>:
20000258:	4867      	ldr	r0, [pc, #412]	; (200003f8 <SF2_MDDR_MODE_CR+0x46>)
2000025a:	4968      	ldr	r1, [pc, #416]	; (200003fc <SF2_MDDR_MODE_CR+0x4a>)
2000025c:	4a5a      	ldr	r2, [pc, #360]	; (200003c8 <SF2_MDDR_MODE_CR+0x16>)
2000025e:	4b5a      	ldr	r3, [pc, #360]	; (200003c8 <SF2_MDDR_MODE_CR+0x16>)
20000260:	4c59      	ldr	r4, [pc, #356]	; (200003c8 <SF2_MDDR_MODE_CR+0x16>)
20000262:	4d59      	ldr	r5, [pc, #356]	; (200003c8 <SF2_MDDR_MODE_CR+0x16>)

20000264 <clear_bss_loop>:
20000264:	4288      	cmp	r0, r1
20000266:	bf18      	it	ne
20000268:	c03c      	stmiane	r0!, {r2, r3, r4, r5}
2000026a:	d1fb      	bne.n	20000264 <clear_bss_loop>

2000026c <clear_heap>:
2000026c:	f1bb 0f00 	cmp.w	fp, #0
20000270:	d016      	beq.n	200002a0 <call_glob_ctor>
20000272:	4863      	ldr	r0, [pc, #396]	; (20000400 <SF2_MDDR_MODE_CR+0x4e>)
20000274:	4963      	ldr	r1, [pc, #396]	; (20000404 <SF2_MDDR_MODE_CR+0x52>)
20000276:	f8df 211e 	ldr.w	r2, [pc, #286]	; 20000396 <HEAP_INIT_PATTERN>
2000027a:	f8df 311a 	ldr.w	r3, [pc, #282]	; 20000396 <HEAP_INIT_PATTERN>
2000027e:	f8df 4116 	ldr.w	r4, [pc, #278]	; 20000396 <HEAP_INIT_PATTERN>
20000282:	f8df 5112 	ldr.w	r5, [pc, #274]	; 20000396 <HEAP_INIT_PATTERN>

20000286 <clear_heap_loop>:
20000286:	4288      	cmp	r0, r1
20000288:	bf18      	it	ne
2000028a:	c03c      	stmiane	r0!, {r2, r3, r4, r5}
2000028c:	d1fb      	bne.n	20000286 <clear_heap_loop>
2000028e:	f00b 0a02 	and.w	sl, fp, #2
20000292:	f1ba 0f00 	cmp.w	sl, #0
20000296:	d003      	beq.n	200002a0 <call_glob_ctor>
20000298:	bc0f      	pop	{r0, r1, r2, r3}
2000029a:	6002      	str	r2, [r0, #0]
2000029c:	600b      	str	r3, [r1, #0]
	...

200002a0 <call_glob_ctor>:
200002a0:	f8df 0164 	ldr.w	r0, [pc, #356]	; 20000408 <SF2_MDDR_MODE_CR+0x56>
200002a4:	f20f 0e03 	addw	lr, pc, #3
200002a8:	4700      	bx	r0

200002aa <branch_to_main>:
200002aa:	f04f 0000 	mov.w	r0, #0
200002ae:	f04f 0100 	mov.w	r1, #0
200002b2:	f8df f158 	ldr.w	pc, [pc, #344]	; 2000040c <SF2_MDDR_MODE_CR+0x5a>

200002b6 <ExitLoop>:
200002b6:	e7fe      	b.n	200002b6 <ExitLoop>

200002b8 <block_copy>:
200002b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
200002ba:	4288      	cmp	r0, r1
200002bc:	d00c      	beq.n	200002d8 <block_copy_exit>
200002be:	1a52      	subs	r2, r2, r1
200002c0:	1112      	asrs	r2, r2, #4
200002c2:	f012 0f0f 	tst.w	r2, #15
200002c6:	d000      	beq.n	200002ca <block_copy_loop>
200002c8:	3201      	adds	r2, #1

200002ca <block_copy_loop>:
200002ca:	429a      	cmp	r2, r3
200002cc:	bf1c      	itt	ne
200002ce:	c8f0      	ldmiane	r0!, {r4, r5, r6, r7}
200002d0:	c1f0      	stmiane	r1!, {r4, r5, r6, r7}
200002d2:	f103 0301 	add.w	r3, r3, #1
200002d6:	d1f8      	bne.n	200002ca <block_copy_loop>

200002d8 <block_copy_exit>:
200002d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

200002da <NMI_Handler>:
200002da:	e7fe      	b.n	200002da <NMI_Handler>

200002dc <HardFault_Handler>:
200002dc:	e7fe      	b.n	200002dc <HardFault_Handler>

200002de <MemManage_Handler>:
200002de:	e7fe      	b.n	200002de <MemManage_Handler>

200002e0 <BusFault_Handler>:
200002e0:	e7fe      	b.n	200002e0 <BusFault_Handler>

200002e2 <UsageFault_Handler>:
200002e2:	e7fe      	b.n	200002e2 <UsageFault_Handler>

200002e4 <SVC_Handler>:
200002e4:	e7fe      	b.n	200002e4 <SVC_Handler>

200002e6 <DebugMon_Handler>:
200002e6:	e7fe      	b.n	200002e6 <DebugMon_Handler>

200002e8 <PendSV_Handler>:
200002e8:	e7fe      	b.n	200002e8 <PendSV_Handler>

200002ea <SysTick_Handler>:
200002ea:	e7fe      	b.n	200002ea <SysTick_Handler>

200002ec <WdogWakeup_IRQHandler>:
200002ec:	e7fe      	b.n	200002ec <WdogWakeup_IRQHandler>

200002ee <RTC_Wakeup_IRQHandler>:
200002ee:	e7fe      	b.n	200002ee <RTC_Wakeup_IRQHandler>
200002f0:	e7fe      	b.n	200002f0 <RTC_Wakeup_IRQHandler+0x2>
200002f2:	e7fe      	b.n	200002f2 <RTC_Wakeup_IRQHandler+0x4>

200002f4 <I2C0_IRQHandler>:
200002f4:	e7fe      	b.n	200002f4 <I2C0_IRQHandler>

200002f6 <I2C0_SMBAlert_IRQHandler>:
200002f6:	e7fe      	b.n	200002f6 <I2C0_SMBAlert_IRQHandler>

200002f8 <I2C0_SMBus_IRQHandler>:
200002f8:	e7fe      	b.n	200002f8 <I2C0_SMBus_IRQHandler>

200002fa <I2C1_IRQHandler>:
200002fa:	e7fe      	b.n	200002fa <I2C1_IRQHandler>

200002fc <I2C1_SMBAlert_IRQHandler>:
200002fc:	e7fe      	b.n	200002fc <I2C1_SMBAlert_IRQHandler>

200002fe <I2C1_SMBus_IRQHandler>:
200002fe:	e7fe      	b.n	200002fe <I2C1_SMBus_IRQHandler>

20000300 <UART0_IRQHandler>:
20000300:	e7fe      	b.n	20000300 <UART0_IRQHandler>

20000302 <UART1_IRQHandler>:
20000302:	e7fe      	b.n	20000302 <UART1_IRQHandler>

20000304 <EthernetMAC_IRQHandler>:
20000304:	e7fe      	b.n	20000304 <EthernetMAC_IRQHandler>
20000306:	e7fe      	b.n	20000306 <EthernetMAC_IRQHandler+0x2>
20000308:	e7fe      	b.n	20000308 <EthernetMAC_IRQHandler+0x4>

2000030a <Timer2_IRQHandler>:
2000030a:	e7fe      	b.n	2000030a <Timer2_IRQHandler>

2000030c <CAN_IRQHandler>:
2000030c:	e7fe      	b.n	2000030c <CAN_IRQHandler>

2000030e <ENVM0_IRQHandler>:
2000030e:	e7fe      	b.n	2000030e <ENVM0_IRQHandler>

20000310 <ENVM1_IRQHandler>:
20000310:	e7fe      	b.n	20000310 <ENVM1_IRQHandler>

20000312 <ComBlk_IRQHandler>:
20000312:	e7fe      	b.n	20000312 <ComBlk_IRQHandler>

20000314 <USB_IRQHandler>:
20000314:	e7fe      	b.n	20000314 <USB_IRQHandler>

20000316 <USB_DMA_IRQHandler>:
20000316:	e7fe      	b.n	20000316 <USB_DMA_IRQHandler>

20000318 <PLL_Lock_IRQHandler>:
20000318:	e7fe      	b.n	20000318 <PLL_Lock_IRQHandler>

2000031a <PLL_LockLost_IRQHandler>:
2000031a:	e7fe      	b.n	2000031a <PLL_LockLost_IRQHandler>

2000031c <CommSwitchError_IRQHandler>:
2000031c:	e7fe      	b.n	2000031c <CommSwitchError_IRQHandler>

2000031e <CacheError_IRQHandler>:
2000031e:	e7fe      	b.n	2000031e <CacheError_IRQHandler>

20000320 <DDR_IRQHandler>:
20000320:	e7fe      	b.n	20000320 <DDR_IRQHandler>

20000322 <HPDMA_Complete_IRQHandler>:
20000322:	e7fe      	b.n	20000322 <HPDMA_Complete_IRQHandler>

20000324 <HPDMA_Error_IRQHandler>:
20000324:	e7fe      	b.n	20000324 <HPDMA_Error_IRQHandler>

20000326 <ECC_Error_IRQHandler>:
20000326:	e7fe      	b.n	20000326 <ECC_Error_IRQHandler>

20000328 <MDDR_IOCalib_IRQHandler>:
20000328:	e7fe      	b.n	20000328 <MDDR_IOCalib_IRQHandler>

2000032a <FAB_PLL_Lock_IRQHandler>:
2000032a:	e7fe      	b.n	2000032a <FAB_PLL_Lock_IRQHandler>

2000032c <FAB_PLL_LockLost_IRQHandler>:
2000032c:	e7fe      	b.n	2000032c <FAB_PLL_LockLost_IRQHandler>

2000032e <FIC64_IRQHandler>:
2000032e:	e7fe      	b.n	2000032e <FIC64_IRQHandler>

20000330 <FabricIrq0_IRQHandler>:
20000330:	e7fe      	b.n	20000330 <FabricIrq0_IRQHandler>

20000332 <FabricIrq1_IRQHandler>:
20000332:	e7fe      	b.n	20000332 <FabricIrq1_IRQHandler>

20000334 <FabricIrq2_IRQHandler>:
20000334:	e7fe      	b.n	20000334 <FabricIrq2_IRQHandler>

20000336 <FabricIrq3_IRQHandler>:
20000336:	e7fe      	b.n	20000336 <FabricIrq3_IRQHandler>

20000338 <FabricIrq4_IRQHandler>:
20000338:	e7fe      	b.n	20000338 <FabricIrq4_IRQHandler>

2000033a <FabricIrq5_IRQHandler>:
2000033a:	e7fe      	b.n	2000033a <FabricIrq5_IRQHandler>

2000033c <FabricIrq6_IRQHandler>:
2000033c:	e7fe      	b.n	2000033c <FabricIrq6_IRQHandler>

2000033e <FabricIrq7_IRQHandler>:
2000033e:	e7fe      	b.n	2000033e <FabricIrq7_IRQHandler>

20000340 <FabricIrq8_IRQHandler>:
20000340:	e7fe      	b.n	20000340 <FabricIrq8_IRQHandler>

20000342 <FabricIrq9_IRQHandler>:
20000342:	e7fe      	b.n	20000342 <FabricIrq9_IRQHandler>

20000344 <FabricIrq10_IRQHandler>:
20000344:	e7fe      	b.n	20000344 <FabricIrq10_IRQHandler>

20000346 <FabricIrq11_IRQHandler>:
20000346:	e7fe      	b.n	20000346 <FabricIrq11_IRQHandler>

20000348 <FabricIrq12_IRQHandler>:
20000348:	e7fe      	b.n	20000348 <FabricIrq12_IRQHandler>

2000034a <FabricIrq13_IRQHandler>:
2000034a:	e7fe      	b.n	2000034a <FabricIrq13_IRQHandler>

2000034c <FabricIrq14_IRQHandler>:
2000034c:	e7fe      	b.n	2000034c <FabricIrq14_IRQHandler>

2000034e <FabricIrq15_IRQHandler>:
2000034e:	e7fe      	b.n	2000034e <FabricIrq15_IRQHandler>

20000350 <GPIO0_IRQHandler>:
20000350:	e7fe      	b.n	20000350 <GPIO0_IRQHandler>

20000352 <GPIO1_IRQHandler>:
20000352:	e7fe      	b.n	20000352 <GPIO1_IRQHandler>

20000354 <GPIO2_IRQHandler>:
20000354:	e7fe      	b.n	20000354 <GPIO2_IRQHandler>

20000356 <GPIO3_IRQHandler>:
20000356:	e7fe      	b.n	20000356 <GPIO3_IRQHandler>

20000358 <GPIO4_IRQHandler>:
20000358:	e7fe      	b.n	20000358 <GPIO4_IRQHandler>
2000035a:	e7fe      	b.n	2000035a <GPIO4_IRQHandler+0x2>
2000035c:	e7fe      	b.n	2000035c <GPIO4_IRQHandler+0x4>
2000035e:	e7fe      	b.n	2000035e <GPIO4_IRQHandler+0x6>
20000360:	e7fe      	b.n	20000360 <GPIO4_IRQHandler+0x8>

20000362 <GPIO9_IRQHandler>:
20000362:	e7fe      	b.n	20000362 <GPIO9_IRQHandler>

20000364 <GPIO10_IRQHandler>:
20000364:	e7fe      	b.n	20000364 <GPIO10_IRQHandler>

20000366 <GPIO11_IRQHandler>:
20000366:	e7fe      	b.n	20000366 <GPIO11_IRQHandler>

20000368 <GPIO12_IRQHandler>:
20000368:	e7fe      	b.n	20000368 <GPIO12_IRQHandler>

2000036a <GPIO13_IRQHandler>:
2000036a:	e7fe      	b.n	2000036a <GPIO13_IRQHandler>

2000036c <GPIO14_IRQHandler>:
2000036c:	e7fe      	b.n	2000036c <GPIO14_IRQHandler>

2000036e <GPIO15_IRQHandler>:
2000036e:	e7fe      	b.n	2000036e <GPIO15_IRQHandler>

20000370 <GPIO16_IRQHandler>:
20000370:	e7fe      	b.n	20000370 <GPIO16_IRQHandler>

20000372 <GPIO17_IRQHandler>:
20000372:	e7fe      	b.n	20000372 <GPIO17_IRQHandler>

20000374 <GPIO18_IRQHandler>:
20000374:	e7fe      	b.n	20000374 <GPIO18_IRQHandler>

20000376 <GPIO19_IRQHandler>:
20000376:	e7fe      	b.n	20000376 <GPIO19_IRQHandler>

20000378 <GPIO20_IRQHandler>:
20000378:	e7fe      	b.n	20000378 <GPIO20_IRQHandler>

2000037a <GPIO21_IRQHandler>:
2000037a:	e7fe      	b.n	2000037a <GPIO21_IRQHandler>

2000037c <GPIO22_IRQHandler>:
2000037c:	e7fe      	b.n	2000037c <GPIO22_IRQHandler>

2000037e <GPIO23_IRQHandler>:
2000037e:	e7fe      	b.n	2000037e <GPIO23_IRQHandler>

20000380 <GPIO24_IRQHandler>:
20000380:	e7fe      	b.n	20000380 <GPIO24_IRQHandler>

20000382 <GPIO25_IRQHandler>:
20000382:	e7fe      	b.n	20000382 <GPIO25_IRQHandler>

20000384 <GPIO26_IRQHandler>:
20000384:	e7fe      	b.n	20000384 <GPIO26_IRQHandler>

20000386 <GPIO27_IRQHandler>:
20000386:	e7fe      	b.n	20000386 <GPIO27_IRQHandler>

20000388 <GPIO28_IRQHandler>:
20000388:	e7fe      	b.n	20000388 <GPIO28_IRQHandler>

2000038a <GPIO29_IRQHandler>:
2000038a:	e7fe      	b.n	2000038a <GPIO29_IRQHandler>

2000038c <GPIO30_IRQHandler>:
2000038c:	e7fe      	b.n	2000038c <GPIO30_IRQHandler>

2000038e <GPIO31_IRQHandler>:
2000038e:	e7fe      	b.n	2000038e <GPIO31_IRQHandler>

20000390 <mscc_post_hw_cfg_init>:
20000390:	4770      	bx	lr

20000392 <RAM_INIT_PATTERN>:
20000392:	0000      	.short	0x0000
	...

20000396 <HEAP_INIT_PATTERN>:
20000396:	a2a2      	.short	0xa2a2
20000398:	a2a2      	.short	0xa2a2

2000039a <SF2_ESRAM_CR>:
2000039a:	8000      	.short	0x8000
2000039c:	4003      	.short	0x4003

2000039e <SF2_DDR_CR>:
2000039e:	8008      	.short	0x8008
200003a0:	4003      	.short	0x4003

200003a2 <SF2_ENVM_REMAP_CR>:
200003a2:	8010      	.short	0x8010
200003a4:	4003      	.short	0x4003

200003a6 <SF2_DDRB_NB_SIZE>:
200003a6:	8030      	.short	0x8030
200003a8:	4003      	.short	0x4003

200003aa <SF2_DDRB_CR>:
200003aa:	8034      	.short	0x8034
200003ac:	4003      	.short	0x4003

200003ae <SF2_EDAC_CR>:
200003ae:	8038      	.short	0x8038
200003b0:	4003      	.short	0x4003

200003b2 <SF2_MDDR_MODE_CR>:
200003b2:	0818      	.short	0x0818
200003b4:	00004002 	.word	0x00004002
200003b8:	2000d000 	.word	0x2000d000
200003bc:	20010000 	.word	0x20010000
200003c0:	20000411 	.word	0x20000411
200003c4:	00000001 	.word	0x00000001
200003c8:	00000000 	.word	0x00000000
200003cc:	00000001 	.word	0x00000001
200003d0:	00000000 	.word	0x00000000
200003d4:	20000000 	.word	0x20000000
200003d8:	20000000 	.word	0x20000000
200003dc:	20000190 	.word	0x20000190
200003e0:	200004f0 	.word	0x200004f0
200003e4:	200004f0 	.word	0x200004f0
200003e8:	20003c90 	.word	0x20003c90
200003ec:	20003c90 	.word	0x20003c90
200003f0:	20003c90 	.word	0x20003c90
200003f4:	20003d20 	.word	0x20003d20
200003f8:	20003d20 	.word	0x20003d20
200003fc:	20004100 	.word	0x20004100
20000400:	20004100 	.word	0x20004100
20000404:	2000d000 	.word	0x2000d000
20000408:	200038bd 	.word	0x200038bd
2000040c:	200007d5 	.word	0x200007d5

20000410 <SystemInit>:

/***************************************************************************//**
 * See system_m2sxxx.h for details.
 */
void SystemInit(void)
{
20000410:	b580      	push	{r7, lr}
20000412:	af00      	add	r7, sp, #0
     */
#if (MSS_SYS_FACC_INIT_BY_CORTEX == 1)
    complete_clock_config();
#endif

    silicon_workarounds();
20000414:	f000 f838 	bl	20000488 <silicon_workarounds>
    /*--------------------------------------------------------------------------
     * Set STKALIGN to ensure exception stacking starts on 8 bytes address
     * boundary. This ensures compliance with the "Procedure Call Standards for
     * the ARM Architecture" (AAPCS).
     */
    SCB->CCR |= SCB_CCR_STKALIGN_Msk;
20000418:	f64e 5300 	movw	r3, #60672	; 0xed00
2000041c:	f2ce 0300 	movt	r3, #57344	; 0xe000
20000420:	f64e 5200 	movw	r2, #60672	; 0xed00
20000424:	f2ce 0200 	movt	r2, #57344	; 0xe000
20000428:	6952      	ldr	r2, [r2, #20]
2000042a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
2000042e:	615a      	str	r2, [r3, #20]
#endif

    /*--------------------------------------------------------------------------
     * Call user defined configuration function.
     */
    mscc_post_hw_cfg_init();
20000430:	f7ff ffae 	bl	20000390 <mscc_post_hw_cfg_init>
    do
    {
        init_done = CORE_SF2_CFG->INIT_DONE & INIT_DONE_MASK;
    } while (0u == init_done);
#endif
}
20000434:	bd80      	pop	{r7, pc}
20000436:	bf00      	nop

20000438 <get_silicon_revision>:

/*------------------------------------------------------------------------------
  Retrieve silicon revision from system registers.
 */
static uint32_t get_silicon_revision(void)
{
20000438:	b480      	push	{r7}
2000043a:	b083      	sub	sp, #12
2000043c:	af00      	add	r7, sp, #0
    uint32_t silicon_revision;
    uint32_t device_version;
    
    device_version = SYSREG->DEVICE_VERSION;
2000043e:	f248 0300 	movw	r3, #32768	; 0x8000
20000442:	f2c4 0303 	movt	r3, #16387	; 0x4003
20000446:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
2000044a:	607b      	str	r3, [r7, #4]
    switch(device_version)
2000044c:	687a      	ldr	r2, [r7, #4]
2000044e:	f64f 0302 	movw	r3, #63490	; 0xf802
20000452:	429a      	cmp	r2, r3
20000454:	d006      	beq.n	20000464 <get_silicon_revision+0x2c>
20000456:	f64f 0302 	movw	r3, #63490	; 0xf802
2000045a:	f2c0 0301 	movt	r3, #1
2000045e:	429a      	cmp	r2, r3
20000460:	d004      	beq.n	2000046c <get_silicon_revision+0x34>
20000462:	e007      	b.n	20000474 <get_silicon_revision+0x3c>
    {
        case 0x0000F802:
            silicon_revision = M2S050_REV_A_SILICON;
20000464:	f04f 0301 	mov.w	r3, #1
20000468:	603b      	str	r3, [r7, #0]
            break;
2000046a:	e006      	b.n	2000047a <get_silicon_revision+0x42>
            
        case 0x0001F802:
            silicon_revision = M2S050_REV_B_SILICON;
2000046c:	f04f 0302 	mov.w	r3, #2
20000470:	603b      	str	r3, [r7, #0]
            break;
20000472:	e002      	b.n	2000047a <get_silicon_revision+0x42>
            
        default:
            silicon_revision = UNKNOWN_SILICON_REV;
20000474:	f04f 0300 	mov.w	r3, #0
20000478:	603b      	str	r3, [r7, #0]
            break;
    }
    
    return silicon_revision;
2000047a:	683b      	ldr	r3, [r7, #0]
}
2000047c:	4618      	mov	r0, r3
2000047e:	f107 070c 	add.w	r7, r7, #12
20000482:	46bd      	mov	sp, r7
20000484:	bc80      	pop	{r7}
20000486:	4770      	bx	lr

20000488 <silicon_workarounds>:

/*------------------------------------------------------------------------------
  Workarounds for various silicon versions.
 */
static void silicon_workarounds(void)
{
20000488:	b580      	push	{r7, lr}
2000048a:	b082      	sub	sp, #8
2000048c:	af00      	add	r7, sp, #0
    uint32_t silicon_revision;
    
    silicon_revision = get_silicon_revision();
2000048e:	f7ff ffd3 	bl	20000438 <get_silicon_revision>
20000492:	4603      	mov	r3, r0
20000494:	607b      	str	r3, [r7, #4]
    
    switch(silicon_revision)
20000496:	687b      	ldr	r3, [r7, #4]
20000498:	2b01      	cmp	r3, #1
2000049a:	d101      	bne.n	200004a0 <silicon_workarounds+0x18>
    {
        case M2S050_REV_A_SILICON:
            m2s050_rev_a_workarounds();
2000049c:	f000 f804 	bl	200004a8 <m2s050_rev_a_workarounds>
        case UNKNOWN_SILICON_REV:
            /* Fall through. */
        default:
            break;
    }
}
200004a0:	f107 0708 	add.w	r7, r7, #8
200004a4:	46bd      	mov	sp, r7
200004a6:	bd80      	pop	{r7, pc}

200004a8 <m2s050_rev_a_workarounds>:

/*------------------------------------------------------------------------------
  Silicon workarounds for M2S050 rev A.
 */
static void m2s050_rev_a_workarounds(void)
{
200004a8:	b480      	push	{r7}
200004aa:	af00      	add	r7, sp, #0
    /*--------------------------------------------------------------------------
     * Work around a couple of silicon issues:
     */
    /* DDR_CLK_EN <- 1 */
    SYSREG->MSSDDR_FACC1_CR |= (uint32_t)1 << DDR_CLK_EN_SHIFT;
200004ac:	f248 0300 	movw	r3, #32768	; 0x8000
200004b0:	f2c4 0303 	movt	r3, #16387	; 0x4003
200004b4:	f248 0200 	movw	r2, #32768	; 0x8000
200004b8:	f2c4 0203 	movt	r2, #16387	; 0x4003
200004bc:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
200004c0:	f442 7280 	orr.w	r2, r2, #256	; 0x100
200004c4:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    
    /* CONTROLLER_PLL_INIT <- 0 */
    SYSREG->MSSDDR_FACC1_CR = SYSREG->MSSDDR_FACC1_CR & ~CONTROLLER_PLL_INIT_MASK;
200004c8:	f248 0300 	movw	r3, #32768	; 0x8000
200004cc:	f2c4 0303 	movt	r3, #16387	; 0x4003
200004d0:	f248 0200 	movw	r2, #32768	; 0x8000
200004d4:	f2c4 0203 	movt	r2, #16387	; 0x4003
200004d8:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
200004dc:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
200004e0:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
}
200004e4:	46bd      	mov	sp, r7
200004e6:	bc80      	pop	{r7}
200004e8:	4770      	bx	lr
200004ea:	bf00      	nop
200004ec:	0000      	lsls	r0, r0, #0
	...

Disassembly of section .text:

200004f0 <__do_global_dtors_aux>:
200004f0:	f643 5320 	movw	r3, #15648	; 0x3d20
200004f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200004f8:	781a      	ldrb	r2, [r3, #0]
200004fa:	b90a      	cbnz	r2, 20000500 <__do_global_dtors_aux+0x10>
200004fc:	2001      	movs	r0, #1
200004fe:	7018      	strb	r0, [r3, #0]
20000500:	4770      	bx	lr
20000502:	bf00      	nop

20000504 <frame_dummy>:
20000504:	f643 4090 	movw	r0, #15504	; 0x3c90
20000508:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000050c:	b508      	push	{r3, lr}
2000050e:	6803      	ldr	r3, [r0, #0]
20000510:	b12b      	cbz	r3, 2000051e <frame_dummy+0x1a>
20000512:	f240 0300 	movw	r3, #0
20000516:	f2c0 0300 	movt	r3, #0
2000051a:	b103      	cbz	r3, 2000051e <frame_dummy+0x1a>
2000051c:	4798      	blx	r3
2000051e:	bd08      	pop	{r3, pc}

20000520 <dbg_set_channel>:
#include "dbg.h"

extern int *dbgsel;

void dbg_set_channel(void)
{
20000520:	b480      	push	{r7}
20000522:	af00      	add	r7, sp, #0
    *dbgsel = DEBUG_SEL;
20000524:	f643 43e4 	movw	r3, #15588	; 0x3ce4
20000528:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000052c:	681b      	ldr	r3, [r3, #0]
2000052e:	f04f 020b 	mov.w	r2, #11
20000532:	601a      	str	r2, [r3, #0]
}
20000534:	46bd      	mov	sp, r7
20000536:	bc80      	pop	{r7}
20000538:	4770      	bx	lr
2000053a:	bf00      	nop

2000053c <MSS_TIM1_clear_irq>:
  (ISR) in order to prevent the same interrupt event re-triggering a call to the
  ISR.

 */
static __INLINE void MSS_TIM1_clear_irq(void)
{
2000053c:	b480      	push	{r7}
2000053e:	af00      	add	r7, sp, #0
    TIMER->TIM1_RIS = 1u;
20000540:	f244 0300 	movw	r3, #16384	; 0x4000
20000544:	f2c4 0300 	movt	r3, #16384	; 0x4000
20000548:	f04f 0201 	mov.w	r2, #1
2000054c:	611a      	str	r2, [r3, #16]
    /*
      To ensure all the previous instructions are completed, data barrier 
      instruction is used. The “dsb” data barriers instruction completes,
      only after all the previous instruction are completed. 
     */
    __ASM volatile ("dsb");
2000054e:	f3bf 8f4f 	dsb	sy
}
20000552:	46bd      	mov	sp, r7
20000554:	bc80      	pop	{r7}
20000556:	4770      	bx	lr

20000558 <GPIO5_IRQHandler>:
// Main SPI-PDMA ISR
// The PDMA block informs the CoreGPIO block that data is ready for transfer.
// The CoreGPIO block interrupts the M3 via MSS GPIO5.
//
void GPIO5_IRQHandler()
{
20000558:	b580      	push	{r7, lr}
2000055a:	af00      	add	r7, sp, #0
	MSS_GPIO_clear_irq(MSS_GPIO_5);
2000055c:	f04f 0005 	mov.w	r0, #5
20000560:	f003 f81a 	bl	20003598 <MSS_GPIO_clear_irq>
	GPIO_clear_irq(&gpio_core_handle, GPIO_0);
20000564:	f643 70e4 	movw	r0, #16356	; 0x3fe4
20000568:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000056c:	f04f 0100 	mov.w	r1, #0
20000570:	f003 f8fa 	bl	20003768 <GPIO_clear_irq>

	pdma_tx_start = true;
20000574:	f643 5323 	movw	r3, #15651	; 0x3d23
20000578:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000057c:	f04f 0201 	mov.w	r2, #1
20000580:	701a      	strb	r2, [r3, #0]
}
20000582:	bd80      	pop	{r7, pc}

20000584 <GPIO6_IRQHandler>:
//
// ACK ready ISR
// Called when an ACK arrives from one or more NMs.
//
void GPIO6_IRQHandler()
{
20000584:	b580      	push	{r7, lr}
20000586:	af00      	add	r7, sp, #0
	MSS_GPIO_clear_irq(MSS_GPIO_6);
20000588:	f04f 0006 	mov.w	r0, #6
2000058c:	f003 f804 	bl	20003598 <MSS_GPIO_clear_irq>
	GPIO_clear_irq(&gpio_core_handle, GPIO_1);
20000590:	f643 70e4 	movw	r0, #16356	; 0x3fe4
20000594:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000598:	f04f 0101 	mov.w	r1, #1
2000059c:	f003 f8e4 	bl	20003768 <GPIO_clear_irq>

	ack_rdy = true;
200005a0:	f643 5325 	movw	r3, #15653	; 0x3d25
200005a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200005a8:	f04f 0201 	mov.w	r2, #1
200005ac:	701a      	strb	r2, [r3, #0]
}
200005ae:	bd80      	pop	{r7, pc}

200005b0 <GPIO7_IRQHandler>:
//
// FFT ready ISR
// Called when an FFT block has completed conversion.
//
void GPIO7_IRQHandler()
{
200005b0:	b580      	push	{r7, lr}
200005b2:	af00      	add	r7, sp, #0
	MSS_GPIO_clear_irq(MSS_GPIO_7);
200005b4:	f04f 0007 	mov.w	r0, #7
200005b8:	f002 ffee 	bl	20003598 <MSS_GPIO_clear_irq>
	GPIO_clear_irq(&gpio_core_handle, GPIO_2);
200005bc:	f643 70e4 	movw	r0, #16356	; 0x3fe4
200005c0:	f2c2 0000 	movt	r0, #8192	; 0x2000
200005c4:	f04f 0102 	mov.w	r1, #2
200005c8:	f003 f8ce 	bl	20003768 <GPIO_clear_irq>

	fft_rdy = true;
200005cc:	f643 5326 	movw	r3, #15654	; 0x3d26
200005d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200005d4:	f04f 0201 	mov.w	r2, #1
200005d8:	701a      	strb	r2, [r3, #0]
}
200005da:	bd80      	pop	{r7, pc}

200005dc <GPIO8_IRQHandler>:
// Accelerometer FIFO overflow ISR
// This is an error condition - need to drain the FIFO before continuing.
// DOES NOT WORK VERY WELL!!
//
void GPIO8_IRQHandler()
{
200005dc:	b580      	push	{r7, lr}
200005de:	af00      	add	r7, sp, #0
	MSS_GPIO_clear_irq(MSS_GPIO_8);
200005e0:	f04f 0008 	mov.w	r0, #8
200005e4:	f002 ffd8 	bl	20003598 <MSS_GPIO_clear_irq>
	GPIO_clear_irq(&gpio_core_handle, GPIO_3);
200005e8:	f643 70e4 	movw	r0, #16356	; 0x3fe4
200005ec:	f2c2 0000 	movt	r0, #8192	; 0x2000
200005f0:	f04f 0103 	mov.w	r1, #3
200005f4:	f003 f8b8 	bl	20003768 <GPIO_clear_irq>

	MPU6050_clear_FIFO();
200005f8:	f001 f83c 	bl	20001674 <MPU6050_clear_FIFO>
}
200005fc:	bd80      	pop	{r7, pc}
200005fe:	bf00      	nop

20000600 <PDMA_0_isr>:
// PDMA --> SPI complete ISR
// When the SPI block completes a transfer on channel 0 (PDMA Tx) it calls this handler.
// Currently not used.
//
void PDMA_0_isr(void)
{
20000600:	b580      	push	{r7, lr}
20000602:	af00      	add	r7, sp, #0
    PDMA_clear_irq(PDMA_CHANNEL_0);
20000604:	f04f 0000 	mov.w	r0, #0
20000608:	f002 fe58 	bl	200032bc <PDMA_clear_irq>
}
2000060c:	bd80      	pop	{r7, pc}
2000060e:	bf00      	nop

20000610 <PDMA_1_isr>:
//
// SPI --> PDMA complete ISR
// When the SPI block completes a transfer on channel 1 (PDMA Rx) it calls this handler.
//
void PDMA_1_isr(void)
{
20000610:	b580      	push	{r7, lr}
20000612:	af00      	add	r7, sp, #0
    PDMA_clear_irq(PDMA_CHANNEL_1);
20000614:	f04f 0001 	mov.w	r0, #1
20000618:	f002 fe50 	bl	200032bc <PDMA_clear_irq>

    pdma_rx_done = true;
2000061c:	f643 5324 	movw	r3, #15652	; 0x3d24
20000620:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000624:	f04f 0201 	mov.w	r2, #1
20000628:	701a      	strb	r2, [r3, #0]
 }
2000062a:	bd80      	pop	{r7, pc}

2000062c <Timer1_IRQHandler>:
// Idle timer.
// Ensures that an SPI poll will occur even if NM ADC data streaming is off.
// This can occur when either the PDMA block is disabled or record is not enabled in both NMs.
//
void Timer1_IRQHandler()
{
2000062c:	b580      	push	{r7, lr}
2000062e:	af00      	add	r7, sp, #0
 	MSS_TIM1_clear_irq();
20000630:	f7ff ff84 	bl	2000053c <MSS_TIM1_clear_irq>

	poll_tx_start = true;
20000634:	f643 5321 	movw	r3, #15649	; 0x3d21
20000638:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000063c:	f04f 0201 	mov.w	r2, #1
20000640:	701a      	strb	r2, [r3, #0]
}
20000642:	bd80      	pop	{r7, pc}

20000644 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
20000644:	b480      	push	{r7}
20000646:	b083      	sub	sp, #12
20000648:	af00      	add	r7, sp, #0
2000064a:	4603      	mov	r3, r0
2000064c:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
2000064e:	f24e 1300 	movw	r3, #57600	; 0xe100
20000652:	f2ce 0300 	movt	r3, #57344	; 0xe000
20000656:	f997 2007 	ldrsb.w	r2, [r7, #7]
2000065a:	ea4f 1252 	mov.w	r2, r2, lsr #5
2000065e:	79f9      	ldrb	r1, [r7, #7]
20000660:	f001 011f 	and.w	r1, r1, #31
20000664:	f04f 0001 	mov.w	r0, #1
20000668:	fa00 f101 	lsl.w	r1, r0, r1
2000066c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20000670:	f107 070c 	add.w	r7, r7, #12
20000674:	46bd      	mov	sp, r7
20000676:	bc80      	pop	{r7}
20000678:	4770      	bx	lr
2000067a:	bf00      	nop

2000067c <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
2000067c:	b480      	push	{r7}
2000067e:	b083      	sub	sp, #12
20000680:	af00      	add	r7, sp, #0
20000682:	4603      	mov	r3, r0
20000684:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
20000686:	f24e 1300 	movw	r3, #57600	; 0xe100
2000068a:	f2ce 0300 	movt	r3, #57344	; 0xe000
2000068e:	f997 2007 	ldrsb.w	r2, [r7, #7]
20000692:	ea4f 1252 	mov.w	r2, r2, lsr #5
20000696:	79f9      	ldrb	r1, [r7, #7]
20000698:	f001 011f 	and.w	r1, r1, #31
2000069c:	f04f 0001 	mov.w	r0, #1
200006a0:	fa00 f101 	lsl.w	r1, r0, r1
200006a4:	f102 0220 	add.w	r2, r2, #32
200006a8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
200006ac:	f107 070c 	add.w	r7, r7, #12
200006b0:	46bd      	mov	sp, r7
200006b2:	bc80      	pop	{r7}
200006b4:	4770      	bx	lr
200006b6:	bf00      	nop

200006b8 <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
200006b8:	b480      	push	{r7}
200006ba:	b083      	sub	sp, #12
200006bc:	af00      	add	r7, sp, #0
200006be:	4603      	mov	r3, r0
200006c0:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
200006c2:	f24e 1300 	movw	r3, #57600	; 0xe100
200006c6:	f2ce 0300 	movt	r3, #57344	; 0xe000
200006ca:	f997 2007 	ldrsb.w	r2, [r7, #7]
200006ce:	ea4f 1252 	mov.w	r2, r2, lsr #5
200006d2:	79f9      	ldrb	r1, [r7, #7]
200006d4:	f001 011f 	and.w	r1, r1, #31
200006d8:	f04f 0001 	mov.w	r0, #1
200006dc:	fa00 f101 	lsl.w	r1, r0, r1
200006e0:	f102 0260 	add.w	r2, r2, #96	; 0x60
200006e4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
200006e8:	f107 070c 	add.w	r7, r7, #12
200006ec:	46bd      	mov	sp, r7
200006ee:	bc80      	pop	{r7}
200006f0:	4770      	bx	lr
200006f2:	bf00      	nop

200006f4 <MSS_TIM1_init>:
    one-shot mode. Allowed values for this parameter are:
        - MSS_TIMER_PERIODIC_MODE
        - MSS_TIMER_ONE_SHOT_MODE
 */
static __INLINE void MSS_TIM1_init(mss_timer_mode_t mode)
{
200006f4:	b580      	push	{r7, lr}
200006f6:	b082      	sub	sp, #8
200006f8:	af00      	add	r7, sp, #0
200006fa:	4603      	mov	r3, r0
200006fc:	71fb      	strb	r3, [r7, #7]
    NVIC_DisableIRQ(Timer1_IRQn);             /* Disable timer 1 irq in the Cortex-M3 NVIC */  
200006fe:	f04f 000e 	mov.w	r0, #14
20000702:	f7ff ffbb 	bl	2000067c <NVIC_DisableIRQ>
    
    SYSREG->SOFT_RST_CR &= ~SYSREG_TIMER_SOFTRESET_MASK; /* Take timer block out of reset */
20000706:	f248 0300 	movw	r3, #32768	; 0x8000
2000070a:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000070e:	f248 0200 	movw	r2, #32768	; 0x8000
20000712:	f2c4 0203 	movt	r2, #16387	; 0x4003
20000716:	6c92      	ldr	r2, [r2, #72]	; 0x48
20000718:	f022 0240 	bic.w	r2, r2, #64	; 0x40
2000071c:	649a      	str	r2, [r3, #72]	; 0x48
    
    TIMER->TIM64_MODE = 0u;                     /* switch to 32 bits mode */
2000071e:	f244 0300 	movw	r3, #16384	; 0x4000
20000722:	f2c4 0300 	movt	r3, #16384	; 0x4000
20000726:	f04f 0200 	mov.w	r2, #0
2000072a:	655a      	str	r2, [r3, #84]	; 0x54
    
    TIMER_BITBAND->TIM1ENABLE = 0u;             /* disable timer */
2000072c:	f240 0300 	movw	r3, #0
20000730:	f2c4 2308 	movt	r3, #16904	; 0x4208
20000734:	f04f 0200 	mov.w	r2, #0
20000738:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    TIMER_BITBAND->TIM1INTEN = 0u;              /* disable interrupt */
2000073c:	f240 0300 	movw	r3, #0
20000740:	f2c4 2308 	movt	r3, #16904	; 0x4208
20000744:	f04f 0200 	mov.w	r2, #0
20000748:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
    TIMER_BITBAND->TIM1MODE = (uint32_t)mode;   /* set mode (continuous/one-shot) */
2000074c:	f240 0300 	movw	r3, #0
20000750:	f2c4 2308 	movt	r3, #16904	; 0x4208
20000754:	79fa      	ldrb	r2, [r7, #7]
20000756:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    
    TIMER->TIM1_RIS = 1u;                       /* clear timer 1 interrupt */
2000075a:	f244 0300 	movw	r3, #16384	; 0x4000
2000075e:	f2c4 0300 	movt	r3, #16384	; 0x4000
20000762:	f04f 0201 	mov.w	r2, #1
20000766:	611a      	str	r2, [r3, #16]
    NVIC_ClearPendingIRQ(Timer1_IRQn);          /* clear timer 1 interrupt within NVIC */
20000768:	f04f 000e 	mov.w	r0, #14
2000076c:	f7ff ffa4 	bl	200006b8 <NVIC_ClearPendingIRQ>
}
20000770:	f107 0708 	add.w	r7, r7, #8
20000774:	46bd      	mov	sp, r7
20000776:	bd80      	pop	{r7, pc}

20000778 <MSS_TIM1_start>:
  MSS_TIM1_load_immediate() or MSS_TIM1_load_background() functions. 
  Note: The MSS_TIM1_start() function is also used to resume the down-counter
        if previously stopped using the MSS_TIM1_stop() function.
 */
static __INLINE void MSS_TIM1_start(void)
{
20000778:	b480      	push	{r7}
2000077a:	af00      	add	r7, sp, #0
    TIMER_BITBAND->TIM1ENABLE = 1u;    /* enable timer */
2000077c:	f240 0300 	movw	r3, #0
20000780:	f2c4 2308 	movt	r3, #16904	; 0x4208
20000784:	f04f 0201 	mov.w	r2, #1
20000788:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
2000078c:	46bd      	mov	sp, r7
2000078e:	bc80      	pop	{r7}
20000790:	4770      	bx	lr
20000792:	bf00      	nop

20000794 <MSS_TIM1_load_background>:
    Timer 1 down-counter the next time the down-counter reaches zero. The Timer
    1 down-counter will start decrementing from this value after the current
    count expires.
 */
static __INLINE void MSS_TIM1_load_background(uint32_t load_value)
{
20000794:	b480      	push	{r7}
20000796:	b083      	sub	sp, #12
20000798:	af00      	add	r7, sp, #0
2000079a:	6078      	str	r0, [r7, #4]
    TIMER->TIM1_BGLOADVAL = load_value;
2000079c:	f244 0300 	movw	r3, #16384	; 0x4000
200007a0:	f2c4 0300 	movt	r3, #16384	; 0x4000
200007a4:	687a      	ldr	r2, [r7, #4]
200007a6:	609a      	str	r2, [r3, #8]
}
200007a8:	f107 070c 	add.w	r7, r7, #12
200007ac:	46bd      	mov	sp, r7
200007ae:	bc80      	pop	{r7}
200007b0:	4770      	bx	lr
200007b2:	bf00      	nop

200007b4 <MSS_TIM1_enable_irq>:
  implementation of the Timer1_IRQHandler() function, that will override the
  default implementation, to suit your application.

 */
static __INLINE void MSS_TIM1_enable_irq(void)
{
200007b4:	b580      	push	{r7, lr}
200007b6:	af00      	add	r7, sp, #0
    TIMER_BITBAND->TIM1INTEN = 1u;
200007b8:	f240 0300 	movw	r3, #0
200007bc:	f2c4 2308 	movt	r3, #16904	; 0x4208
200007c0:	f04f 0201 	mov.w	r2, #1
200007c4:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
    NVIC_EnableIRQ(Timer1_IRQn);
200007c8:	f04f 000e 	mov.w	r0, #14
200007cc:	f7ff ff3a 	bl	20000644 <NVIC_EnableIRQ>
}
200007d0:	bd80      	pop	{r7, pc}
200007d2:	bf00      	nop

200007d4 <main>:
uint8_t *PDMA_find_command(void);
void SPI_read_check(uint8_t *cmd);
int sys_init(void);

int main()
{
200007d4:	b580      	push	{r7, lr}
200007d6:	b086      	sub	sp, #24
200007d8:	af00      	add	r7, sp, #0
	// Assert rstb in the HDL blocks
	SYSREG->SOFT_RST_CR |= SYSREG_FPGA_SOFTRESET_MASK;
200007da:	f248 0300 	movw	r3, #32768	; 0x8000
200007de:	f2c4 0303 	movt	r3, #16387	; 0x4003
200007e2:	f248 0200 	movw	r2, #32768	; 0x8000
200007e6:	f2c4 0203 	movt	r2, #16387	; 0x4003
200007ea:	6c92      	ldr	r2, [r2, #72]	; 0x48
200007ec:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
200007f0:	649a      	str	r2, [r3, #72]	; 0x48
	SYSREG->SOFT_RST_CR &= ~SYSREG_FPGA_SOFTRESET_MASK;
200007f2:	f248 0300 	movw	r3, #32768	; 0x8000
200007f6:	f2c4 0303 	movt	r3, #16387	; 0x4003
200007fa:	f248 0200 	movw	r2, #32768	; 0x8000
200007fe:	f2c4 0203 	movt	r2, #16387	; 0x4003
20000802:	6c92      	ldr	r2, [r2, #72]	; 0x48
20000804:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
20000808:	649a      	str	r2, [r3, #72]	; 0x48

	// debug
	memset((char *) dbg_rx_pdma_array, 0, sizeof(dbg_rx_pdma_array));
2000080a:	f643 60dc 	movw	r0, #16092	; 0x3edc
2000080e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000812:	f04f 0100 	mov.w	r1, #0
20000816:	f04f 028c 	mov.w	r2, #140	; 0x8c
2000081a:	f003 f93f 	bl	20003a9c <memset>

	// Set debug channel for HDL debug_mux.v, To select, in dbg.h set DEBUG_SEL to one of the DEBUG_... #defines.
	dbg_set_channel();
2000081e:	f7ff fe7f 	bl	20000520 <dbg_set_channel>

//	set_system_mode(NM0_EMULATE_EN | NM1_EMULATE_EN);

    sys_init();
20000822:	f000 fd23 	bl	2000126c <sys_init>

	// Enable or disable PDMA block, accelerometer IRQ, NM emulation, accelerometer emulation, or PDMA emulation
	set_system_mode(PDMA_EN | ACC_IRQ_EN);
20000826:	f643 43cc 	movw	r3, #15564	; 0x3ccc
2000082a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000082e:	681a      	ldr	r2, [r3, #0]
20000830:	f643 43cc 	movw	r3, #15564	; 0x3ccc
20000834:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000838:	681b      	ldr	r3, [r3, #0]
2000083a:	681b      	ldr	r3, [r3, #0]
2000083c:	ea4f 4313 	mov.w	r3, r3, lsr #16
20000840:	ea4f 4303 	mov.w	r3, r3, lsl #16
20000844:	f043 0303 	orr.w	r3, r3, #3
20000848:	6013      	str	r3, [r2, #0]
//	set_system_mode(PDMA_EN | ACC_IRQ_EN | ARTIFACT_EN | FFT_EN | ACC_EMULATE_EN | NM0_EMULATE_EN | NM1_EMULATE_EN);

	// Select the channel for FFT. One channel can be selected for each NM.
	set_FFT_channel(0,9);
2000084a:	f04f 0000 	mov.w	r0, #0
2000084e:	f04f 0109 	mov.w	r1, #9
20000852:	f001 f9d7 	bl	20001c04 <set_FFT_channel>
	set_FFT_channel(1,5);
20000856:	f04f 0001 	mov.w	r0, #1
2000085a:	f04f 0105 	mov.w	r1, #5
2000085e:	f001 f9d1 	bl	20001c04 <set_FFT_channel>
20000862:	e000      	b.n	20000866 <main+0x92>
			}
			while (*status & NM1_FFT_RDY_BIT) {
				fftval = *n1fft;
			}
        }
	}
20000864:	bf00      	nop
		// All SPI I/O and Tx/Rx buffering is done here.
		// A complete event-driven solution can be realized by putting the M3 to sleep pending an interrupt.
		//

		// The poll timer has expired so start a poll if streaming is off
		if (poll_tx_start && !stream_en) {
20000866:	f643 5321 	movw	r3, #15649	; 0x3d21
2000086a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000086e:	781b      	ldrb	r3, [r3, #0]
20000870:	2b00      	cmp	r3, #0
20000872:	d019      	beq.n	200008a8 <main+0xd4>
20000874:	f643 63d4 	movw	r3, #16084	; 0x3ed4
20000878:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000087c:	781b      	ldrb	r3, [r3, #0]
2000087e:	f083 0301 	eor.w	r3, r3, #1
20000882:	b2db      	uxtb	r3, r3
20000884:	2b00      	cmp	r3, #0
20000886:	d00f      	beq.n	200008a8 <main+0xd4>
			poll_tx_start = false;
20000888:	f643 5321 	movw	r3, #15649	; 0x3d21
2000088c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000890:	f04f 0200 	mov.w	r2, #0
20000894:	701a      	strb	r2, [r3, #0]
			poll_tx_buf[0] = 0;
20000896:	f643 5328 	movw	r3, #15656	; 0x3d28
2000089a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000089e:	f04f 0200 	mov.w	r2, #0
200008a2:	701a      	strb	r2, [r3, #0]
   			SPI_poll_write_read();
200008a4:	f000 f9ee 	bl	20000c84 <SPI_poll_write_read>
   		}

		// A valid command from the GUI has been detected in a poll.
		if (poll_rx_rdy && !stream_en) {
200008a8:	f643 5322 	movw	r3, #15650	; 0x3d22
200008ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
200008b0:	781b      	ldrb	r3, [r3, #0]
200008b2:	2b00      	cmp	r3, #0
200008b4:	d016      	beq.n	200008e4 <main+0x110>
200008b6:	f643 63d4 	movw	r3, #16084	; 0x3ed4
200008ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
200008be:	781b      	ldrb	r3, [r3, #0]
200008c0:	f083 0301 	eor.w	r3, r3, #1
200008c4:	b2db      	uxtb	r3, r3
200008c6:	2b00      	cmp	r3, #0
200008c8:	d00c      	beq.n	200008e4 <main+0x110>
			poll_rx_rdy = false;
200008ca:	f643 5322 	movw	r3, #15650	; 0x3d22
200008ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
200008d2:	f04f 0200 	mov.w	r2, #0
200008d6:	701a      	strb	r2, [r3, #0]
			SPI_read_check(poll_rx_buf);
200008d8:	f643 50f0 	movw	r0, #15856	; 0x3df0
200008dc:	f2c2 0000 	movt	r0, #8192	; 0x2000
200008e0:	f000 fade 	bl	20000ea0 <SPI_read_check>
		}

		// The PDMA interrupt has occurred indicating an ADC frame is ready for transfer via SPI.
		// If streaming is enabled start Tx and Rx PDMA channels.
		if (pdma_tx_start && stream_en) {
200008e4:	f643 5323 	movw	r3, #15651	; 0x3d23
200008e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200008ec:	781b      	ldrb	r3, [r3, #0]
200008ee:	2b00      	cmp	r3, #0
200008f0:	d00f      	beq.n	20000912 <main+0x13e>
200008f2:	f643 63d4 	movw	r3, #16084	; 0x3ed4
200008f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200008fa:	781b      	ldrb	r3, [r3, #0]
200008fc:	2b00      	cmp	r3, #0
200008fe:	d008      	beq.n	20000912 <main+0x13e>
			pdma_tx_start = false;
20000900:	f643 5323 	movw	r3, #15651	; 0x3d23
20000904:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000908:	f04f 0200 	mov.w	r2, #0
2000090c:	701a      	strb	r2, [r3, #0]
			SPI_PDMA_write_read();
2000090e:	f000 fa03 	bl	20000d18 <SPI_PDMA_write_read>
		}

		// The PDMA Rx channel has completed a transfer.
		// If streaming is still enabled check the Rx channel for a command.
		if (pdma_rx_done && stream_en) {
20000912:	f643 5324 	movw	r3, #15652	; 0x3d24
20000916:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000091a:	781b      	ldrb	r3, [r3, #0]
2000091c:	2b00      	cmp	r3, #0
2000091e:	d013      	beq.n	20000948 <main+0x174>
20000920:	f643 63d4 	movw	r3, #16084	; 0x3ed4
20000924:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000928:	781b      	ldrb	r3, [r3, #0]
2000092a:	2b00      	cmp	r3, #0
2000092c:	d00c      	beq.n	20000948 <main+0x174>
			pdma_rx_done = false;
2000092e:	f643 5324 	movw	r3, #15652	; 0x3d24
20000932:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000936:	f04f 0200 	mov.w	r2, #0
2000093a:	701a      	strb	r2, [r3, #0]
			SPI_read_check(PDMA_find_command());
2000093c:	f000 fa3e 	bl	20000dbc <PDMA_find_command>
20000940:	4603      	mov	r3, r0
20000942:	4618      	mov	r0, r3
20000944:	f000 faac 	bl	20000ea0 <SPI_read_check>
		}

		// An ACK (register read) packet has been received by the HDL.
		// Either manage stims or forward the ACK to the GUI.
		if (ack_rdy && !stream_en) {
20000948:	f643 5325 	movw	r3, #15653	; 0x3d25
2000094c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000950:	781b      	ldrb	r3, [r3, #0]
20000952:	2b00      	cmp	r3, #0
20000954:	f000 8162 	beq.w	20000c1c <main+0x448>
20000958:	f643 63d4 	movw	r3, #16084	; 0x3ed4
2000095c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000960:	781b      	ldrb	r3, [r3, #0]
20000962:	f083 0301 	eor.w	r3, r3, #1
20000966:	b2db      	uxtb	r3, r3
20000968:	2b00      	cmp	r3, #0
2000096a:	f000 8157 	beq.w	20000c1c <main+0x448>
			uint32_t stat;
			uint32_t addr_n_data;
			uint16_t addr, data;
			bool ackok;

			ack_rdy = false;
2000096e:	f643 5325 	movw	r3, #15653	; 0x3d25
20000972:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000976:	f04f 0200 	mov.w	r2, #0
2000097a:	701a      	strb	r2, [r3, #0]

			stat = *status;
2000097c:	f643 43f8 	movw	r3, #15608	; 0x3cf8
20000980:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000984:	681b      	ldr	r3, [r3, #0]
20000986:	681b      	ldr	r3, [r3, #0]
20000988:	607b      	str	r3, [r7, #4]

        	if (stat & NM0_ACK_RDY_BIT)
2000098a:	687b      	ldr	r3, [r7, #4]
2000098c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
20000990:	2b00      	cmp	r3, #0
20000992:	f000 809f 	beq.w	20000ad4 <main+0x300>
			{
				addr_n_data = *n0ack;
20000996:	f643 43fc 	movw	r3, #15612	; 0x3cfc
2000099a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000099e:	681b      	ldr	r3, [r3, #0]
200009a0:	681b      	ldr	r3, [r3, #0]
200009a2:	60bb      	str	r3, [r7, #8]
				addr = (addr_n_data >> 16) & 0xffff;
200009a4:	68bb      	ldr	r3, [r7, #8]
200009a6:	ea4f 4313 	mov.w	r3, r3, lsr #16
200009aa:	81fb      	strh	r3, [r7, #14]
				data = addr_n_data & 0xffff;
200009ac:	68bb      	ldr	r3, [r7, #8]
200009ae:	823b      	strh	r3, [r7, #16]

		        if (stim_rep > 0) // if we still have a stim train to start
200009b0:	f643 63d0 	movw	r3, #16080	; 0x3ed0
200009b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009b8:	681b      	ldr	r3, [r3, #0]
200009ba:	2b00      	cmp	r3, #0
200009bc:	d043      	beq.n	20000a46 <main+0x272>
				{
		        	ackok = (addr == 0x01);
200009be:	89fb      	ldrh	r3, [r7, #14]
200009c0:	2b01      	cmp	r3, #1
200009c2:	bf14      	ite	ne
200009c4:	2300      	movne	r3, #0
200009c6:	2301      	moveq	r3, #1
200009c8:	74fb      	strb	r3, [r7, #19]

		        	if (ackok & !(data & (1 << 15))) // previous stim ended, so start a new train
200009ca:	7cfa      	ldrb	r2, [r7, #19]
200009cc:	8a3b      	ldrh	r3, [r7, #16]
200009ce:	b21b      	sxth	r3, r3
200009d0:	ea6f 0303 	mvn.w	r3, r3
200009d4:	ea4f 73d3 	mov.w	r3, r3, lsr #31
200009d8:	ea02 0303 	and.w	r3, r2, r3
200009dc:	2b00      	cmp	r3, #0
200009de:	d02b      	beq.n	20000a38 <main+0x264>
		        	{
		        		stim_rep--;
200009e0:	f643 63d0 	movw	r3, #16080	; 0x3ed0
200009e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009e8:	681b      	ldr	r3, [r3, #0]
200009ea:	f103 32ff 	add.w	r2, r3, #4294967295
200009ee:	f643 63d0 	movw	r3, #16080	; 0x3ed0
200009f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200009f6:	601a      	str	r2, [r3, #0]
		        		sendNMcmd(NM0, 0x09);
200009f8:	f04f 0000 	mov.w	r0, #0
200009fc:	f04f 0109 	mov.w	r1, #9
20000a00:	f001 f9ca 	bl	20001d98 <sendNMcmd>
		        		stim_count++;
20000a04:	f643 63c8 	movw	r3, #16072	; 0x3ec8
20000a08:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a0c:	681b      	ldr	r3, [r3, #0]
20000a0e:	f103 0201 	add.w	r2, r3, #1
20000a12:	f643 63c8 	movw	r3, #16072	; 0x3ec8
20000a16:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a1a:	601a      	str	r2, [r3, #0]
		        		if (stim_rep > 0)
20000a1c:	f643 63d0 	movw	r3, #16080	; 0x3ed0
20000a20:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a24:	681b      	ldr	r3, [r3, #0]
20000a26:	2b00      	cmp	r3, #0
20000a28:	d053      	beq.n	20000ad2 <main+0x2fe>
		        		{
		        			postNMregRead(NM0, 0x01);
20000a2a:	f04f 0000 	mov.w	r0, #0
20000a2e:	f04f 0101 	mov.w	r1, #1
20000a32:	f001 f8f5 	bl	20001c20 <postNMregRead>
		        		}
		        	}
		        	else
		        	{
		        		postNMregRead(NM0, 0x01);
20000a36:	e04d      	b.n	20000ad4 <main+0x300>
20000a38:	f04f 0000 	mov.w	r0, #0
20000a3c:	f04f 0101 	mov.w	r1, #1
20000a40:	f001 f8ee 	bl	20001c20 <postNMregRead>
20000a44:	e046      	b.n	20000ad4 <main+0x300>
		        	}
				}
		        else if (data_ack_req & 0x01) // not doing stim on NM0, so continue with register operations
20000a46:	f643 4394 	movw	r3, #15508	; 0x3c94
20000a4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a4e:	681b      	ldr	r3, [r3, #0]
20000a50:	f003 0301 	and.w	r3, r3, #1
20000a54:	b2db      	uxtb	r3, r3
20000a56:	2b00      	cmp	r3, #0
20000a58:	d03c      	beq.n	20000ad4 <main+0x300>
				{
		   	 		poll_tx_buf[0] = 0xff;
20000a5a:	f643 5328 	movw	r3, #15656	; 0x3d28
20000a5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a62:	f04f 32ff 	mov.w	r2, #4294967295
20000a66:	701a      	strb	r2, [r3, #0]
		   	 		poll_tx_buf[1] = (char) ((addr_n_data >> 16) & 0xff);
20000a68:	68bb      	ldr	r3, [r7, #8]
20000a6a:	ea4f 4313 	mov.w	r3, r3, lsr #16
20000a6e:	b2da      	uxtb	r2, r3
20000a70:	f643 5328 	movw	r3, #15656	; 0x3d28
20000a74:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a78:	705a      	strb	r2, [r3, #1]
		   	 		poll_tx_buf[2] = (char) ((addr_n_data >> 24) & 0xff);
20000a7a:	68bb      	ldr	r3, [r7, #8]
20000a7c:	ea4f 6313 	mov.w	r3, r3, lsr #24
20000a80:	b2da      	uxtb	r2, r3
20000a82:	f643 5328 	movw	r3, #15656	; 0x3d28
20000a86:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a8a:	709a      	strb	r2, [r3, #2]
		   	 		poll_tx_buf[3] = (char) ((addr_n_data >> 0) & 0xff);
20000a8c:	68bb      	ldr	r3, [r7, #8]
20000a8e:	b2da      	uxtb	r2, r3
20000a90:	f643 5328 	movw	r3, #15656	; 0x3d28
20000a94:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a98:	70da      	strb	r2, [r3, #3]
		   	 		poll_tx_buf[4] = (char) ((addr_n_data >> 8) & 0xff);
20000a9a:	68bb      	ldr	r3, [r7, #8]
20000a9c:	ea4f 2313 	mov.w	r3, r3, lsr #8
20000aa0:	b2da      	uxtb	r2, r3
20000aa2:	f643 5328 	movw	r3, #15656	; 0x3d28
20000aa6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000aaa:	711a      	strb	r2, [r3, #4]

		   	 		delay_us(100);	// The Nordic is sensitive to turnaround time so delay a little here to make sure it's ready
20000aac:	f04f 0064 	mov.w	r0, #100	; 0x64
20000ab0:	f001 f9cc 	bl	20001e4c <delay_us>

		   	 		SPI_poll_write_read();
20000ab4:	f000 f8e6 	bl	20000c84 <SPI_poll_write_read>

		   			data_ack_req &= ~0x01;
20000ab8:	f643 4394 	movw	r3, #15508	; 0x3c94
20000abc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000ac0:	681b      	ldr	r3, [r3, #0]
20000ac2:	f023 0201 	bic.w	r2, r3, #1
20000ac6:	f643 4394 	movw	r3, #15508	; 0x3c94
20000aca:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000ace:	601a      	str	r2, [r3, #0]
20000ad0:	e000      	b.n	20000ad4 <main+0x300>
		        			postNMregRead(NM0, 0x01);
		        		}
		        	}
		        	else
		        	{
		        		postNMregRead(NM0, 0x01);
20000ad2:	bf00      	nop
					// debug only
//		   			dbg_record_nm_ack(addr_n_data);
				}
			}

            if (stat & NM1_ACK_RDY_BIT)
20000ad4:	687b      	ldr	r3, [r7, #4]
20000ad6:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
20000ada:	2b00      	cmp	r3, #0
20000adc:	f000 809e 	beq.w	20000c1c <main+0x448>
            {
				addr_n_data = *n1ack;
20000ae0:	f643 5304 	movw	r3, #15620	; 0x3d04
20000ae4:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000ae8:	681b      	ldr	r3, [r3, #0]
20000aea:	681b      	ldr	r3, [r3, #0]
20000aec:	60bb      	str	r3, [r7, #8]
				addr = (addr_n_data >> 16) & 0xffff;
20000aee:	68bb      	ldr	r3, [r7, #8]
20000af0:	ea4f 4313 	mov.w	r3, r3, lsr #16
20000af4:	81fb      	strh	r3, [r7, #14]
				data = addr_n_data & 0xffff;
20000af6:	68bb      	ldr	r3, [r7, #8]
20000af8:	823b      	strh	r3, [r7, #16]

		        if (stim_rep > 0) // if we still have a stim train to start
20000afa:	f643 63d0 	movw	r3, #16080	; 0x3ed0
20000afe:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000b02:	681b      	ldr	r3, [r3, #0]
20000b04:	2b00      	cmp	r3, #0
20000b06:	d043      	beq.n	20000b90 <main+0x3bc>
				{
		        	ackok = (addr == 0x01);
20000b08:	89fb      	ldrh	r3, [r7, #14]
20000b0a:	2b01      	cmp	r3, #1
20000b0c:	bf14      	ite	ne
20000b0e:	2300      	movne	r3, #0
20000b10:	2301      	moveq	r3, #1
20000b12:	74fb      	strb	r3, [r7, #19]

		        	if (ackok & !(data & (1 << 15))) // previous stim ended, so start a new train
20000b14:	7cfa      	ldrb	r2, [r7, #19]
20000b16:	8a3b      	ldrh	r3, [r7, #16]
20000b18:	b21b      	sxth	r3, r3
20000b1a:	ea6f 0303 	mvn.w	r3, r3
20000b1e:	ea4f 73d3 	mov.w	r3, r3, lsr #31
20000b22:	ea02 0303 	and.w	r3, r2, r3
20000b26:	2b00      	cmp	r3, #0
20000b28:	d02b      	beq.n	20000b82 <main+0x3ae>
		        	{
		        		stim_rep--;
20000b2a:	f643 63d0 	movw	r3, #16080	; 0x3ed0
20000b2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000b32:	681b      	ldr	r3, [r3, #0]
20000b34:	f103 32ff 	add.w	r2, r3, #4294967295
20000b38:	f643 63d0 	movw	r3, #16080	; 0x3ed0
20000b3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000b40:	601a      	str	r2, [r3, #0]
		        		sendNMcmd(NM1, 0x09);
20000b42:	f04f 0001 	mov.w	r0, #1
20000b46:	f04f 0109 	mov.w	r1, #9
20000b4a:	f001 f925 	bl	20001d98 <sendNMcmd>
		        		stim_count++;
20000b4e:	f643 63c8 	movw	r3, #16072	; 0x3ec8
20000b52:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000b56:	681b      	ldr	r3, [r3, #0]
20000b58:	f103 0201 	add.w	r2, r3, #1
20000b5c:	f643 63c8 	movw	r3, #16072	; 0x3ec8
20000b60:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000b64:	601a      	str	r2, [r3, #0]
		        		if (stim_rep > 0)
20000b66:	f643 63d0 	movw	r3, #16080	; 0x3ed0
20000b6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000b6e:	681b      	ldr	r3, [r3, #0]
20000b70:	2b00      	cmp	r3, #0
20000b72:	d052      	beq.n	20000c1a <main+0x446>
		        		{
		        			postNMregRead(NM1, 0x01);
20000b74:	f04f 0001 	mov.w	r0, #1
20000b78:	f04f 0101 	mov.w	r1, #1
20000b7c:	f001 f850 	bl	20001c20 <postNMregRead>
		        		}
		        	}
		        	else
		        	{
		        		postNMregRead(NM1, 0x01);
20000b80:	e04c      	b.n	20000c1c <main+0x448>
20000b82:	f04f 0001 	mov.w	r0, #1
20000b86:	f04f 0101 	mov.w	r1, #1
20000b8a:	f001 f849 	bl	20001c20 <postNMregRead>
20000b8e:	e045      	b.n	20000c1c <main+0x448>
		        	}
				}
		        else if (data_ack_req & 0x02) // not doing stim on NM1, so continue with register operations
20000b90:	f643 4394 	movw	r3, #15508	; 0x3c94
20000b94:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000b98:	681b      	ldr	r3, [r3, #0]
20000b9a:	f003 0302 	and.w	r3, r3, #2
20000b9e:	2b00      	cmp	r3, #0
20000ba0:	d03c      	beq.n	20000c1c <main+0x448>
				{
		   	 		poll_tx_buf[0] = 0xff;
20000ba2:	f643 5328 	movw	r3, #15656	; 0x3d28
20000ba6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000baa:	f04f 32ff 	mov.w	r2, #4294967295
20000bae:	701a      	strb	r2, [r3, #0]
		   	 		poll_tx_buf[1] = (char) ((addr_n_data >> 16) & 0xff);
20000bb0:	68bb      	ldr	r3, [r7, #8]
20000bb2:	ea4f 4313 	mov.w	r3, r3, lsr #16
20000bb6:	b2da      	uxtb	r2, r3
20000bb8:	f643 5328 	movw	r3, #15656	; 0x3d28
20000bbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000bc0:	705a      	strb	r2, [r3, #1]
		   	 		poll_tx_buf[2] = (char) ((addr_n_data >> 24) & 0xff);
20000bc2:	68bb      	ldr	r3, [r7, #8]
20000bc4:	ea4f 6313 	mov.w	r3, r3, lsr #24
20000bc8:	b2da      	uxtb	r2, r3
20000bca:	f643 5328 	movw	r3, #15656	; 0x3d28
20000bce:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000bd2:	709a      	strb	r2, [r3, #2]
		   	 		poll_tx_buf[3] = (char) ((addr_n_data >> 0) & 0xff);
20000bd4:	68bb      	ldr	r3, [r7, #8]
20000bd6:	b2da      	uxtb	r2, r3
20000bd8:	f643 5328 	movw	r3, #15656	; 0x3d28
20000bdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000be0:	70da      	strb	r2, [r3, #3]
		   	 		poll_tx_buf[4] = (char) ((addr_n_data >> 8) & 0xff);
20000be2:	68bb      	ldr	r3, [r7, #8]
20000be4:	ea4f 2313 	mov.w	r3, r3, lsr #8
20000be8:	b2da      	uxtb	r2, r3
20000bea:	f643 5328 	movw	r3, #15656	; 0x3d28
20000bee:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000bf2:	711a      	strb	r2, [r3, #4]

		   	 		delay_us(100);	// The Nordic is sensitive to turnaround time so delay a little here to make sure it's ready
20000bf4:	f04f 0064 	mov.w	r0, #100	; 0x64
20000bf8:	f001 f928 	bl	20001e4c <delay_us>

		   	 		SPI_poll_write_read();
20000bfc:	f000 f842 	bl	20000c84 <SPI_poll_write_read>

					data_ack_req &= ~0x02;
20000c00:	f643 4394 	movw	r3, #15508	; 0x3c94
20000c04:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c08:	681b      	ldr	r3, [r3, #0]
20000c0a:	f023 0202 	bic.w	r2, r3, #2
20000c0e:	f643 4394 	movw	r3, #15508	; 0x3c94
20000c12:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c16:	601a      	str	r2, [r3, #0]
20000c18:	e000      	b.n	20000c1c <main+0x448>
		        			postNMregRead(NM1, 0x01);
		        		}
		        	}
		        	else
		        	{
		        		postNMregRead(NM1, 0x01);
20000c1a:	bf00      	nop
//		   			dbg_record_nm_ack(addr_n_data);
				}
            }
		}

		if (fft_rdy) {
20000c1c:	f643 5326 	movw	r3, #15654	; 0x3d26
20000c20:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c24:	781b      	ldrb	r3, [r3, #0]
20000c26:	2b00      	cmp	r3, #0
20000c28:	f43f ae1c 	beq.w	20000864 <main+0x90>
			fft_rdy = false;
20000c2c:	f643 5326 	movw	r3, #15654	; 0x3d26
20000c30:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c34:	f04f 0200 	mov.w	r2, #0
20000c38:	701a      	strb	r2, [r3, #0]

			uint32_t fftval;

			while (*status & NM0_FFT_RDY_BIT) {
20000c3a:	e006      	b.n	20000c4a <main+0x476>
				fftval = *n0fft;
20000c3c:	f643 5300 	movw	r3, #15616	; 0x3d00
20000c40:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c44:	681b      	ldr	r3, [r3, #0]
20000c46:	681b      	ldr	r3, [r3, #0]
20000c48:	617b      	str	r3, [r7, #20]
		if (fft_rdy) {
			fft_rdy = false;

			uint32_t fftval;

			while (*status & NM0_FFT_RDY_BIT) {
20000c4a:	f643 43f8 	movw	r3, #15608	; 0x3cf8
20000c4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c52:	681b      	ldr	r3, [r3, #0]
20000c54:	681b      	ldr	r3, [r3, #0]
20000c56:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
20000c5a:	2b00      	cmp	r3, #0
20000c5c:	d1ee      	bne.n	20000c3c <main+0x468>
				fftval = *n0fft;
			}
			while (*status & NM1_FFT_RDY_BIT) {
20000c5e:	e006      	b.n	20000c6e <main+0x49a>
				fftval = *n1fft;
20000c60:	f643 5308 	movw	r3, #15624	; 0x3d08
20000c64:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c68:	681b      	ldr	r3, [r3, #0]
20000c6a:	681b      	ldr	r3, [r3, #0]
20000c6c:	617b      	str	r3, [r7, #20]
			uint32_t fftval;

			while (*status & NM0_FFT_RDY_BIT) {
				fftval = *n0fft;
			}
			while (*status & NM1_FFT_RDY_BIT) {
20000c6e:	f643 43f8 	movw	r3, #15608	; 0x3cf8
20000c72:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c76:	681b      	ldr	r3, [r3, #0]
20000c78:	681b      	ldr	r3, [r3, #0]
20000c7a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
20000c7e:	2b00      	cmp	r3, #0
20000c80:	d1ee      	bne.n	20000c60 <main+0x48c>
				fftval = *n1fft;
			}
        }
	}
20000c82:	e5f0      	b.n	20000866 <main+0x92>

20000c84 <SPI_poll_write_read>:
//
// Writes poll_tx_buf to SPI (to GUI via Nordic) and receives command (if any) in poll_rx_buf
// Checks to see if anything interesting was returned in a SPI poll.
//
void SPI_poll_write_read(void)
{
20000c84:	b580      	push	{r7, lr}
20000c86:	b082      	sub	sp, #8
20000c88:	af02      	add	r7, sp, #8
	if (stream_en) return;	// assertion
20000c8a:	f643 63d4 	movw	r3, #16084	; 0x3ed4
20000c8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000c92:	781b      	ldrb	r3, [r3, #0]
20000c94:	2b00      	cmp	r3, #0
20000c96:	d13b      	bne.n	20000d10 <SPI_poll_write_read+0x8c>

	memset((char *) poll_rx_buf, 0, sizeof(poll_rx_buf));
20000c98:	f643 50f0 	movw	r0, #15856	; 0x3df0
20000c9c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000ca0:	f04f 0100 	mov.w	r1, #0
20000ca4:	f04f 0206 	mov.w	r2, #6
20000ca8:	f002 fef8 	bl	20003a9c <memset>

	MSS_SPI_set_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);
20000cac:	f244 0070 	movw	r0, #16496	; 0x4070
20000cb0:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000cb4:	f04f 0100 	mov.w	r1, #0
20000cb8:	f001 fb2c 	bl	20002314 <MSS_SPI_set_slave_select>
 	MSS_SPI_transfer_block(&g_mss_spi0, poll_tx_buf, POLL_TX_BUF_SIZE, poll_rx_buf, POLL_RX_BUF_SIZE);
20000cbc:	f04f 0306 	mov.w	r3, #6
20000cc0:	9300      	str	r3, [sp, #0]
20000cc2:	f244 0070 	movw	r0, #16496	; 0x4070
20000cc6:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000cca:	f643 5128 	movw	r1, #15656	; 0x3d28
20000cce:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000cd2:	f04f 02c7 	mov.w	r2, #199	; 0xc7
20000cd6:	f643 53f0 	movw	r3, #15856	; 0x3df0
20000cda:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000cde:	f001 fbe5 	bl	200024ac <MSS_SPI_transfer_block>
	MSS_SPI_clear_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);
20000ce2:	f244 0070 	movw	r0, #16496	; 0x4070
20000ce6:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000cea:	f04f 0100 	mov.w	r1, #0
20000cee:	f001 fb95 	bl	2000241c <MSS_SPI_clear_slave_select>

	if (poll_rx_buf[0] == 0xAA) {
20000cf2:	f643 53f0 	movw	r3, #15856	; 0x3df0
20000cf6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000cfa:	781b      	ldrb	r3, [r3, #0]
20000cfc:	2baa      	cmp	r3, #170	; 0xaa
20000cfe:	d108      	bne.n	20000d12 <SPI_poll_write_read+0x8e>
		poll_rx_rdy = true;
20000d00:	f643 5322 	movw	r3, #15650	; 0x3d22
20000d04:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000d08:	f04f 0201 	mov.w	r2, #1
20000d0c:	701a      	strb	r2, [r3, #0]
20000d0e:	e000      	b.n	20000d12 <SPI_poll_write_read+0x8e>
// Writes poll_tx_buf to SPI (to GUI via Nordic) and receives command (if any) in poll_rx_buf
// Checks to see if anything interesting was returned in a SPI poll.
//
void SPI_poll_write_read(void)
{
	if (stream_en) return;	// assertion
20000d10:	bf00      	nop
	MSS_SPI_clear_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);

	if (poll_rx_buf[0] == 0xAA) {
		poll_rx_rdy = true;
	}
}
20000d12:	46bd      	mov	sp, r7
20000d14:	bd80      	pop	{r7, pc}
20000d16:	bf00      	nop

20000d18 <SPI_PDMA_write_read>:
//
// Starts Tx and Rx PDMA channels to/from the SPI (to GUI via Nordic)
// Command from the GUI will be in pdma_rx_buf when Rx transfer is complete
//
void SPI_PDMA_write_read(void)
{
20000d18:	b580      	push	{r7, lr}
20000d1a:	af00      	add	r7, sp, #0
	if (!stream_en) return;	// assertion
20000d1c:	f643 63d4 	movw	r3, #16084	; 0x3ed4
20000d20:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000d24:	781b      	ldrb	r3, [r3, #0]
20000d26:	f083 0301 	eor.w	r3, r3, #1
20000d2a:	b2db      	uxtb	r3, r3
20000d2c:	2b00      	cmp	r3, #0
20000d2e:	d143      	bne.n	20000db8 <SPI_PDMA_write_read+0xa0>

	memset((char *) pdma_rx_buf, 0, sizeof(pdma_rx_buf));
20000d30:	f643 50f8 	movw	r0, #15864	; 0x3df8
20000d34:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000d38:	f04f 0100 	mov.w	r1, #0
20000d3c:	f04f 02cd 	mov.w	r2, #205	; 0xcd
20000d40:	f002 feac 	bl	20003a9c <memset>

	MSS_SPI_set_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);
20000d44:	f244 0070 	movw	r0, #16496	; 0x4070
20000d48:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000d4c:	f04f 0100 	mov.w	r1, #0
20000d50:	f001 fae0 	bl	20002314 <MSS_SPI_set_slave_select>
	MSS_SPI_disable(&g_mss_spi0);
20000d54:	f244 0070 	movw	r0, #16496	; 0x4070
20000d58:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000d5c:	f001 fcd6 	bl	2000270c <MSS_SPI_disable>
	MSS_SPI_set_transfer_byte_count(&g_mss_spi0, PDMA_TX_FRAME_SIZE);	// can only be set with SPI disabled
20000d60:	f244 0070 	movw	r0, #16496	; 0x4070
20000d64:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000d68:	f04f 01cd 	mov.w	r1, #205	; 0xcd
20000d6c:	f001 fcea 	bl	20002744 <MSS_SPI_set_transfer_byte_count>
	PDMA_start(PDMA_CHANNEL_0, REG_BASE+0x0008, PDMA_SPI0_TX_REGISTER, PDMA_TX_FRAME_SIZE);
20000d70:	f04f 0000 	mov.w	r0, #0
20000d74:	f240 0108 	movw	r1, #8
20000d78:	f2c3 0100 	movt	r1, #12288	; 0x3000
20000d7c:	f241 0214 	movw	r2, #4116	; 0x1014
20000d80:	f2c4 0200 	movt	r2, #16384	; 0x4000
20000d84:	f04f 03cd 	mov.w	r3, #205	; 0xcd
20000d88:	f002 f88c 	bl	20002ea4 <PDMA_start>
	PDMA_start(PDMA_CHANNEL_1, PDMA_SPI0_RX_REGISTER, (uint32_t) pdma_rx_buf, PDMA_RX_FRAME_SIZE);
20000d8c:	f643 53f8 	movw	r3, #15864	; 0x3df8
20000d90:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000d94:	f04f 0001 	mov.w	r0, #1
20000d98:	f241 0110 	movw	r1, #4112	; 0x1010
20000d9c:	f2c4 0100 	movt	r1, #16384	; 0x4000
20000da0:	461a      	mov	r2, r3
20000da2:	f04f 03cd 	mov.w	r3, #205	; 0xcd
20000da6:	f002 f87d 	bl	20002ea4 <PDMA_start>
	MSS_SPI_enable(&g_mss_spi0);
20000daa:	f244 0070 	movw	r0, #16496	; 0x4070
20000dae:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000db2:	f001 fc8f 	bl	200026d4 <MSS_SPI_enable>
20000db6:	e000      	b.n	20000dba <SPI_PDMA_write_read+0xa2>
// Starts Tx and Rx PDMA channels to/from the SPI (to GUI via Nordic)
// Command from the GUI will be in pdma_rx_buf when Rx transfer is complete
//
void SPI_PDMA_write_read(void)
{
	if (!stream_en) return;	// assertion
20000db8:	bf00      	nop
    PDMA_start(PDMA_CHANNEL_0, REG_BASE+0x0008, PDMA_SPI0_TX_REGISTER, PDMA_TX_FRAME_SIZE);
    PDMA_start(PDMA_CHANNEL_1, PDMA_SPI0_RX_REGISTER, (uint32_t) pdma_rx_buf, PDMA_RX_FRAME_SIZE);
    while (PDMA_status(PDMA_CHANNEL_1) == 0);
    MSS_SPI_clear_slave_select(&g_mss_spi0, MSS_SPI_SLAVE_0);
*/
}
20000dba:	bd80      	pop	{r7, pc}

20000dbc <PDMA_find_command>:
// Find the start of a GUI command in pdma_rx_buf.
// For whatever reason the commands do not always start in the same place so this ensures that the header byte is correctly identified.
// Also records commands for debugging.
//
uint8_t *PDMA_find_command(void)
{
20000dbc:	b580      	push	{r7, lr}
20000dbe:	b082      	sub	sp, #8
20000dc0:	af00      	add	r7, sp, #0
    int  i;

    for (i = 0; i < sizeof(dbg_rx_pdma_array); i++) {
20000dc2:	f04f 0300 	mov.w	r3, #0
20000dc6:	607b      	str	r3, [r7, #4]
20000dc8:	e056      	b.n	20000e78 <PDMA_find_command+0xbc>
       	if (pdma_rx_buf[i] == 0xAA) {
20000dca:	687a      	ldr	r2, [r7, #4]
20000dcc:	f643 53f8 	movw	r3, #15864	; 0x3df8
20000dd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000dd4:	5c9b      	ldrb	r3, [r3, r2]
20000dd6:	2baa      	cmp	r3, #170	; 0xaa
20000dd8:	d14a      	bne.n	20000e70 <PDMA_find_command+0xb4>
       		if (dbg_rx_pdma_indx < 20) {
20000dda:	f643 63d8 	movw	r3, #16088	; 0x3ed8
20000dde:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000de2:	681b      	ldr	r3, [r3, #0]
20000de4:	2b13      	cmp	r3, #19
20000de6:	dc38      	bgt.n	20000e5a <PDMA_find_command+0x9e>
       			dbg_rx_pdma_array[dbg_rx_pdma_indx][0] = i;
20000de8:	f643 63d8 	movw	r3, #16088	; 0x3ed8
20000dec:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000df0:	6819      	ldr	r1, [r3, #0]
20000df2:	687b      	ldr	r3, [r7, #4]
20000df4:	b2d8      	uxtb	r0, r3
20000df6:	f643 62dc 	movw	r2, #16092	; 0x3edc
20000dfa:	f2c2 0200 	movt	r2, #8192	; 0x2000
20000dfe:	460b      	mov	r3, r1
20000e00:	ea4f 03c3 	mov.w	r3, r3, lsl #3
20000e04:	ebc1 0303 	rsb	r3, r1, r3
20000e08:	4413      	add	r3, r2
20000e0a:	4602      	mov	r2, r0
20000e0c:	701a      	strb	r2, [r3, #0]
       			memcpy((char *) &(dbg_rx_pdma_array[dbg_rx_pdma_indx++][1]), (char *) &pdma_rx_buf[i], 6);
20000e0e:	f643 63d8 	movw	r3, #16088	; 0x3ed8
20000e12:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000e16:	681a      	ldr	r2, [r3, #0]
20000e18:	4611      	mov	r1, r2
20000e1a:	460b      	mov	r3, r1
20000e1c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
20000e20:	ebc1 0303 	rsb	r3, r1, r3
20000e24:	f103 0101 	add.w	r1, r3, #1
20000e28:	f643 63dc 	movw	r3, #16092	; 0x3edc
20000e2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000e30:	4419      	add	r1, r3
20000e32:	f102 0201 	add.w	r2, r2, #1
20000e36:	f643 63d8 	movw	r3, #16088	; 0x3ed8
20000e3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000e3e:	601a      	str	r2, [r3, #0]
20000e40:	687a      	ldr	r2, [r7, #4]
20000e42:	f643 53f8 	movw	r3, #15864	; 0x3df8
20000e46:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000e4a:	4413      	add	r3, r2
20000e4c:	4608      	mov	r0, r1
20000e4e:	4619      	mov	r1, r3
20000e50:	f04f 0206 	mov.w	r2, #6
20000e54:	f002 fd5a 	bl	2000390c <memcpy>
       		} else {
       			dbg_rx_pdma_indx = dbg_rx_pdma_indx;	// line for breakpoint
       		}
       		break;
20000e58:	e011      	b.n	20000e7e <PDMA_find_command+0xc2>
       	if (pdma_rx_buf[i] == 0xAA) {
       		if (dbg_rx_pdma_indx < 20) {
       			dbg_rx_pdma_array[dbg_rx_pdma_indx][0] = i;
       			memcpy((char *) &(dbg_rx_pdma_array[dbg_rx_pdma_indx++][1]), (char *) &pdma_rx_buf[i], 6);
       		} else {
       			dbg_rx_pdma_indx = dbg_rx_pdma_indx;	// line for breakpoint
20000e5a:	f643 63d8 	movw	r3, #16088	; 0x3ed8
20000e5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000e62:	681a      	ldr	r2, [r3, #0]
20000e64:	f643 63d8 	movw	r3, #16088	; 0x3ed8
20000e68:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000e6c:	601a      	str	r2, [r3, #0]
       		}
       		break;
20000e6e:	e006      	b.n	20000e7e <PDMA_find_command+0xc2>
//
uint8_t *PDMA_find_command(void)
{
    int  i;

    for (i = 0; i < sizeof(dbg_rx_pdma_array); i++) {
20000e70:	687b      	ldr	r3, [r7, #4]
20000e72:	f103 0301 	add.w	r3, r3, #1
20000e76:	607b      	str	r3, [r7, #4]
20000e78:	687b      	ldr	r3, [r7, #4]
20000e7a:	2b8b      	cmp	r3, #139	; 0x8b
20000e7c:	d9a5      	bls.n	20000dca <PDMA_find_command+0xe>
       		}
       		break;
       	}
    }

    if (i == sizeof(dbg_rx_pdma_array)) {
20000e7e:	687b      	ldr	r3, [r7, #4]
20000e80:	2b8c      	cmp	r3, #140	; 0x8c
20000e82:	d102      	bne.n	20000e8a <PDMA_find_command+0xce>
       	return NULL;
20000e84:	f04f 0300 	mov.w	r3, #0
20000e88:	e005      	b.n	20000e96 <PDMA_find_command+0xda>
    }

	return &pdma_rx_buf[i];
20000e8a:	687a      	ldr	r2, [r7, #4]
20000e8c:	f643 53f8 	movw	r3, #15864	; 0x3df8
20000e90:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000e94:	4413      	add	r3, r2
}
20000e96:	4618      	mov	r0, r3
20000e98:	f107 0708 	add.w	r7, r7, #8
20000e9c:	46bd      	mov	sp, r7
20000e9e:	bd80      	pop	{r7, pc}

20000ea0 <SPI_read_check>:
//
// A valid GUI command should be in rx_buf.
// Parse rx_buf and execute the command.
//
void SPI_read_check(uint8_t *rx_buf)
{
20000ea0:	b580      	push	{r7, lr}
20000ea2:	b088      	sub	sp, #32
20000ea4:	af00      	add	r7, sp, #0
20000ea6:	6078      	str	r0, [r7, #4]
   	bool stream_on = 0, stream_off = 0, artifact_on = 0, artifact_off = 0;
20000ea8:	f04f 0300 	mov.w	r3, #0
20000eac:	723b      	strb	r3, [r7, #8]
20000eae:	f04f 0300 	mov.w	r3, #0
20000eb2:	727b      	strb	r3, [r7, #9]
20000eb4:	f04f 0300 	mov.w	r3, #0
20000eb8:	72bb      	strb	r3, [r7, #10]
20000eba:	f04f 0300 	mov.w	r3, #0
20000ebe:	72fb      	strb	r3, [r7, #11]
   	int stim_req = 0, stim_nm0 = 0, stim_nm1 = 0;
20000ec0:	f04f 0300 	mov.w	r3, #0
20000ec4:	60fb      	str	r3, [r7, #12]
20000ec6:	f04f 0300 	mov.w	r3, #0
20000eca:	613b      	str	r3, [r7, #16]
20000ecc:	f04f 0300 	mov.w	r3, #0
20000ed0:	617b      	str	r3, [r7, #20]

   	// Sanity check
   	if (rx_buf[0] != 0xAA) {
20000ed2:	687b      	ldr	r3, [r7, #4]
20000ed4:	781b      	ldrb	r3, [r3, #0]
20000ed6:	2baa      	cmp	r3, #170	; 0xaa
20000ed8:	d00b      	beq.n	20000ef2 <SPI_read_check+0x52>
   		++dbg_bad_cmd;
20000eda:	f643 7368 	movw	r3, #16232	; 0x3f68
20000ede:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000ee2:	681b      	ldr	r3, [r3, #0]
20000ee4:	f103 0201 	add.w	r2, r3, #1
20000ee8:	f643 7368 	movw	r3, #16232	; 0x3f68
20000eec:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000ef0:	601a      	str	r2, [r3, #0]
   	}

	if (rx_buf[1] == 0xFF)
20000ef2:	687b      	ldr	r3, [r7, #4]
20000ef4:	f103 0301 	add.w	r3, r3, #1
20000ef8:	781b      	ldrb	r3, [r3, #0]
20000efa:	2bff      	cmp	r3, #255	; 0xff
20000efc:	f040 812f 	bne.w	2000115e <SPI_read_check+0x2be>
	{
	    // The command is a local state change
        stim_rep      = (rx_buf[2] << 8) | rx_buf[3];
20000f00:	687b      	ldr	r3, [r7, #4]
20000f02:	f103 0302 	add.w	r3, r3, #2
20000f06:	781b      	ldrb	r3, [r3, #0]
20000f08:	ea4f 2203 	mov.w	r2, r3, lsl #8
20000f0c:	687b      	ldr	r3, [r7, #4]
20000f0e:	f103 0303 	add.w	r3, r3, #3
20000f12:	781b      	ldrb	r3, [r3, #0]
20000f14:	ea42 0303 	orr.w	r3, r2, r3
20000f18:	461a      	mov	r2, r3
20000f1a:	f643 63d0 	movw	r3, #16080	; 0x3ed0
20000f1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000f22:	601a      	str	r2, [r3, #0]
        data_ack_req  =  rx_buf[4]       & 0x3;
20000f24:	687b      	ldr	r3, [r7, #4]
20000f26:	f103 0304 	add.w	r3, r3, #4
20000f2a:	781b      	ldrb	r3, [r3, #0]
20000f2c:	f003 0203 	and.w	r2, r3, #3
20000f30:	f643 4394 	movw	r3, #15508	; 0x3c94
20000f34:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000f38:	601a      	str	r2, [r3, #0]
        stim_nm0      = (rx_buf[4] >> 3) & 0x01;
20000f3a:	687b      	ldr	r3, [r7, #4]
20000f3c:	f103 0304 	add.w	r3, r3, #4
20000f40:	781b      	ldrb	r3, [r3, #0]
20000f42:	ea4f 03d3 	mov.w	r3, r3, lsr #3
20000f46:	b2db      	uxtb	r3, r3
20000f48:	f003 0301 	and.w	r3, r3, #1
20000f4c:	613b      	str	r3, [r7, #16]
        stim_nm1      = (rx_buf[4] >> 4) & 0x01;
20000f4e:	687b      	ldr	r3, [r7, #4]
20000f50:	f103 0304 	add.w	r3, r3, #4
20000f54:	781b      	ldrb	r3, [r3, #0]
20000f56:	ea4f 1313 	mov.w	r3, r3, lsr #4
20000f5a:	b2db      	uxtb	r3, r3
20000f5c:	f003 0301 	and.w	r3, r3, #1
20000f60:	617b      	str	r3, [r7, #20]
        stim_req      = (rx_buf[4] >> 5) & 0x1;
20000f62:	687b      	ldr	r3, [r7, #4]
20000f64:	f103 0304 	add.w	r3, r3, #4
20000f68:	781b      	ldrb	r3, [r3, #0]
20000f6a:	ea4f 1353 	mov.w	r3, r3, lsr #5
20000f6e:	b2db      	uxtb	r3, r3
20000f70:	f003 0301 	and.w	r3, r3, #1
20000f74:	60fb      	str	r3, [r7, #12]
        artifact_off  = (rx_buf[4] >> 6) & 0x1;
20000f76:	687b      	ldr	r3, [r7, #4]
20000f78:	f103 0304 	add.w	r3, r3, #4
20000f7c:	781b      	ldrb	r3, [r3, #0]
20000f7e:	ea4f 1393 	mov.w	r3, r3, lsr #6
20000f82:	b2db      	uxtb	r3, r3
20000f84:	f003 0301 	and.w	r3, r3, #1
20000f88:	72fb      	strb	r3, [r7, #11]
        artifact_on   = (rx_buf[4] >> 7) & 0x1;
20000f8a:	687b      	ldr	r3, [r7, #4]
20000f8c:	f103 0304 	add.w	r3, r3, #4
20000f90:	781b      	ldrb	r3, [r3, #0]
20000f92:	ea4f 13d3 	mov.w	r3, r3, lsr #7
20000f96:	72bb      	strb	r3, [r7, #10]
        stream_off    = (rx_buf[5] >> 4) & 0x1;
20000f98:	687b      	ldr	r3, [r7, #4]
20000f9a:	f103 0305 	add.w	r3, r3, #5
20000f9e:	781b      	ldrb	r3, [r3, #0]
20000fa0:	ea4f 1313 	mov.w	r3, r3, lsr #4
20000fa4:	b2db      	uxtb	r3, r3
20000fa6:	f003 0301 	and.w	r3, r3, #1
20000faa:	727b      	strb	r3, [r7, #9]
        stream_on     = (rx_buf[5] >> 5) & 0x1;
20000fac:	687b      	ldr	r3, [r7, #4]
20000fae:	f103 0305 	add.w	r3, r3, #5
20000fb2:	781b      	ldrb	r3, [r3, #0]
20000fb4:	ea4f 1353 	mov.w	r3, r3, lsr #5
20000fb8:	b2db      	uxtb	r3, r3
20000fba:	f003 0301 	and.w	r3, r3, #1
20000fbe:	723b      	strb	r3, [r7, #8]

        if (stream_on && !stream_en)
20000fc0:	7a3b      	ldrb	r3, [r7, #8]
20000fc2:	2b00      	cmp	r3, #0
20000fc4:	d01e      	beq.n	20001004 <SPI_read_check+0x164>
20000fc6:	f643 63d4 	movw	r3, #16084	; 0x3ed4
20000fca:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000fce:	781b      	ldrb	r3, [r3, #0]
20000fd0:	f083 0301 	eor.w	r3, r3, #1
20000fd4:	b2db      	uxtb	r3, r3
20000fd6:	2b00      	cmp	r3, #0
20000fd8:	d014      	beq.n	20001004 <SPI_read_check+0x164>
        {
           	*mode = (*mode) | PDMA_EN;
20000fda:	f643 43cc 	movw	r3, #15564	; 0x3ccc
20000fde:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000fe2:	681a      	ldr	r2, [r3, #0]
20000fe4:	f643 43cc 	movw	r3, #15564	; 0x3ccc
20000fe8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000fec:	681b      	ldr	r3, [r3, #0]
20000fee:	681b      	ldr	r3, [r3, #0]
20000ff0:	f043 0301 	orr.w	r3, r3, #1
20000ff4:	6013      	str	r3, [r2, #0]
            stream_en = 1;
20000ff6:	f643 63d4 	movw	r3, #16084	; 0x3ed4
20000ffa:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000ffe:	f04f 0201 	mov.w	r2, #1
20001002:	701a      	strb	r2, [r3, #0]
//            MSS_TIM1_stop();		// don't need the poll timer in streaming mode
        }
        if (stream_off && stream_en)
20001004:	7a7b      	ldrb	r3, [r7, #9]
20001006:	2b00      	cmp	r3, #0
20001008:	d01b      	beq.n	20001042 <SPI_read_check+0x1a2>
2000100a:	f643 63d4 	movw	r3, #16084	; 0x3ed4
2000100e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001012:	781b      	ldrb	r3, [r3, #0]
20001014:	2b00      	cmp	r3, #0
20001016:	d014      	beq.n	20001042 <SPI_read_check+0x1a2>
        {
           	*mode = (*mode) & ~PDMA_EN;
20001018:	f643 43cc 	movw	r3, #15564	; 0x3ccc
2000101c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001020:	681a      	ldr	r2, [r3, #0]
20001022:	f643 43cc 	movw	r3, #15564	; 0x3ccc
20001026:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000102a:	681b      	ldr	r3, [r3, #0]
2000102c:	681b      	ldr	r3, [r3, #0]
2000102e:	f023 0301 	bic.w	r3, r3, #1
20001032:	6013      	str	r3, [r2, #0]
           	stream_en = 0;
20001034:	f643 63d4 	movw	r3, #16084	; 0x3ed4
20001038:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000103c:	f04f 0200 	mov.w	r2, #0
20001040:	701a      	strb	r2, [r3, #0]
//           	poll_tx_start = false;	// make sure we don't execute a poll immediately
//           	MSS_TIM1_start();		// restart the poll timer
        }

        if (artifact_on && !artifact_en)
20001042:	7abb      	ldrb	r3, [r7, #10]
20001044:	2b00      	cmp	r3, #0
20001046:	d01e      	beq.n	20001086 <SPI_read_check+0x1e6>
20001048:	f643 63d5 	movw	r3, #16085	; 0x3ed5
2000104c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001050:	781b      	ldrb	r3, [r3, #0]
20001052:	f083 0301 	eor.w	r3, r3, #1
20001056:	b2db      	uxtb	r3, r3
20001058:	2b00      	cmp	r3, #0
2000105a:	d014      	beq.n	20001086 <SPI_read_check+0x1e6>
        {
           	*mode = (*mode) | ARTIFACT_EN;
2000105c:	f643 43cc 	movw	r3, #15564	; 0x3ccc
20001060:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001064:	681a      	ldr	r2, [r3, #0]
20001066:	f643 43cc 	movw	r3, #15564	; 0x3ccc
2000106a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000106e:	681b      	ldr	r3, [r3, #0]
20001070:	681b      	ldr	r3, [r3, #0]
20001072:	f043 0304 	orr.w	r3, r3, #4
20001076:	6013      	str	r3, [r2, #0]
            artifact_en = 1;
20001078:	f643 63d5 	movw	r3, #16085	; 0x3ed5
2000107c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001080:	f04f 0201 	mov.w	r2, #1
20001084:	701a      	strb	r2, [r3, #0]
        }
        if (artifact_off && artifact_en)
20001086:	7afb      	ldrb	r3, [r7, #11]
20001088:	2b00      	cmp	r3, #0
2000108a:	d01b      	beq.n	200010c4 <SPI_read_check+0x224>
2000108c:	f643 63d5 	movw	r3, #16085	; 0x3ed5
20001090:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001094:	781b      	ldrb	r3, [r3, #0]
20001096:	2b00      	cmp	r3, #0
20001098:	d014      	beq.n	200010c4 <SPI_read_check+0x224>
        {
           	*mode = (*mode) & ~ARTIFACT_EN;
2000109a:	f643 43cc 	movw	r3, #15564	; 0x3ccc
2000109e:	f2c2 0300 	movt	r3, #8192	; 0x2000
200010a2:	681a      	ldr	r2, [r3, #0]
200010a4:	f643 43cc 	movw	r3, #15564	; 0x3ccc
200010a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200010ac:	681b      	ldr	r3, [r3, #0]
200010ae:	681b      	ldr	r3, [r3, #0]
200010b0:	f023 0304 	bic.w	r3, r3, #4
200010b4:	6013      	str	r3, [r2, #0]
            artifact_en = 0;
200010b6:	f643 63d5 	movw	r3, #16085	; 0x3ed5
200010ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
200010be:	f04f 0200 	mov.w	r2, #0
200010c2:	701a      	strb	r2, [r3, #0]
        }

        if (stim_req)
200010c4:	68fb      	ldr	r3, [r7, #12]
200010c6:	2b00      	cmp	r3, #0
200010c8:	f000 80c4 	beq.w	20001254 <SPI_read_check+0x3b4>
        {
            if (stim_nm0)
200010cc:	693b      	ldr	r3, [r7, #16]
200010ce:	2b00      	cmp	r3, #0
200010d0:	d020      	beq.n	20001114 <SPI_read_check+0x274>
            {
            	sendNMcmd(NM0, 0x09 | (1 << 10));
200010d2:	f04f 0000 	mov.w	r0, #0
200010d6:	f240 4109 	movw	r1, #1033	; 0x409
200010da:	f000 fe5d 	bl	20001d98 <sendNMcmd>
               	stim_count++;
200010de:	f643 63c8 	movw	r3, #16072	; 0x3ec8
200010e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200010e6:	681b      	ldr	r3, [r3, #0]
200010e8:	f103 0201 	add.w	r2, r3, #1
200010ec:	f643 63c8 	movw	r3, #16072	; 0x3ec8
200010f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200010f4:	601a      	str	r2, [r3, #0]
                if (stim_rep > 0)
200010f6:	f643 63d0 	movw	r3, #16080	; 0x3ed0
200010fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
200010fe:	681b      	ldr	r3, [r3, #0]
20001100:	2b00      	cmp	r3, #0
20001102:	f000 80a9 	beq.w	20001258 <SPI_read_check+0x3b8>
                {
                	postNMregRead(NM0, 0x01);
20001106:	f04f 0000 	mov.w	r0, #0
2000110a:	f04f 0101 	mov.w	r1, #1
2000110e:	f000 fd87 	bl	20001c20 <postNMregRead>
            {
            	sendNMcmd(NM1, 0x09 | (1 << 10));
               	stim_count++;
                if (stim_rep > 0)
                {
      				postNMregRead(NM1, 0x01);
20001112:	e0a6      	b.n	20001262 <SPI_read_check+0x3c2>
                if (stim_rep > 0)
                {
                	postNMregRead(NM0, 0x01);
                }
            }
            else if (stim_nm1)
20001114:	697b      	ldr	r3, [r7, #20]
20001116:	2b00      	cmp	r3, #0
20001118:	f000 80a0 	beq.w	2000125c <SPI_read_check+0x3bc>
            {
            	sendNMcmd(NM1, 0x09 | (1 << 10));
2000111c:	f04f 0001 	mov.w	r0, #1
20001120:	f240 4109 	movw	r1, #1033	; 0x409
20001124:	f000 fe38 	bl	20001d98 <sendNMcmd>
               	stim_count++;
20001128:	f643 63c8 	movw	r3, #16072	; 0x3ec8
2000112c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001130:	681b      	ldr	r3, [r3, #0]
20001132:	f103 0201 	add.w	r2, r3, #1
20001136:	f643 63c8 	movw	r3, #16072	; 0x3ec8
2000113a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000113e:	601a      	str	r2, [r3, #0]
                if (stim_rep > 0)
20001140:	f643 63d0 	movw	r3, #16080	; 0x3ed0
20001144:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001148:	681b      	ldr	r3, [r3, #0]
2000114a:	2b00      	cmp	r3, #0
2000114c:	f000 8088 	beq.w	20001260 <SPI_read_check+0x3c0>
                {
      				postNMregRead(NM1, 0x01);
20001150:	f04f 0001 	mov.w	r0, #1
20001154:	f04f 0101 	mov.w	r1, #1
20001158:	f000 fd62 	bl	20001c20 <postNMregRead>
2000115c:	e081      	b.n	20001262 <SPI_read_check+0x3c2>
                }
            }
        }
	}

	else if ((unsigned char) rx_buf[1] <= 0x4f)
2000115e:	687b      	ldr	r3, [r7, #4]
20001160:	f103 0301 	add.w	r3, r3, #1
20001164:	781b      	ldrb	r3, [r3, #0]
20001166:	2b4f      	cmp	r3, #79	; 0x4f
20001168:	d87b      	bhi.n	20001262 <SPI_read_check+0x3c2>
		// See Mario-CM M3 code documentation.pptx for the address map.

		int reg_val;
		uint16_t reg_addr, reg_data;

		reg_val = rx_buf[5] + ((uint32_t)rx_buf[4] << 8) + ((uint32_t)rx_buf[3] << 16) + ((uint32_t)rx_buf[2] << 24);
2000116a:	687b      	ldr	r3, [r7, #4]
2000116c:	f103 0305 	add.w	r3, r3, #5
20001170:	781b      	ldrb	r3, [r3, #0]
20001172:	461a      	mov	r2, r3
20001174:	687b      	ldr	r3, [r7, #4]
20001176:	f103 0304 	add.w	r3, r3, #4
2000117a:	781b      	ldrb	r3, [r3, #0]
2000117c:	ea4f 2303 	mov.w	r3, r3, lsl #8
20001180:	441a      	add	r2, r3
20001182:	687b      	ldr	r3, [r7, #4]
20001184:	f103 0303 	add.w	r3, r3, #3
20001188:	781b      	ldrb	r3, [r3, #0]
2000118a:	ea4f 4303 	mov.w	r3, r3, lsl #16
2000118e:	441a      	add	r2, r3
20001190:	687b      	ldr	r3, [r7, #4]
20001192:	f103 0302 	add.w	r3, r3, #2
20001196:	781b      	ldrb	r3, [r3, #0]
20001198:	ea4f 6303 	mov.w	r3, r3, lsl #24
2000119c:	4413      	add	r3, r2
2000119e:	61bb      	str	r3, [r7, #24]
		*(int*)(REG_BASE+rx_buf[1]) = reg_val;
200011a0:	687b      	ldr	r3, [r7, #4]
200011a2:	f103 0301 	add.w	r3, r3, #1
200011a6:	781b      	ldrb	r3, [r3, #0]
200011a8:	f103 5340 	add.w	r3, r3, #805306368	; 0x30000000
200011ac:	69ba      	ldr	r2, [r7, #24]
200011ae:	601a      	str	r2, [r3, #0]
		while((*status) & (NM0_TX_BUSY_BIT | NM1_TX_BUSY_BIT));
200011b0:	f643 43f8 	movw	r3, #15608	; 0x3cf8
200011b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200011b8:	681b      	ldr	r3, [r3, #0]
200011ba:	681b      	ldr	r3, [r3, #0]
200011bc:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
200011c0:	2b00      	cmp	r3, #0
200011c2:	d1f5      	bne.n	200011b0 <SPI_read_check+0x310>

		reg_addr = (reg_val >> 16) & 0xFFFF;
200011c4:	69bb      	ldr	r3, [r7, #24]
200011c6:	ea4f 4313 	mov.w	r3, r3, lsr #16
200011ca:	83bb      	strh	r3, [r7, #28]
		reg_data = reg_val & 0xFFFF;
200011cc:	69bb      	ldr	r3, [r7, #24]
200011ce:	83fb      	strh	r3, [r7, #30]
		//		3) HDL command register write, initiates Tx of d1 and d2 to selected NM.
		//		4) set local enable ACK return flag

		// The previous command was a d1 HDL register write (indicating type of op, either write or read).
		// If it was a write rec_enable_write will be set.
		if (rec_enable_write)
200011d0:	f643 63cc 	movw	r3, #16076	; 0x3ecc
200011d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200011d8:	781b      	ldrb	r3, [r3, #0]
200011da:	2b00      	cmp	r3, #0
200011dc:	d023      	beq.n	20001226 <SPI_read_check+0x386>
		{
			rec_enable_write = false;
200011de:	f643 63cc 	movw	r3, #16076	; 0x3ecc
200011e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200011e6:	f04f 0200 	mov.w	r2, #0
200011ea:	701a      	strb	r2, [r3, #0]

			// If this command is for the NM0 d2 HDL register, then update NM0 vectors
			if (rx_buf[1] == 0x14)
200011ec:	687b      	ldr	r3, [r7, #4]
200011ee:	f103 0301 	add.w	r3, r3, #1
200011f2:	781b      	ldrb	r3, [r3, #0]
200011f4:	2b14      	cmp	r3, #20
200011f6:	d108      	bne.n	2000120a <SPI_read_check+0x36a>
			{
				update_ADC_vectors(0, reg_addr, reg_data);
200011f8:	8bba      	ldrh	r2, [r7, #28]
200011fa:	8bfb      	ldrh	r3, [r7, #30]
200011fc:	f04f 0000 	mov.w	r0, #0
20001200:	4611      	mov	r1, r2
20001202:	461a      	mov	r2, r3
20001204:	f000 fbf2 	bl	200019ec <update_ADC_vectors>
20001208:	e00d      	b.n	20001226 <SPI_read_check+0x386>
			}
			// If this command is for the NM1 d2 HDL register, then update NM1 vectors
			else if (rx_buf[1] == 0x24)
2000120a:	687b      	ldr	r3, [r7, #4]
2000120c:	f103 0301 	add.w	r3, r3, #1
20001210:	781b      	ldrb	r3, [r3, #0]
20001212:	2b24      	cmp	r3, #36	; 0x24
20001214:	d107      	bne.n	20001226 <SPI_read_check+0x386>
			{
				update_ADC_vectors(1, reg_addr, reg_data);
20001216:	8bba      	ldrh	r2, [r7, #28]
20001218:	8bfb      	ldrh	r3, [r7, #30]
2000121a:	f04f 0001 	mov.w	r0, #1
2000121e:	4611      	mov	r1, r2
20001220:	461a      	mov	r2, r3
20001222:	f000 fbe3 	bl	200019ec <update_ADC_vectors>
			}
		}

		// If this command is an HDL d1 register write...
		if (((rx_buf[1] == 0x10) || (rx_buf[1] == 0x20)) && (reg_data == 1))
20001226:	687b      	ldr	r3, [r7, #4]
20001228:	f103 0301 	add.w	r3, r3, #1
2000122c:	781b      	ldrb	r3, [r3, #0]
2000122e:	2b10      	cmp	r3, #16
20001230:	d005      	beq.n	2000123e <SPI_read_check+0x39e>
20001232:	687b      	ldr	r3, [r7, #4]
20001234:	f103 0301 	add.w	r3, r3, #1
20001238:	781b      	ldrb	r3, [r3, #0]
2000123a:	2b20      	cmp	r3, #32
2000123c:	d111      	bne.n	20001262 <SPI_read_check+0x3c2>
2000123e:	8bfb      	ldrh	r3, [r7, #30]
20001240:	2b01      	cmp	r3, #1
20001242:	d10e      	bne.n	20001262 <SPI_read_check+0x3c2>
		{
			// The next command will be a d2 HDL register write.
			rec_enable_write = true;
20001244:	f643 63cc 	movw	r3, #16076	; 0x3ecc
20001248:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000124c:	f04f 0201 	mov.w	r2, #1
20001250:	701a      	strb	r2, [r3, #0]
20001252:	e006      	b.n	20001262 <SPI_read_check+0x3c2>
            {
            	sendNMcmd(NM1, 0x09 | (1 << 10));
               	stim_count++;
                if (stim_rep > 0)
                {
      				postNMregRead(NM1, 0x01);
20001254:	bf00      	nop
20001256:	e004      	b.n	20001262 <SPI_read_check+0x3c2>
20001258:	bf00      	nop
2000125a:	e002      	b.n	20001262 <SPI_read_check+0x3c2>
2000125c:	bf00      	nop
2000125e:	e000      	b.n	20001262 <SPI_read_check+0x3c2>
20001260:	bf00      	nop
		{
			// The next command will be a d2 HDL register write.
			rec_enable_write = true;
		}
	}
}
20001262:	f107 0720 	add.w	r7, r7, #32
20001266:	46bd      	mov	sp, r7
20001268:	bd80      	pop	{r7, pc}
2000126a:	bf00      	nop

2000126c <sys_init>:

//
// Initialize and configure MSS peripherals and core blocks
//
int sys_init(void)
{
2000126c:	b580      	push	{r7, lr}
2000126e:	b084      	sub	sp, #16
20001270:	af02      	add	r7, sp, #8
	gpio_init();
20001272:	f000 fac9 	bl	20001808 <gpio_init>

	// Initialize SPI_0
	MSS_SPI_init(&g_mss_spi0);
20001276:	f244 0070 	movw	r0, #16496	; 0x4070
2000127a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000127e:	f000 fe57 	bl	20001f30 <MSS_SPI_init>
	MSS_SPI_configure_master_mode(&g_mss_spi0,
20001282:	f04f 0308 	mov.w	r3, #8
20001286:	9300      	str	r3, [sp, #0]
20001288:	f244 0070 	movw	r0, #16496	; 0x4070
2000128c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001290:	f04f 0100 	mov.w	r1, #0
20001294:	f04f 0200 	mov.w	r2, #0
20001298:	f04f 0308 	mov.w	r3, #8
2000129c:	f000 ff92 	bl	200021c4 <MSS_SPI_configure_master_mode>
//			4u, // seems to work best with PDMA on eval board but does not work with Nordic - FLB
			MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE	 //needed for transmitting in blocks
	);

	// Initialize timer for polling when PDMA is disabled
	MSS_TIM1_init(MSS_TIMER_PERIODIC_MODE);
200012a0:	f04f 0000 	mov.w	r0, #0
200012a4:	f7ff fa26 	bl	200006f4 <MSS_TIM1_init>
 	MSS_TIM1_load_background(GUI_POLL_DELAY_IDLE);
200012a8:	f640 5040 	movw	r0, #3392	; 0xd40
200012ac:	f2c0 0003 	movt	r0, #3
200012b0:	f7ff fa70 	bl	20000794 <MSS_TIM1_load_background>
	MSS_TIM1_enable_irq();
200012b4:	f7ff fa7e 	bl	200007b4 <MSS_TIM1_enable_irq>
 	MSS_TIM1_start();
200012b8:	f7ff fa5e 	bl	20000778 <MSS_TIM1_start>

	// Initialize PDMA channels
	PDMA_init();
200012bc:	f001 fd00 	bl	20002cc0 <PDMA_init>
	PDMA_configure(PDMA_CHANNEL_0, PDMA_TO_SPI_0,   PDMA_LOW_PRIORITY  | PDMA_BYTE_TRANSFER | PDMA_NO_INC,            PDMA_DEFAULT_WRITE_ADJ);
200012c0:	f04f 0000 	mov.w	r0, #0
200012c4:	f04f 0105 	mov.w	r1, #5
200012c8:	f04f 0200 	mov.w	r2, #0
200012cc:	f04f 030a 	mov.w	r3, #10
200012d0:	f001 fd46 	bl	20002d60 <PDMA_configure>
	PDMA_configure(PDMA_CHANNEL_1, PDMA_FROM_SPI_0, PDMA_HIGH_PRIORITY | PDMA_BYTE_TRANSFER | PDMA_INC_DEST_ONE_BYTE, PDMA_DEFAULT_WRITE_ADJ);
200012d4:	f04f 0001 	mov.w	r0, #1
200012d8:	f04f 0104 	mov.w	r1, #4
200012dc:	f44f 5290 	mov.w	r2, #4608	; 0x1200
200012e0:	f04f 030a 	mov.w	r3, #10
200012e4:	f001 fd3c 	bl	20002d60 <PDMA_configure>
	PDMA_set_irq_handler(PDMA_CHANNEL_0, PDMA_0_isr);
200012e8:	f04f 0000 	mov.w	r0, #0
200012ec:	f240 6101 	movw	r1, #1537	; 0x601
200012f0:	f2c2 0100 	movt	r1, #8192	; 0x2000
200012f4:	f001 ff8e 	bl	20003214 <PDMA_set_irq_handler>
	PDMA_set_irq_handler(PDMA_CHANNEL_1, PDMA_1_isr);
200012f8:	f04f 0001 	mov.w	r0, #1
200012fc:	f240 6111 	movw	r1, #1553	; 0x611
20001300:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001304:	f001 ff86 	bl	20003214 <PDMA_set_irq_handler>

	// Initialize accelerometer and test
	// Sometimes initialization fails if code restarted without power cycle
    int retval = MPU6050_init();
20001308:	f000 f884 	bl	20001414 <MPU6050_init>
2000130c:	4603      	mov	r3, r0
2000130e:	607b      	str	r3, [r7, #4]
    if (retval < 0) {
20001310:	687b      	ldr	r3, [r7, #4]
20001312:	2b00      	cmp	r3, #0
20001314:	da00      	bge.n	20001318 <sys_init+0xac>
    	while(1);	// assertion
20001316:	e7fe      	b.n	20001316 <sys_init+0xaa>
    }

	// Turn on rec_en for both NMs
	writeNMreg(NM0, NM_REC_CONFIG_REG, 0x3884);
20001318:	f04f 0000 	mov.w	r0, #0
2000131c:	f04f 010c 	mov.w	r1, #12
20001320:	f643 0284 	movw	r2, #14468	; 0x3884
20001324:	f000 fcc0 	bl	20001ca8 <writeNMreg>
	writeNMreg(NM1, NM_REC_CONFIG_REG, 0x3884);
20001328:	f04f 0001 	mov.w	r0, #1
2000132c:	f04f 010c 	mov.w	r1, #12
20001330:	f643 0284 	movw	r2, #14468	; 0x3884
20001334:	f000 fcb8 	bl	20001ca8 <writeNMreg>

	// Change LV charge pumps from 3:1 to 2:1 for both NMs
	writeNMreg(NM0, NM_PWR_CONFIG_REG, 0x0001); //change NM0 LV charge pump from 3:1 to 2:1
20001338:	f04f 0000 	mov.w	r0, #0
2000133c:	f04f 0102 	mov.w	r1, #2
20001340:	f04f 0201 	mov.w	r2, #1
20001344:	f000 fcb0 	bl	20001ca8 <writeNMreg>
	writeNMreg(NM1, NM_PWR_CONFIG_REG, 0x0001); //change NM1 LV charge pump from 3:1 to 2:1
20001348:	f04f 0001 	mov.w	r0, #1
2000134c:	f04f 0102 	mov.w	r1, #2
20001350:	f04f 0201 	mov.w	r2, #1
20001354:	f000 fca8 	bl	20001ca8 <writeNMreg>

	// Program NM channel enable registers.
	// Side effect is to initialize ADC vectors in HDL ADC data path
	init_ADC_vectors();
20001358:	f000 fae4 	bl	20001924 <init_ADC_vectors>

	// Enable recording bias current to go to the stimulator
	writeNMreg(NM0, NM_SYS_CONFIG_REG, 0x4000);
2000135c:	f04f 0000 	mov.w	r0, #0
20001360:	f04f 010d 	mov.w	r1, #13
20001364:	f44f 4280 	mov.w	r2, #16384	; 0x4000
20001368:	f000 fc9e 	bl	20001ca8 <writeNMreg>
	writeNMreg(NM1, NM_SYS_CONFIG_REG, 0x4000);
2000136c:	f04f 0001 	mov.w	r0, #1
20001370:	f04f 010d 	mov.w	r1, #13
20001374:	f44f 4280 	mov.w	r2, #16384	; 0x4000
20001378:	f000 fc96 	bl	20001ca8 <writeNMreg>

	// The CoreGPIO block intercepts the PDMA ready signal from the CMAM block and generates an interrupt on MSS GPIO[5].
	// CoreGPIO and MSS GPIOs are completely independent.
	MSS_GPIO_enable_irq(MSS_GPIO_5);
2000137c:	f04f 0005 	mov.w	r0, #5
20001380:	f002 f8da 	bl	20003538 <MSS_GPIO_enable_irq>
	GPIO_enable_irq(&gpio_core_handle, GPIO_0);
20001384:	f643 70e4 	movw	r0, #16356	; 0x3fe4
20001388:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000138c:	f04f 0100 	mov.w	r1, #0
20001390:	f002 f9c2 	bl	20003718 <GPIO_enable_irq>

	// ACK ready
	MSS_GPIO_enable_irq(MSS_GPIO_6);
20001394:	f04f 0006 	mov.w	r0, #6
20001398:	f002 f8ce 	bl	20003538 <MSS_GPIO_enable_irq>
	GPIO_enable_irq(&gpio_core_handle, GPIO_1);
2000139c:	f643 70e4 	movw	r0, #16356	; 0x3fe4
200013a0:	f2c2 0000 	movt	r0, #8192	; 0x2000
200013a4:	f04f 0101 	mov.w	r1, #1
200013a8:	f002 f9b6 	bl	20003718 <GPIO_enable_irq>

	// FFT ready
	MSS_GPIO_enable_irq(MSS_GPIO_7);
200013ac:	f04f 0007 	mov.w	r0, #7
200013b0:	f002 f8c2 	bl	20003538 <MSS_GPIO_enable_irq>
	GPIO_enable_irq(&gpio_core_handle, GPIO_2);
200013b4:	f643 70e4 	movw	r0, #16356	; 0x3fe4
200013b8:	f2c2 0000 	movt	r0, #8192	; 0x2000
200013bc:	f04f 0102 	mov.w	r1, #2
200013c0:	f002 f9aa 	bl	20003718 <GPIO_enable_irq>
	// If the accelerometer FIFO gets out of sync it may overflow.
	// Take action to either reset the FIFO (doesn't always work) or read all data.
//	MSS_GPIO_enable_irq(MSS_GPIO_8);
//	GPIO_enable_irq(&gpio_core_handle, GPIO_3);

	PDMA_enable_irq(0);
200013c4:	f04f 0000 	mov.w	r0, #0
200013c8:	f001 ff52 	bl	20003270 <PDMA_enable_irq>
	PDMA_enable_irq(1);
200013cc:	f04f 0001 	mov.w	r0, #1
200013d0:	f001 ff4e 	bl	20003270 <PDMA_enable_irq>

	return 0;
200013d4:	f04f 0300 	mov.w	r3, #0
}
200013d8:	4618      	mov	r0, r3
200013da:	f107 0708 	add.w	r7, r7, #8
200013de:	46bd      	mov	sp, r7
200013e0:	bd80      	pop	{r7, pc}
200013e2:	bf00      	nop

200013e4 <mpu_delay>:
int *mpu_last_Y	  	  = compute_addr(LAST_Y_VAL);
int *mpu_last_Z	      = compute_addr(LAST_Z_VAL);


void mpu_delay(int ticks)
{
200013e4:	b480      	push	{r7}
200013e6:	b085      	sub	sp, #20
200013e8:	af00      	add	r7, sp, #0
200013ea:	6078      	str	r0, [r7, #4]
	int i = 0;
200013ec:	f04f 0300 	mov.w	r3, #0
200013f0:	60fb      	str	r3, [r7, #12]
	for(i = 0; i < ticks; i++);
200013f2:	f04f 0300 	mov.w	r3, #0
200013f6:	60fb      	str	r3, [r7, #12]
200013f8:	e003      	b.n	20001402 <mpu_delay+0x1e>
200013fa:	68fb      	ldr	r3, [r7, #12]
200013fc:	f103 0301 	add.w	r3, r3, #1
20001400:	60fb      	str	r3, [r7, #12]
20001402:	68fa      	ldr	r2, [r7, #12]
20001404:	687b      	ldr	r3, [r7, #4]
20001406:	429a      	cmp	r2, r3
20001408:	dbf7      	blt.n	200013fa <mpu_delay+0x16>
}
2000140a:	f107 0714 	add.w	r7, r7, #20
2000140e:	46bd      	mov	sp, r7
20001410:	bc80      	pop	{r7}
20001412:	4770      	bx	lr

20001414 <MPU6050_init>:

int MPU6050_init(void)
{
20001414:	b580      	push	{r7, lr}
20001416:	b082      	sub	sp, #8
20001418:	af00      	add	r7, sp, #0
	// All sensors standby on start-up

	int retval;

    // Set DLPF_CFG to 3
	retval = MPU6050_write_reg_readback(reg_config, 3);
2000141a:	f643 4398 	movw	r3, #15512	; 0x3c98
2000141e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001422:	681b      	ldr	r3, [r3, #0]
20001424:	4618      	mov	r0, r3
20001426:	f04f 0103 	mov.w	r1, #3
2000142a:	f000 f8f3 	bl	20001614 <MPU6050_write_reg_readback>
2000142e:	4603      	mov	r3, r0
20001430:	607b      	str	r3, [r7, #4]
//	if (retval < 0) return retval - 4;

	// Disable temperature sensor, set clock source to internal 8MHz (accelerometer sample rate = 1KHz)
	retval = MPU6050_write_reg_readback(reg_pwr_mgmt_1, TEMP_DIS);
20001432:	f643 439c 	movw	r3, #15516	; 0x3c9c
20001436:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000143a:	681b      	ldr	r3, [r3, #0]
2000143c:	4618      	mov	r0, r3
2000143e:	f04f 0108 	mov.w	r1, #8
20001442:	f000 f8e7 	bl	20001614 <MPU6050_write_reg_readback>
20001446:	4603      	mov	r3, r0
20001448:	607b      	str	r3, [r7, #4]
	if (retval < 0) return retval - 12;
2000144a:	687b      	ldr	r3, [r7, #4]
2000144c:	2b00      	cmp	r3, #0
2000144e:	da03      	bge.n	20001458 <MPU6050_init+0x44>
20001450:	687b      	ldr	r3, [r7, #4]
20001452:	f1a3 030c 	sub.w	r3, r3, #12
20001456:	e08a      	b.n	2000156e <MPU6050_init+0x15a>

	// Gyro on standby and accelerometer running
	retval = MPU6050_write_reg_readback(reg_pwr_mgmt_2, STBY_XG | STBY_YG | STBY_ZG);
20001458:	f643 43a0 	movw	r3, #15520	; 0x3ca0
2000145c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001460:	681b      	ldr	r3, [r3, #0]
20001462:	4618      	mov	r0, r3
20001464:	f04f 0107 	mov.w	r1, #7
20001468:	f000 f8d4 	bl	20001614 <MPU6050_write_reg_readback>
2000146c:	4603      	mov	r3, r0
2000146e:	607b      	str	r3, [r7, #4]
	if (retval < 0) return retval - 16;
20001470:	687b      	ldr	r3, [r7, #4]
20001472:	2b00      	cmp	r3, #0
20001474:	da03      	bge.n	2000147e <MPU6050_init+0x6a>
20001476:	687b      	ldr	r3, [r7, #4]
20001478:	f1a3 0310 	sub.w	r3, r3, #16
2000147c:	e077      	b.n	2000156e <MPU6050_init+0x15a>

	// Tell FIFO to accept samples from all accelerometer axes
	retval = MPU6050_write_reg_readback(reg_fifo_en, ACCEL_FIFO_EN);
2000147e:	f643 43a4 	movw	r3, #15524	; 0x3ca4
20001482:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001486:	681b      	ldr	r3, [r3, #0]
20001488:	4618      	mov	r0, r3
2000148a:	f04f 0108 	mov.w	r1, #8
2000148e:	f000 f8c1 	bl	20001614 <MPU6050_write_reg_readback>
20001492:	4603      	mov	r3, r0
20001494:	607b      	str	r3, [r7, #4]
	if (retval < 0) return retval - 20;
20001496:	687b      	ldr	r3, [r7, #4]
20001498:	2b00      	cmp	r3, #0
2000149a:	da03      	bge.n	200014a4 <MPU6050_init+0x90>
2000149c:	687b      	ldr	r3, [r7, #4]
2000149e:	f1a3 0314 	sub.w	r3, r3, #20
200014a2:	e064      	b.n	2000156e <MPU6050_init+0x15a>

	// Configure INT pin to hold until reset and interrupts cleared on any read
	retval = MPU6050_write_reg_readback(reg_int_pin_cfg, LATCH_INT_EN | INT_RD_CLEAR);
200014a4:	f643 43a8 	movw	r3, #15528	; 0x3ca8
200014a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200014ac:	681b      	ldr	r3, [r3, #0]
200014ae:	4618      	mov	r0, r3
200014b0:	f04f 0130 	mov.w	r1, #48	; 0x30
200014b4:	f000 f8ae 	bl	20001614 <MPU6050_write_reg_readback>
200014b8:	4603      	mov	r3, r0
200014ba:	607b      	str	r3, [r7, #4]
	if (retval < 0) return retval - 24;
200014bc:	687b      	ldr	r3, [r7, #4]
200014be:	2b00      	cmp	r3, #0
200014c0:	da03      	bge.n	200014ca <MPU6050_init+0xb6>
200014c2:	687b      	ldr	r3, [r7, #4]
200014c4:	f1a3 0318 	sub.w	r3, r3, #24
200014c8:	e051      	b.n	2000156e <MPU6050_init+0x15a>

	// Make sure the user crtl register is cleared
	retval = MPU6050_write_reg_readback(reg_user_ctrl, 0);
200014ca:	f643 43ac 	movw	r3, #15532	; 0x3cac
200014ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
200014d2:	681b      	ldr	r3, [r3, #0]
200014d4:	4618      	mov	r0, r3
200014d6:	f04f 0100 	mov.w	r1, #0
200014da:	f000 f89b 	bl	20001614 <MPU6050_write_reg_readback>
200014de:	4603      	mov	r3, r0
200014e0:	607b      	str	r3, [r7, #4]
	if (retval < 0) return retval - 28;
200014e2:	687b      	ldr	r3, [r7, #4]
200014e4:	2b00      	cmp	r3, #0
200014e6:	da03      	bge.n	200014f0 <MPU6050_init+0xdc>
200014e8:	687b      	ldr	r3, [r7, #4]
200014ea:	f1a3 031c 	sub.w	r3, r3, #28
200014ee:	e03e      	b.n	2000156e <MPU6050_init+0x15a>

	// Reset the FIFO, signal paths and sensor registers (bits cleared internally after reset initiated)
	// Don't user MPU6050_write_reg_readback() since the bits may not be set on readback.
	retval = MPU6050_write_reg(reg_user_ctrl, FIFO_RESET | SIG_COND_RESET);
200014f0:	f643 43ac 	movw	r3, #15532	; 0x3cac
200014f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200014f8:	681b      	ldr	r3, [r3, #0]
200014fa:	4618      	mov	r0, r3
200014fc:	f04f 0105 	mov.w	r1, #5
20001500:	f000 f83a 	bl	20001578 <MPU6050_write_reg>
20001504:	4603      	mov	r3, r0
20001506:	607b      	str	r3, [r7, #4]
	if (retval < 0) return retval - 32;
20001508:	687b      	ldr	r3, [r7, #4]
2000150a:	2b00      	cmp	r3, #0
2000150c:	da03      	bge.n	20001516 <MPU6050_init+0x102>
2000150e:	687b      	ldr	r3, [r7, #4]
20001510:	f1a3 0320 	sub.w	r3, r3, #32
20001514:	e02b      	b.n	2000156e <MPU6050_init+0x15a>

	// Enable FIFO overflow and data ready interrupts
	retval = MPU6050_write_reg_readback(reg_int_enable, FIFO_OFLOW_EN | DATA_RDY_EN);
20001516:	f643 43b4 	movw	r3, #15540	; 0x3cb4
2000151a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000151e:	681b      	ldr	r3, [r3, #0]
20001520:	4618      	mov	r0, r3
20001522:	f04f 0111 	mov.w	r1, #17
20001526:	f000 f875 	bl	20001614 <MPU6050_write_reg_readback>
2000152a:	4603      	mov	r3, r0
2000152c:	607b      	str	r3, [r7, #4]
	if (retval < 0) return retval - 36;
2000152e:	687b      	ldr	r3, [r7, #4]
20001530:	2b00      	cmp	r3, #0
20001532:	da03      	bge.n	2000153c <MPU6050_init+0x128>
20001534:	687b      	ldr	r3, [r7, #4]
20001536:	f1a3 0324 	sub.w	r3, r3, #36	; 0x24
2000153a:	e018      	b.n	2000156e <MPU6050_init+0x15a>

	// Enable the FIFO
	retval = MPU6050_write_reg_readback(reg_user_ctrl, FIFO_EN);
2000153c:	f643 43ac 	movw	r3, #15532	; 0x3cac
20001540:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001544:	681b      	ldr	r3, [r3, #0]
20001546:	4618      	mov	r0, r3
20001548:	f04f 0140 	mov.w	r1, #64	; 0x40
2000154c:	f000 f862 	bl	20001614 <MPU6050_write_reg_readback>
20001550:	4603      	mov	r3, r0
20001552:	607b      	str	r3, [r7, #4]
	if (retval < 0) return retval - 40;
20001554:	687b      	ldr	r3, [r7, #4]
20001556:	2b00      	cmp	r3, #0
20001558:	da03      	bge.n	20001562 <MPU6050_init+0x14e>
2000155a:	687b      	ldr	r3, [r7, #4]
2000155c:	f1a3 0328 	sub.w	r3, r3, #40	; 0x28
20001560:	e005      	b.n	2000156e <MPU6050_init+0x15a>

	return *mpu_status;
20001562:	f643 43c4 	movw	r3, #15556	; 0x3cc4
20001566:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000156a:	681b      	ldr	r3, [r3, #0]
2000156c:	681b      	ldr	r3, [r3, #0]
}
2000156e:	4618      	mov	r0, r3
20001570:	f107 0708 	add.w	r7, r7, #8
20001574:	46bd      	mov	sp, r7
20001576:	bd80      	pop	{r7, pc}

20001578 <MPU6050_write_reg>:

int MPU6050_write_reg(int *regaddr, uint8_t regval)
{
20001578:	b580      	push	{r7, lr}
2000157a:	b084      	sub	sp, #16
2000157c:	af00      	add	r7, sp, #0
2000157e:	6078      	str	r0, [r7, #4]
20001580:	460b      	mov	r3, r1
20001582:	70fb      	strb	r3, [r7, #3]
	int stat;

	*regaddr = regval;
20001584:	78fa      	ldrb	r2, [r7, #3]
20001586:	687b      	ldr	r3, [r7, #4]
20001588:	601a      	str	r2, [r3, #0]

	mpu_delay(600);
2000158a:	f44f 7016 	mov.w	r0, #600	; 0x258
2000158e:	f7ff ff29 	bl	200013e4 <mpu_delay>

    do {
    	stat = *mpu_status;
20001592:	f643 43c4 	movw	r3, #15556	; 0x3cc4
20001596:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000159a:	681b      	ldr	r3, [r3, #0]
2000159c:	681b      	ldr	r3, [r3, #0]
2000159e:	60fb      	str	r3, [r7, #12]
    } while (stat & APB_BUSY);
200015a0:	68fb      	ldr	r3, [r7, #12]
200015a2:	f003 0308 	and.w	r3, r3, #8
200015a6:	2b00      	cmp	r3, #0
200015a8:	d1f3      	bne.n	20001592 <MPU6050_write_reg+0x1a>

    return (stat & REG_WR_OK);
200015aa:	68fb      	ldr	r3, [r7, #12]
200015ac:	f003 0302 	and.w	r3, r3, #2
}
200015b0:	4618      	mov	r0, r3
200015b2:	f107 0710 	add.w	r7, r7, #16
200015b6:	46bd      	mov	sp, r7
200015b8:	bd80      	pop	{r7, pc}
200015ba:	bf00      	nop

200015bc <MPU6050_read_reg>:

int MPU6050_read_reg(int *regaddr, uint8_t *regval)
{
200015bc:	b580      	push	{r7, lr}
200015be:	b084      	sub	sp, #16
200015c0:	af00      	add	r7, sp, #0
200015c2:	6078      	str	r0, [r7, #4]
200015c4:	6039      	str	r1, [r7, #0]
	int stat;

	// The first read initiates the I2C transfer.
	*regval = *regaddr;
200015c6:	687b      	ldr	r3, [r7, #4]
200015c8:	681b      	ldr	r3, [r3, #0]
200015ca:	b2da      	uxtb	r2, r3
200015cc:	683b      	ldr	r3, [r7, #0]
200015ce:	701a      	strb	r2, [r3, #0]

	mpu_delay(600);
200015d0:	f44f 7016 	mov.w	r0, #600	; 0x258
200015d4:	f7ff ff06 	bl	200013e4 <mpu_delay>

	do {
    	stat = *mpu_status;
200015d8:	f643 43c4 	movw	r3, #15556	; 0x3cc4
200015dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
200015e0:	681b      	ldr	r3, [r3, #0]
200015e2:	681b      	ldr	r3, [r3, #0]
200015e4:	60fb      	str	r3, [r7, #12]
    } while (stat & APB_BUSY);
200015e6:	68fb      	ldr	r3, [r7, #12]
200015e8:	f003 0308 	and.w	r3, r3, #8
200015ec:	2b00      	cmp	r3, #0
200015ee:	d1f3      	bne.n	200015d8 <MPU6050_read_reg+0x1c>

    // The second read gets the value.
    *regval = *read_result;
200015f0:	f643 43c8 	movw	r3, #15560	; 0x3cc8
200015f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200015f8:	681b      	ldr	r3, [r3, #0]
200015fa:	681b      	ldr	r3, [r3, #0]
200015fc:	b2da      	uxtb	r2, r3
200015fe:	683b      	ldr	r3, [r7, #0]
20001600:	701a      	strb	r2, [r3, #0]

	return (stat & REG_RD_OK);
20001602:	68fb      	ldr	r3, [r7, #12]
20001604:	f003 0301 	and.w	r3, r3, #1
}
20001608:	4618      	mov	r0, r3
2000160a:	f107 0710 	add.w	r7, r7, #16
2000160e:	46bd      	mov	sp, r7
20001610:	bd80      	pop	{r7, pc}
20001612:	bf00      	nop

20001614 <MPU6050_write_reg_readback>:

int MPU6050_write_reg_readback(int *regaddr, uint8_t regval)
{
20001614:	b580      	push	{r7, lr}
20001616:	b084      	sub	sp, #16
20001618:	af00      	add	r7, sp, #0
2000161a:	6078      	str	r0, [r7, #4]
2000161c:	460b      	mov	r3, r1
2000161e:	70fb      	strb	r3, [r7, #3]
	uint8_t i2c_read_buf;

	if (MPU6050_write_reg(regaddr, regval) == 0) return -1;
20001620:	78fb      	ldrb	r3, [r7, #3]
20001622:	6878      	ldr	r0, [r7, #4]
20001624:	4619      	mov	r1, r3
20001626:	f7ff ffa7 	bl	20001578 <MPU6050_write_reg>
2000162a:	4603      	mov	r3, r0
2000162c:	2b00      	cmp	r3, #0
2000162e:	d102      	bne.n	20001636 <MPU6050_write_reg_readback+0x22>
20001630:	f04f 33ff 	mov.w	r3, #4294967295
20001634:	e018      	b.n	20001668 <MPU6050_write_reg_readback+0x54>
	if (MPU6050_read_reg(regaddr, &i2c_read_buf) == 0) return -2;
20001636:	f107 030f 	add.w	r3, r7, #15
2000163a:	6878      	ldr	r0, [r7, #4]
2000163c:	4619      	mov	r1, r3
2000163e:	f7ff ffbd 	bl	200015bc <MPU6050_read_reg>
20001642:	4603      	mov	r3, r0
20001644:	2b00      	cmp	r3, #0
20001646:	d102      	bne.n	2000164e <MPU6050_write_reg_readback+0x3a>
20001648:	f06f 0301 	mvn.w	r3, #1
2000164c:	e00c      	b.n	20001668 <MPU6050_write_reg_readback+0x54>
	if (i2c_read_buf != regval) return -3;
2000164e:	7bfb      	ldrb	r3, [r7, #15]
20001650:	78fa      	ldrb	r2, [r7, #3]
20001652:	429a      	cmp	r2, r3
20001654:	d002      	beq.n	2000165c <MPU6050_write_reg_readback+0x48>
20001656:	f06f 0302 	mvn.w	r3, #2
2000165a:	e005      	b.n	20001668 <MPU6050_write_reg_readback+0x54>

	mpu_delay(100);
2000165c:	f04f 0064 	mov.w	r0, #100	; 0x64
20001660:	f7ff fec0 	bl	200013e4 <mpu_delay>

	return 0;
20001664:	f04f 0300 	mov.w	r3, #0
}
20001668:	4618      	mov	r0, r3
2000166a:	f107 0710 	add.w	r7, r7, #16
2000166e:	46bd      	mov	sp, r7
20001670:	bd80      	pop	{r7, pc}
20001672:	bf00      	nop

20001674 <MPU6050_clear_FIFO>:

	return 0;
}

int MPU6050_clear_FIFO(void)
{
20001674:	b580      	push	{r7, lr}
20001676:	f5ad 6d82 	sub.w	sp, sp, #1040	; 0x410
2000167a:	af00      	add	r7, sp, #0
	uint8_t int_status = 0;
2000167c:	f04f 0300 	mov.w	r3, #0
20001680:	f887 3405 	strb.w	r3, [r7, #1029]	; 0x405
	uint16_t byte_count = 0;
20001684:	f04f 0300 	mov.w	r3, #0
20001688:	f8a7 3406 	strh.w	r3, [r7, #1030]	; 0x406
	uint8_t buf[1024];

	// Disable FIFO interrupts
	int retval = MPU6050_write_reg_readback(reg_int_enable, 0);
2000168c:	f643 43b4 	movw	r3, #15540	; 0x3cb4
20001690:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001694:	681b      	ldr	r3, [r3, #0]
20001696:	4618      	mov	r0, r3
20001698:	f04f 0100 	mov.w	r1, #0
2000169c:	f7ff ffba 	bl	20001614 <MPU6050_write_reg_readback>
200016a0:	4603      	mov	r3, r0
200016a2:	f8c7 3408 	str.w	r3, [r7, #1032]	; 0x408
	if (retval < 0) return retval;
200016a6:	f8d7 3408 	ldr.w	r3, [r7, #1032]	; 0x408
200016aa:	2b00      	cmp	r3, #0
200016ac:	da02      	bge.n	200016b4 <MPU6050_clear_FIFO+0x40>
200016ae:	f8d7 3408 	ldr.w	r3, [r7, #1032]	; 0x408
200016b2:	e05b      	b.n	2000176c <MPU6050_clear_FIFO+0xf8>

	byte_count = MPU6050_get_FIFO_byte_count();
200016b4:	f000 f860 	bl	20001778 <MPU6050_get_FIFO_byte_count>
200016b8:	4603      	mov	r3, r0
200016ba:	f8a7 3406 	strh.w	r3, [r7, #1030]	; 0x406

    int i;
    for (i = 0; i < byte_count; i++) {
200016be:	f04f 0300 	mov.w	r3, #0
200016c2:	f8c7 340c 	str.w	r3, [r7, #1036]	; 0x40c
200016c6:	e01b      	b.n	20001700 <MPU6050_clear_FIFO+0x8c>
		if (MPU6050_read_reg(reg_fifo_r_w, &buf[i]) == 0) return -5;
200016c8:	f643 43c0 	movw	r3, #15552	; 0x3cc0
200016cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
200016d0:	681a      	ldr	r2, [r3, #0]
200016d2:	f8d7 140c 	ldr.w	r1, [r7, #1036]	; 0x40c
200016d6:	f107 0310 	add.w	r3, r7, #16
200016da:	f1a3 030c 	sub.w	r3, r3, #12
200016de:	440b      	add	r3, r1
200016e0:	4610      	mov	r0, r2
200016e2:	4619      	mov	r1, r3
200016e4:	f7ff ff6a 	bl	200015bc <MPU6050_read_reg>
200016e8:	4603      	mov	r3, r0
200016ea:	2b00      	cmp	r3, #0
200016ec:	d102      	bne.n	200016f4 <MPU6050_clear_FIFO+0x80>
200016ee:	f06f 0304 	mvn.w	r3, #4
200016f2:	e03b      	b.n	2000176c <MPU6050_clear_FIFO+0xf8>
	if (retval < 0) return retval;

	byte_count = MPU6050_get_FIFO_byte_count();

    int i;
    for (i = 0; i < byte_count; i++) {
200016f4:	f8d7 340c 	ldr.w	r3, [r7, #1036]	; 0x40c
200016f8:	f103 0301 	add.w	r3, r3, #1
200016fc:	f8c7 340c 	str.w	r3, [r7, #1036]	; 0x40c
20001700:	f8b7 2406 	ldrh.w	r2, [r7, #1030]	; 0x406
20001704:	f8d7 340c 	ldr.w	r3, [r7, #1036]	; 0x40c
20001708:	429a      	cmp	r2, r3
2000170a:	dcdd      	bgt.n	200016c8 <MPU6050_clear_FIFO+0x54>
		if (MPU6050_read_reg(reg_fifo_r_w, &buf[i]) == 0) return -5;
	}

	if (MPU6050_read_reg(reg_int_status, &int_status) == 0) return -6;
2000170c:	f643 43b0 	movw	r3, #15536	; 0x3cb0
20001710:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001714:	681a      	ldr	r2, [r3, #0]
20001716:	f507 6380 	add.w	r3, r7, #1024	; 0x400
2000171a:	f103 0305 	add.w	r3, r3, #5
2000171e:	4610      	mov	r0, r2
20001720:	4619      	mov	r1, r3
20001722:	f7ff ff4b 	bl	200015bc <MPU6050_read_reg>
20001726:	4603      	mov	r3, r0
20001728:	2b00      	cmp	r3, #0
2000172a:	d102      	bne.n	20001732 <MPU6050_clear_FIFO+0xbe>
2000172c:	f06f 0305 	mvn.w	r3, #5
20001730:	e01c      	b.n	2000176c <MPU6050_clear_FIFO+0xf8>

	byte_count = MPU6050_get_FIFO_byte_count();
20001732:	f000 f821 	bl	20001778 <MPU6050_get_FIFO_byte_count>
20001736:	4603      	mov	r3, r0
20001738:	f8a7 3406 	strh.w	r3, [r7, #1030]	; 0x406

	// Re-enable FIFO overflow and data ready interrupts
	retval = MPU6050_write_reg_readback(reg_int_enable, FIFO_OFLOW_EN | DATA_RDY_EN);
2000173c:	f643 43b4 	movw	r3, #15540	; 0x3cb4
20001740:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001744:	681b      	ldr	r3, [r3, #0]
20001746:	4618      	mov	r0, r3
20001748:	f04f 0111 	mov.w	r1, #17
2000174c:	f7ff ff62 	bl	20001614 <MPU6050_write_reg_readback>
20001750:	4603      	mov	r3, r0
20001752:	f8c7 3408 	str.w	r3, [r7, #1032]	; 0x408
	if (retval < 0) return retval - 8;
20001756:	f8d7 3408 	ldr.w	r3, [r7, #1032]	; 0x408
2000175a:	2b00      	cmp	r3, #0
2000175c:	da04      	bge.n	20001768 <MPU6050_clear_FIFO+0xf4>
2000175e:	f8d7 3408 	ldr.w	r3, [r7, #1032]	; 0x408
20001762:	f1a3 0308 	sub.w	r3, r3, #8
20001766:	e001      	b.n	2000176c <MPU6050_clear_FIFO+0xf8>

	return byte_count;
20001768:	f8b7 3406 	ldrh.w	r3, [r7, #1030]	; 0x406
}
2000176c:	4618      	mov	r0, r3
2000176e:	f507 6782 	add.w	r7, r7, #1040	; 0x410
20001772:	46bd      	mov	sp, r7
20001774:	bd80      	pop	{r7, pc}
20001776:	bf00      	nop

20001778 <MPU6050_get_FIFO_byte_count>:

int MPU6050_get_FIFO_byte_count(void)
{
20001778:	b580      	push	{r7, lr}
2000177a:	b084      	sub	sp, #16
2000177c:	af00      	add	r7, sp, #0
	uint16_t bc = 0;
2000177e:	f04f 0300 	mov.w	r3, #0
20001782:	807b      	strh	r3, [r7, #2]
	uint8_t i2c_read_1 = 0, i2c_read_2 = 0;
20001784:	f04f 0300 	mov.w	r3, #0
20001788:	707b      	strb	r3, [r7, #1]
2000178a:	f04f 0300 	mov.w	r3, #0
2000178e:	703b      	strb	r3, [r7, #0]

	// get high FIFO count byte
	if (MPU6050_read_reg(reg_fifo_count_h, &i2c_read_1) == 0) return -2;
20001790:	f643 43b8 	movw	r3, #15544	; 0x3cb8
20001794:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001798:	681a      	ldr	r2, [r3, #0]
2000179a:	f107 0301 	add.w	r3, r7, #1
2000179e:	4610      	mov	r0, r2
200017a0:	4619      	mov	r1, r3
200017a2:	f7ff ff0b 	bl	200015bc <MPU6050_read_reg>
200017a6:	4603      	mov	r3, r0
200017a8:	2b00      	cmp	r3, #0
200017aa:	d102      	bne.n	200017b2 <MPU6050_get_FIFO_byte_count+0x3a>
200017ac:	f06f 0301 	mvn.w	r3, #1
200017b0:	e025      	b.n	200017fe <MPU6050_get_FIFO_byte_count+0x86>
	bc = i2c_read_1 << 8;
200017b2:	787b      	ldrb	r3, [r7, #1]
200017b4:	ea4f 2303 	mov.w	r3, r3, lsl #8
200017b8:	807b      	strh	r3, [r7, #2]
int x = i2c_read_1;
200017ba:	787b      	ldrb	r3, [r7, #1]
200017bc:	607b      	str	r3, [r7, #4]
	// get low FIFO count byte
	if (MPU6050_read_reg(reg_fifo_count_l, &i2c_read_2) == 0) return -3;
200017be:	f643 43bc 	movw	r3, #15548	; 0x3cbc
200017c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200017c6:	681a      	ldr	r2, [r3, #0]
200017c8:	463b      	mov	r3, r7
200017ca:	4610      	mov	r0, r2
200017cc:	4619      	mov	r1, r3
200017ce:	f7ff fef5 	bl	200015bc <MPU6050_read_reg>
200017d2:	4603      	mov	r3, r0
200017d4:	2b00      	cmp	r3, #0
200017d6:	d102      	bne.n	200017de <MPU6050_get_FIFO_byte_count+0x66>
200017d8:	f06f 0302 	mvn.w	r3, #2
200017dc:	e00f      	b.n	200017fe <MPU6050_get_FIFO_byte_count+0x86>
	bc += i2c_read_2;
200017de:	783b      	ldrb	r3, [r7, #0]
200017e0:	461a      	mov	r2, r3
200017e2:	887b      	ldrh	r3, [r7, #2]
200017e4:	4413      	add	r3, r2
200017e6:	807b      	strh	r3, [r7, #2]
int y = i2c_read_2;
200017e8:	783b      	ldrb	r3, [r7, #0]
200017ea:	60bb      	str	r3, [r7, #8]
int z = (x << 8);
200017ec:	687b      	ldr	r3, [r7, #4]
200017ee:	ea4f 2303 	mov.w	r3, r3, lsl #8
200017f2:	60fb      	str	r3, [r7, #12]
z += y;
200017f4:	68fa      	ldr	r2, [r7, #12]
200017f6:	68bb      	ldr	r3, [r7, #8]
200017f8:	4413      	add	r3, r2
200017fa:	60fb      	str	r3, [r7, #12]

	return bc;
200017fc:	887b      	ldrh	r3, [r7, #2]
}
200017fe:	4618      	mov	r0, r3
20001800:	f107 0710 	add.w	r7, r7, #16
20001804:	46bd      	mov	sp, r7
20001806:	bd80      	pop	{r7, pc}

20001808 <gpio_init>:

//Structures for HDL library core functions
gpio_instance_t gpio_core_handle;

void gpio_init(void)
{
20001808:	b580      	push	{r7, lr}
2000180a:	af00      	add	r7, sp, #0
	// Initialize and configure the MSS internal GPIO block as opposed to a library Core such as CoreGPIO (see below)
	// Used for direct-from-M3 debug output and HDL-to-M3 interrupts

	MSS_GPIO_init();
2000180c:	f001 fde8 	bl	200033e0 <MSS_GPIO_init>

	MSS_GPIO_config(MSS_GPIO_0, MSS_GPIO_OUTPUT_MODE);
20001810:	f04f 0000 	mov.w	r0, #0
20001814:	f04f 0105 	mov.w	r1, #5
20001818:	f001 fe38 	bl	2000348c <MSS_GPIO_config>
	MSS_GPIO_config(MSS_GPIO_1, MSS_GPIO_OUTPUT_MODE);
2000181c:	f04f 0001 	mov.w	r0, #1
20001820:	f04f 0105 	mov.w	r1, #5
20001824:	f001 fe32 	bl	2000348c <MSS_GPIO_config>
	MSS_GPIO_config(MSS_GPIO_2, MSS_GPIO_OUTPUT_MODE);
20001828:	f04f 0002 	mov.w	r0, #2
2000182c:	f04f 0105 	mov.w	r1, #5
20001830:	f001 fe2c 	bl	2000348c <MSS_GPIO_config>
	MSS_GPIO_config(MSS_GPIO_3, MSS_GPIO_OUTPUT_MODE);
20001834:	f04f 0003 	mov.w	r0, #3
20001838:	f04f 0105 	mov.w	r1, #5
2000183c:	f001 fe26 	bl	2000348c <MSS_GPIO_config>
	MSS_GPIO_config(MSS_GPIO_4, MSS_GPIO_OUTPUT_MODE);	// ACC_CLKIN
20001840:	f04f 0004 	mov.w	r0, #4
20001844:	f04f 0105 	mov.w	r1, #5
20001848:	f001 fe20 	bl	2000348c <MSS_GPIO_config>
	MSS_GPIO_config(MSS_GPIO_5, MSS_GPIO_INPUT_MODE | MSS_GPIO_IRQ_EDGE_POSITIVE);	// PDMA done interrupt
2000184c:	f04f 0005 	mov.w	r0, #5
20001850:	f04f 0142 	mov.w	r1, #66	; 0x42
20001854:	f001 fe1a 	bl	2000348c <MSS_GPIO_config>
	MSS_GPIO_config(MSS_GPIO_6, MSS_GPIO_INPUT_MODE | MSS_GPIO_IRQ_EDGE_POSITIVE);	// ACK ready interrupt
20001858:	f04f 0006 	mov.w	r0, #6
2000185c:	f04f 0142 	mov.w	r1, #66	; 0x42
20001860:	f001 fe14 	bl	2000348c <MSS_GPIO_config>
	MSS_GPIO_config(MSS_GPIO_7, MSS_GPIO_INPUT_MODE | MSS_GPIO_IRQ_EDGE_POSITIVE);	// FFT ready interrupt
20001864:	f04f 0007 	mov.w	r0, #7
20001868:	f04f 0142 	mov.w	r1, #66	; 0x42
2000186c:	f001 fe0e 	bl	2000348c <MSS_GPIO_config>
	MSS_GPIO_config(MSS_GPIO_8, MSS_GPIO_INPUT_MODE | MSS_GPIO_IRQ_EDGE_POSITIVE);	// Accelerometer FIFO overflow interrupt
20001870:	f04f 0008 	mov.w	r0, #8
20001874:	f04f 0142 	mov.w	r1, #66	; 0x42
20001878:	f001 fe08 	bl	2000348c <MSS_GPIO_config>

	MSS_GPIO_set_output(MSS_GPIO_0, 0);
2000187c:	f04f 0000 	mov.w	r0, #0
20001880:	f04f 0100 	mov.w	r1, #0
20001884:	f001 fe20 	bl	200034c8 <MSS_GPIO_set_output>
	MSS_GPIO_set_output(MSS_GPIO_1, 0);
20001888:	f04f 0001 	mov.w	r0, #1
2000188c:	f04f 0100 	mov.w	r1, #0
20001890:	f001 fe1a 	bl	200034c8 <MSS_GPIO_set_output>
	MSS_GPIO_set_output(MSS_GPIO_2, 0);
20001894:	f04f 0002 	mov.w	r0, #2
20001898:	f04f 0100 	mov.w	r1, #0
2000189c:	f001 fe14 	bl	200034c8 <MSS_GPIO_set_output>
	MSS_GPIO_set_output(MSS_GPIO_3, 0);
200018a0:	f04f 0003 	mov.w	r0, #3
200018a4:	f04f 0100 	mov.w	r1, #0
200018a8:	f001 fe0e 	bl	200034c8 <MSS_GPIO_set_output>
	MSS_GPIO_set_output(MSS_GPIO_4, 0);
200018ac:	f04f 0004 	mov.w	r0, #4
200018b0:	f04f 0100 	mov.w	r1, #0
200018b4:	f001 fe08 	bl	200034c8 <MSS_GPIO_set_output>

	// Initialize and configure CoreGPIO
    // This is a soft core from the HDL catalog as opposed to the MSS internal GPIO block (see above)
	// Used for HDL-to-M3 interrupt management
	GPIO_init(&gpio_core_handle, CoreGPIO_REG_BASE, GPIO_APB_32_BITS_BUS);
200018b8:	f643 70e4 	movw	r0, #16356	; 0x3fe4
200018bc:	f2c2 0000 	movt	r0, #8192	; 0x2000
200018c0:	f240 0100 	movw	r1, #0
200018c4:	f2c3 0101 	movt	r1, #12289	; 0x3001
200018c8:	f04f 0202 	mov.w	r2, #2
200018cc:	f001 fe84 	bl	200035d8 <GPIO_init>
	GPIO_config(&gpio_core_handle, GPIO_0, GPIO_IRQ_EDGE_POSITIVE);	// PDMA done
200018d0:	f643 70e4 	movw	r0, #16356	; 0x3fe4
200018d4:	f2c2 0000 	movt	r0, #8192	; 0x2000
200018d8:	f04f 0100 	mov.w	r1, #0
200018dc:	f04f 0240 	mov.w	r2, #64	; 0x40
200018e0:	f001 fef2 	bl	200036c8 <GPIO_config>
	GPIO_config(&gpio_core_handle, GPIO_1, GPIO_IRQ_EDGE_POSITIVE);	// ACK ready
200018e4:	f643 70e4 	movw	r0, #16356	; 0x3fe4
200018e8:	f2c2 0000 	movt	r0, #8192	; 0x2000
200018ec:	f04f 0101 	mov.w	r1, #1
200018f0:	f04f 0240 	mov.w	r2, #64	; 0x40
200018f4:	f001 fee8 	bl	200036c8 <GPIO_config>
	GPIO_config(&gpio_core_handle, GPIO_2, GPIO_IRQ_EDGE_POSITIVE);	// FFT ready
200018f8:	f643 70e4 	movw	r0, #16356	; 0x3fe4
200018fc:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001900:	f04f 0102 	mov.w	r1, #2
20001904:	f04f 0240 	mov.w	r2, #64	; 0x40
20001908:	f001 fede 	bl	200036c8 <GPIO_config>
	GPIO_config(&gpio_core_handle, GPIO_3, GPIO_IRQ_EDGE_POSITIVE);	// Accelerometer FIFO overflow
2000190c:	f643 70e4 	movw	r0, #16356	; 0x3fe4
20001910:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001914:	f04f 0103 	mov.w	r1, #3
20001918:	f04f 0240 	mov.w	r2, #64	; 0x40
2000191c:	f001 fed4 	bl	200036c8 <GPIO_config>
}
20001920:	bd80      	pop	{r7, pc}
20001922:	bf00      	nop

20001924 <init_ADC_vectors>:
//
// Initializes HDL channel vector tables from nm_rec_enable_vector
//
void init_ADC_vectors(void)
{
20001924:	b580      	push	{r7, lr}
20001926:	af00      	add	r7, sp, #0
	writeNMreg(NM0, NM_REC_ENABLE0_REG, nm0_rec_enable_vector[3]);
20001928:	f643 530c 	movw	r3, #15628	; 0x3d0c
2000192c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001930:	88db      	ldrh	r3, [r3, #6]
20001932:	f04f 0000 	mov.w	r0, #0
20001936:	f04f 0104 	mov.w	r1, #4
2000193a:	461a      	mov	r2, r3
2000193c:	f000 f9b4 	bl	20001ca8 <writeNMreg>
	writeNMreg(NM0, NM_REC_ENABLE1_REG, nm0_rec_enable_vector[2]);
20001940:	f643 530c 	movw	r3, #15628	; 0x3d0c
20001944:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001948:	889b      	ldrh	r3, [r3, #4]
2000194a:	f04f 0000 	mov.w	r0, #0
2000194e:	f04f 0105 	mov.w	r1, #5
20001952:	461a      	mov	r2, r3
20001954:	f000 f9a8 	bl	20001ca8 <writeNMreg>
	writeNMreg(NM0, NM_REC_ENABLE2_REG, nm0_rec_enable_vector[1]);
20001958:	f643 530c 	movw	r3, #15628	; 0x3d0c
2000195c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001960:	885b      	ldrh	r3, [r3, #2]
20001962:	f04f 0000 	mov.w	r0, #0
20001966:	f04f 0106 	mov.w	r1, #6
2000196a:	461a      	mov	r2, r3
2000196c:	f000 f99c 	bl	20001ca8 <writeNMreg>
	writeNMreg(NM0, NM_REC_ENABLE3_REG, nm0_rec_enable_vector[0]);
20001970:	f643 530c 	movw	r3, #15628	; 0x3d0c
20001974:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001978:	881b      	ldrh	r3, [r3, #0]
2000197a:	f04f 0000 	mov.w	r0, #0
2000197e:	f04f 0107 	mov.w	r1, #7
20001982:	461a      	mov	r2, r3
20001984:	f000 f990 	bl	20001ca8 <writeNMreg>

	writeNMreg(NM1, NM_REC_ENABLE0_REG, nm1_rec_enable_vector[3]);
20001988:	f643 5314 	movw	r3, #15636	; 0x3d14
2000198c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001990:	88db      	ldrh	r3, [r3, #6]
20001992:	f04f 0001 	mov.w	r0, #1
20001996:	f04f 0104 	mov.w	r1, #4
2000199a:	461a      	mov	r2, r3
2000199c:	f000 f984 	bl	20001ca8 <writeNMreg>
	writeNMreg(NM1, NM_REC_ENABLE1_REG, nm1_rec_enable_vector[2]);
200019a0:	f643 5314 	movw	r3, #15636	; 0x3d14
200019a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200019a8:	889b      	ldrh	r3, [r3, #4]
200019aa:	f04f 0001 	mov.w	r0, #1
200019ae:	f04f 0105 	mov.w	r1, #5
200019b2:	461a      	mov	r2, r3
200019b4:	f000 f978 	bl	20001ca8 <writeNMreg>
	writeNMreg(NM1, NM_REC_ENABLE2_REG, nm1_rec_enable_vector[1]);
200019b8:	f643 5314 	movw	r3, #15636	; 0x3d14
200019bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
200019c0:	885b      	ldrh	r3, [r3, #2]
200019c2:	f04f 0001 	mov.w	r0, #1
200019c6:	f04f 0106 	mov.w	r1, #6
200019ca:	461a      	mov	r2, r3
200019cc:	f000 f96c 	bl	20001ca8 <writeNMreg>
	writeNMreg(NM1, NM_REC_ENABLE3_REG, nm1_rec_enable_vector[0]);
200019d0:	f643 5314 	movw	r3, #15636	; 0x3d14
200019d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200019d8:	881b      	ldrh	r3, [r3, #0]
200019da:	f04f 0001 	mov.w	r0, #1
200019de:	f04f 0107 	mov.w	r1, #7
200019e2:	461a      	mov	r2, r3
200019e4:	f000 f960 	bl	20001ca8 <writeNMreg>
}
200019e8:	bd80      	pop	{r7, pc}
200019ea:	bf00      	nop

200019ec <update_ADC_vectors>:

//
// Updates local (nm_rec_enable_vector) and HDL channel vector tables to reflect channels enabled in NMs
//
void update_ADC_vectors(int nmid, int nm_addr, int data)
{
200019ec:	b480      	push	{r7}
200019ee:	b085      	sub	sp, #20
200019f0:	af00      	add	r7, sp, #0
200019f2:	60f8      	str	r0, [r7, #12]
200019f4:	60b9      	str	r1, [r7, #8]
200019f6:	607a      	str	r2, [r7, #4]
	switch (nmid){
200019f8:	68fb      	ldr	r3, [r7, #12]
200019fa:	2b00      	cmp	r3, #0
200019fc:	d002      	beq.n	20001a04 <update_ADC_vectors+0x18>
200019fe:	2b01      	cmp	r3, #1
20001a00:	d07d      	beq.n	20001afe <update_ADC_vectors+0x112>
20001a02:	e0f9      	b.n	20001bf8 <update_ADC_vectors+0x20c>
	case 0:
		// need to update the channel select vector if writing to NM_REC_ENABLE reg
		if (nm_addr == NM_REC_ENABLE0_REG)
20001a04:	68bb      	ldr	r3, [r7, #8]
20001a06:	2b04      	cmp	r3, #4
20001a08:	d11b      	bne.n	20001a42 <update_ADC_vectors+0x56>
		{
			// channels 0-15
			nm0_rec_enable_vector[3] = data;
20001a0a:	687b      	ldr	r3, [r7, #4]
20001a0c:	b29a      	uxth	r2, r3
20001a0e:	f643 530c 	movw	r3, #15628	; 0x3d0c
20001a12:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001a16:	80da      	strh	r2, [r3, #6]
	 		*n0veclo = (nm0_rec_enable_vector[2] << 16) | nm0_rec_enable_vector[3];
20001a18:	f643 43ec 	movw	r3, #15596	; 0x3cec
20001a1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001a20:	681a      	ldr	r2, [r3, #0]
20001a22:	f643 530c 	movw	r3, #15628	; 0x3d0c
20001a26:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001a2a:	889b      	ldrh	r3, [r3, #4]
20001a2c:	ea4f 4103 	mov.w	r1, r3, lsl #16
20001a30:	f643 530c 	movw	r3, #15628	; 0x3d0c
20001a34:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001a38:	88db      	ldrh	r3, [r3, #6]
20001a3a:	ea41 0303 	orr.w	r3, r1, r3
20001a3e:	6013      	str	r3, [r2, #0]
		{
			// channels 48-63
			nm0_rec_enable_vector[0] = data;
	 		*n0vechi = (nm0_rec_enable_vector[0] << 16) | nm0_rec_enable_vector[1];
		}
		break;
20001a40:	e0da      	b.n	20001bf8 <update_ADC_vectors+0x20c>
		{
			// channels 0-15
			nm0_rec_enable_vector[3] = data;
	 		*n0veclo = (nm0_rec_enable_vector[2] << 16) | nm0_rec_enable_vector[3];
		}
		else if (nm_addr == NM_REC_ENABLE1_REG)
20001a42:	68bb      	ldr	r3, [r7, #8]
20001a44:	2b05      	cmp	r3, #5
20001a46:	d11b      	bne.n	20001a80 <update_ADC_vectors+0x94>
		{
			// channels 16-31
			nm0_rec_enable_vector[2] = data;
20001a48:	687b      	ldr	r3, [r7, #4]
20001a4a:	b29a      	uxth	r2, r3
20001a4c:	f643 530c 	movw	r3, #15628	; 0x3d0c
20001a50:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001a54:	809a      	strh	r2, [r3, #4]
	 		*n0veclo = (nm0_rec_enable_vector[2] << 16) | nm0_rec_enable_vector[3];
20001a56:	f643 43ec 	movw	r3, #15596	; 0x3cec
20001a5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001a5e:	681a      	ldr	r2, [r3, #0]
20001a60:	f643 530c 	movw	r3, #15628	; 0x3d0c
20001a64:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001a68:	889b      	ldrh	r3, [r3, #4]
20001a6a:	ea4f 4103 	mov.w	r1, r3, lsl #16
20001a6e:	f643 530c 	movw	r3, #15628	; 0x3d0c
20001a72:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001a76:	88db      	ldrh	r3, [r3, #6]
20001a78:	ea41 0303 	orr.w	r3, r1, r3
20001a7c:	6013      	str	r3, [r2, #0]
		{
			// channels 48-63
			nm0_rec_enable_vector[0] = data;
	 		*n0vechi = (nm0_rec_enable_vector[0] << 16) | nm0_rec_enable_vector[1];
		}
		break;
20001a7e:	e0bb      	b.n	20001bf8 <update_ADC_vectors+0x20c>
		{
			// channels 16-31
			nm0_rec_enable_vector[2] = data;
	 		*n0veclo = (nm0_rec_enable_vector[2] << 16) | nm0_rec_enable_vector[3];
		}
		else if (nm_addr == NM_REC_ENABLE2_REG)
20001a80:	68bb      	ldr	r3, [r7, #8]
20001a82:	2b06      	cmp	r3, #6
20001a84:	d11b      	bne.n	20001abe <update_ADC_vectors+0xd2>
		{
			// channels 32-47
			nm0_rec_enable_vector[1] = data;
20001a86:	687b      	ldr	r3, [r7, #4]
20001a88:	b29a      	uxth	r2, r3
20001a8a:	f643 530c 	movw	r3, #15628	; 0x3d0c
20001a8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001a92:	805a      	strh	r2, [r3, #2]
	 		*n0vechi = (nm0_rec_enable_vector[0] << 16) | nm0_rec_enable_vector[1];
20001a94:	f643 43e8 	movw	r3, #15592	; 0x3ce8
20001a98:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001a9c:	681a      	ldr	r2, [r3, #0]
20001a9e:	f643 530c 	movw	r3, #15628	; 0x3d0c
20001aa2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001aa6:	881b      	ldrh	r3, [r3, #0]
20001aa8:	ea4f 4103 	mov.w	r1, r3, lsl #16
20001aac:	f643 530c 	movw	r3, #15628	; 0x3d0c
20001ab0:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001ab4:	885b      	ldrh	r3, [r3, #2]
20001ab6:	ea41 0303 	orr.w	r3, r1, r3
20001aba:	6013      	str	r3, [r2, #0]
		{
			// channels 48-63
			nm0_rec_enable_vector[0] = data;
	 		*n0vechi = (nm0_rec_enable_vector[0] << 16) | nm0_rec_enable_vector[1];
		}
		break;
20001abc:	e09c      	b.n	20001bf8 <update_ADC_vectors+0x20c>
		{
			// channels 32-47
			nm0_rec_enable_vector[1] = data;
	 		*n0vechi = (nm0_rec_enable_vector[0] << 16) | nm0_rec_enable_vector[1];
		}
		else if (nm_addr == NM_REC_ENABLE3_REG)
20001abe:	68bb      	ldr	r3, [r7, #8]
20001ac0:	2b07      	cmp	r3, #7
20001ac2:	f040 8098 	bne.w	20001bf6 <update_ADC_vectors+0x20a>
		{
			// channels 48-63
			nm0_rec_enable_vector[0] = data;
20001ac6:	687b      	ldr	r3, [r7, #4]
20001ac8:	b29a      	uxth	r2, r3
20001aca:	f643 530c 	movw	r3, #15628	; 0x3d0c
20001ace:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001ad2:	801a      	strh	r2, [r3, #0]
	 		*n0vechi = (nm0_rec_enable_vector[0] << 16) | nm0_rec_enable_vector[1];
20001ad4:	f643 43e8 	movw	r3, #15592	; 0x3ce8
20001ad8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001adc:	681a      	ldr	r2, [r3, #0]
20001ade:	f643 530c 	movw	r3, #15628	; 0x3d0c
20001ae2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001ae6:	881b      	ldrh	r3, [r3, #0]
20001ae8:	ea4f 4103 	mov.w	r1, r3, lsl #16
20001aec:	f643 530c 	movw	r3, #15628	; 0x3d0c
20001af0:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001af4:	885b      	ldrh	r3, [r3, #2]
20001af6:	ea41 0303 	orr.w	r3, r1, r3
20001afa:	6013      	str	r3, [r2, #0]
		}
		break;
20001afc:	e07c      	b.n	20001bf8 <update_ADC_vectors+0x20c>

	case 1:
		if (nm_addr == NM_REC_ENABLE0_REG)
20001afe:	68bb      	ldr	r3, [r7, #8]
20001b00:	2b04      	cmp	r3, #4
20001b02:	d11b      	bne.n	20001b3c <update_ADC_vectors+0x150>
		{
			// channels 0-15
			nm1_rec_enable_vector[3] = data;
20001b04:	687b      	ldr	r3, [r7, #4]
20001b06:	b29a      	uxth	r2, r3
20001b08:	f643 5314 	movw	r3, #15636	; 0x3d14
20001b0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b10:	80da      	strh	r2, [r3, #6]
	 		*n1veclo = (nm1_rec_enable_vector[2] << 16) | nm1_rec_enable_vector[3];
20001b12:	f643 43f4 	movw	r3, #15604	; 0x3cf4
20001b16:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b1a:	681a      	ldr	r2, [r3, #0]
20001b1c:	f643 5314 	movw	r3, #15636	; 0x3d14
20001b20:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b24:	889b      	ldrh	r3, [r3, #4]
20001b26:	ea4f 4103 	mov.w	r1, r3, lsl #16
20001b2a:	f643 5314 	movw	r3, #15636	; 0x3d14
20001b2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b32:	88db      	ldrh	r3, [r3, #6]
20001b34:	ea41 0303 	orr.w	r3, r1, r3
20001b38:	6013      	str	r3, [r2, #0]
20001b3a:	e05d      	b.n	20001bf8 <update_ADC_vectors+0x20c>
		}
		else if (nm_addr == NM_REC_ENABLE1_REG)
20001b3c:	68bb      	ldr	r3, [r7, #8]
20001b3e:	2b05      	cmp	r3, #5
20001b40:	d11b      	bne.n	20001b7a <update_ADC_vectors+0x18e>
		{
			// channels 16-31
			nm1_rec_enable_vector[2] = data;
20001b42:	687b      	ldr	r3, [r7, #4]
20001b44:	b29a      	uxth	r2, r3
20001b46:	f643 5314 	movw	r3, #15636	; 0x3d14
20001b4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b4e:	809a      	strh	r2, [r3, #4]
	 		*n1veclo = (nm1_rec_enable_vector[2] << 16) | nm1_rec_enable_vector[3];
20001b50:	f643 43f4 	movw	r3, #15604	; 0x3cf4
20001b54:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b58:	681a      	ldr	r2, [r3, #0]
20001b5a:	f643 5314 	movw	r3, #15636	; 0x3d14
20001b5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b62:	889b      	ldrh	r3, [r3, #4]
20001b64:	ea4f 4103 	mov.w	r1, r3, lsl #16
20001b68:	f643 5314 	movw	r3, #15636	; 0x3d14
20001b6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b70:	88db      	ldrh	r3, [r3, #6]
20001b72:	ea41 0303 	orr.w	r3, r1, r3
20001b76:	6013      	str	r3, [r2, #0]
20001b78:	e03e      	b.n	20001bf8 <update_ADC_vectors+0x20c>
		}
		else if (nm_addr == NM_REC_ENABLE2_REG)
20001b7a:	68bb      	ldr	r3, [r7, #8]
20001b7c:	2b06      	cmp	r3, #6
20001b7e:	d11b      	bne.n	20001bb8 <update_ADC_vectors+0x1cc>
		{
			// channels 32-47
			nm1_rec_enable_vector[1] = data;
20001b80:	687b      	ldr	r3, [r7, #4]
20001b82:	b29a      	uxth	r2, r3
20001b84:	f643 5314 	movw	r3, #15636	; 0x3d14
20001b88:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b8c:	805a      	strh	r2, [r3, #2]
	 		*n1vechi = (nm1_rec_enable_vector[0] << 16) | nm1_rec_enable_vector[1];
20001b8e:	f643 43f0 	movw	r3, #15600	; 0x3cf0
20001b92:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001b96:	681a      	ldr	r2, [r3, #0]
20001b98:	f643 5314 	movw	r3, #15636	; 0x3d14
20001b9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001ba0:	881b      	ldrh	r3, [r3, #0]
20001ba2:	ea4f 4103 	mov.w	r1, r3, lsl #16
20001ba6:	f643 5314 	movw	r3, #15636	; 0x3d14
20001baa:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001bae:	885b      	ldrh	r3, [r3, #2]
20001bb0:	ea41 0303 	orr.w	r3, r1, r3
20001bb4:	6013      	str	r3, [r2, #0]
20001bb6:	e01f      	b.n	20001bf8 <update_ADC_vectors+0x20c>
		}
		else if (nm_addr == NM_REC_ENABLE3_REG)
20001bb8:	68bb      	ldr	r3, [r7, #8]
20001bba:	2b07      	cmp	r3, #7
20001bbc:	d11c      	bne.n	20001bf8 <update_ADC_vectors+0x20c>
		{
			// channels 48-63
			nm1_rec_enable_vector[0] = data;
20001bbe:	687b      	ldr	r3, [r7, #4]
20001bc0:	b29a      	uxth	r2, r3
20001bc2:	f643 5314 	movw	r3, #15636	; 0x3d14
20001bc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001bca:	801a      	strh	r2, [r3, #0]
	 		*n1vechi = (nm1_rec_enable_vector[0] << 16) | nm1_rec_enable_vector[1];
20001bcc:	f643 43f0 	movw	r3, #15600	; 0x3cf0
20001bd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001bd4:	681a      	ldr	r2, [r3, #0]
20001bd6:	f643 5314 	movw	r3, #15636	; 0x3d14
20001bda:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001bde:	881b      	ldrh	r3, [r3, #0]
20001be0:	ea4f 4103 	mov.w	r1, r3, lsl #16
20001be4:	f643 5314 	movw	r3, #15636	; 0x3d14
20001be8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001bec:	885b      	ldrh	r3, [r3, #2]
20001bee:	ea41 0303 	orr.w	r3, r1, r3
20001bf2:	6013      	str	r3, [r2, #0]
20001bf4:	e000      	b.n	20001bf8 <update_ADC_vectors+0x20c>
		{
			// channels 48-63
			nm0_rec_enable_vector[0] = data;
	 		*n0vechi = (nm0_rec_enable_vector[0] << 16) | nm0_rec_enable_vector[1];
		}
		break;
20001bf6:	bf00      	nop
		break;

	default:
		break;
	}
}
20001bf8:	f107 0714 	add.w	r7, r7, #20
20001bfc:	46bd      	mov	sp, r7
20001bfe:	bc80      	pop	{r7}
20001c00:	4770      	bx	lr
20001c02:	bf00      	nop

20001c04 <set_FFT_channel>:

//
// Set mode word FFT channel field for nmid
//
int set_FFT_channel(int nmid, int chan)
{
20001c04:	b480      	push	{r7}
20001c06:	b083      	sub	sp, #12
20001c08:	af00      	add	r7, sp, #0
20001c0a:	6078      	str	r0, [r7, #4]
20001c0c:	6039      	str	r1, [r7, #0]

	if (i == 64) {
		return -1;
	}
*/
	return 0;
20001c0e:	f04f 0300 	mov.w	r3, #0
}
20001c12:	4618      	mov	r0, r3
20001c14:	f107 070c 	add.w	r7, r7, #12
20001c18:	46bd      	mov	sp, r7
20001c1a:	bc80      	pop	{r7}
20001c1c:	4770      	bx	lr
20001c1e:	bf00      	nop

20001c20 <postNMregRead>:
//
// Post a request for contents of NM[nmid] register at regaddr
// Value will be collected after ACK ready interrupt
//
void postNMregRead(int nmid, int regaddr)
{
20001c20:	b480      	push	{r7}
20001c22:	b083      	sub	sp, #12
20001c24:	af00      	add	r7, sp, #0
20001c26:	6078      	str	r0, [r7, #4]
20001c28:	6039      	str	r1, [r7, #0]
	if (nmid == 0) {
20001c2a:	687b      	ldr	r3, [r7, #4]
20001c2c:	2b00      	cmp	r3, #0
20001c2e:	d119      	bne.n	20001c64 <postNMregRead+0x44>
		*n0d1 = OP_REG_READ;
20001c30:	f643 43d0 	movw	r3, #15568	; 0x3cd0
20001c34:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001c38:	681b      	ldr	r3, [r3, #0]
20001c3a:	f04f 0200 	mov.w	r2, #0
20001c3e:	601a      	str	r2, [r3, #0]
		*n0d2 = regaddr << 16;
20001c40:	f643 43d4 	movw	r3, #15572	; 0x3cd4
20001c44:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001c48:	681b      	ldr	r3, [r3, #0]
20001c4a:	683a      	ldr	r2, [r7, #0]
20001c4c:	ea4f 4202 	mov.w	r2, r2, lsl #16
20001c50:	601a      	str	r2, [r3, #0]
		*command = NM0_TX_START_BIT;
20001c52:	f643 43e0 	movw	r3, #15584	; 0x3ce0
20001c56:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001c5a:	681b      	ldr	r3, [r3, #0]
20001c5c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
20001c60:	601a      	str	r2, [r3, #0]
20001c62:	e01b      	b.n	20001c9c <postNMregRead+0x7c>
	}
	else if (nmid == 1) {
20001c64:	687b      	ldr	r3, [r7, #4]
20001c66:	2b01      	cmp	r3, #1
20001c68:	d118      	bne.n	20001c9c <postNMregRead+0x7c>
		*n1d1 = OP_REG_READ;
20001c6a:	f643 43d8 	movw	r3, #15576	; 0x3cd8
20001c6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001c72:	681b      	ldr	r3, [r3, #0]
20001c74:	f04f 0200 	mov.w	r2, #0
20001c78:	601a      	str	r2, [r3, #0]
		*n1d2 = regaddr << 16;
20001c7a:	f643 43dc 	movw	r3, #15580	; 0x3cdc
20001c7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001c82:	681b      	ldr	r3, [r3, #0]
20001c84:	683a      	ldr	r2, [r7, #0]
20001c86:	ea4f 4202 	mov.w	r2, r2, lsl #16
20001c8a:	601a      	str	r2, [r3, #0]
		*command = NM1_TX_START_BIT;
20001c8c:	f643 43e0 	movw	r3, #15584	; 0x3ce0
20001c90:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001c94:	681b      	ldr	r3, [r3, #0]
20001c96:	f44f 5200 	mov.w	r2, #8192	; 0x2000
20001c9a:	601a      	str	r2, [r3, #0]
	}
}
20001c9c:	f107 070c 	add.w	r7, r7, #12
20001ca0:	46bd      	mov	sp, r7
20001ca2:	bc80      	pop	{r7}
20001ca4:	4770      	bx	lr
20001ca6:	bf00      	nop

20001ca8 <writeNMreg>:

//
// Write regdata to NM[nmid] register at regaddr
//
void writeNMreg(int nmid, int regaddr, int regdata)
{
20001ca8:	b580      	push	{r7, lr}
20001caa:	b086      	sub	sp, #24
20001cac:	af00      	add	r7, sp, #0
20001cae:	60f8      	str	r0, [r7, #12]
20001cb0:	60b9      	str	r1, [r7, #8]
20001cb2:	607a      	str	r2, [r7, #4]
	int i;

	update_ADC_vectors(nmid, regaddr, regdata);
20001cb4:	68f8      	ldr	r0, [r7, #12]
20001cb6:	68b9      	ldr	r1, [r7, #8]
20001cb8:	687a      	ldr	r2, [r7, #4]
20001cba:	f7ff fe97 	bl	200019ec <update_ADC_vectors>

	switch (nmid){
20001cbe:	68fb      	ldr	r3, [r7, #12]
20001cc0:	2b00      	cmp	r3, #0
20001cc2:	d002      	beq.n	20001cca <writeNMreg+0x22>
20001cc4:	2b01      	cmp	r3, #1
20001cc6:	d032      	beq.n	20001d2e <writeNMreg+0x86>
20001cc8:	e062      	b.n	20001d90 <writeNMreg+0xe8>
	case 0:
		*n0d1 = OP_REG_WRITE;
20001cca:	f643 43d0 	movw	r3, #15568	; 0x3cd0
20001cce:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001cd2:	681b      	ldr	r3, [r3, #0]
20001cd4:	f04f 0201 	mov.w	r2, #1
20001cd8:	601a      	str	r2, [r3, #0]
		*n0d2 = (regaddr << 16) | regdata;
20001cda:	f643 43d4 	movw	r3, #15572	; 0x3cd4
20001cde:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001ce2:	681b      	ldr	r3, [r3, #0]
20001ce4:	68ba      	ldr	r2, [r7, #8]
20001ce6:	ea4f 4102 	mov.w	r1, r2, lsl #16
20001cea:	687a      	ldr	r2, [r7, #4]
20001cec:	ea41 0202 	orr.w	r2, r1, r2
20001cf0:	601a      	str	r2, [r3, #0]
		*command = NM0_TX_START_BIT;			// start transmit
20001cf2:	f643 43e0 	movw	r3, #15584	; 0x3ce0
20001cf6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001cfa:	681b      	ldr	r3, [r3, #0]
20001cfc:	f44f 5280 	mov.w	r2, #4096	; 0x1000
20001d00:	601a      	str	r2, [r3, #0]

		for (i = 0; i < 10; i++);				// delay a little bit to allow the busy flag to be set
20001d02:	f04f 0300 	mov.w	r3, #0
20001d06:	617b      	str	r3, [r7, #20]
20001d08:	e003      	b.n	20001d12 <writeNMreg+0x6a>
20001d0a:	697b      	ldr	r3, [r7, #20]
20001d0c:	f103 0301 	add.w	r3, r3, #1
20001d10:	617b      	str	r3, [r7, #20]
20001d12:	697b      	ldr	r3, [r7, #20]
20001d14:	2b09      	cmp	r3, #9
20001d16:	ddf8      	ble.n	20001d0a <writeNMreg+0x62>

		while((*status) & NM0_TX_BUSY_BIT);
20001d18:	f643 43f8 	movw	r3, #15608	; 0x3cf8
20001d1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001d20:	681b      	ldr	r3, [r3, #0]
20001d22:	681b      	ldr	r3, [r3, #0]
20001d24:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
20001d28:	2b00      	cmp	r3, #0
20001d2a:	d1f5      	bne.n	20001d18 <writeNMreg+0x70>

		break;
20001d2c:	e030      	b.n	20001d90 <writeNMreg+0xe8>

	case 1:
		*n1d1 = OP_REG_WRITE;
20001d2e:	f643 43d8 	movw	r3, #15576	; 0x3cd8
20001d32:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001d36:	681b      	ldr	r3, [r3, #0]
20001d38:	f04f 0201 	mov.w	r2, #1
20001d3c:	601a      	str	r2, [r3, #0]
		*n1d2 = (regaddr << 16) | regdata;
20001d3e:	f643 43dc 	movw	r3, #15580	; 0x3cdc
20001d42:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001d46:	681b      	ldr	r3, [r3, #0]
20001d48:	68ba      	ldr	r2, [r7, #8]
20001d4a:	ea4f 4102 	mov.w	r1, r2, lsl #16
20001d4e:	687a      	ldr	r2, [r7, #4]
20001d50:	ea41 0202 	orr.w	r2, r1, r2
20001d54:	601a      	str	r2, [r3, #0]
		*command = NM1_TX_START_BIT;			// start transmit
20001d56:	f643 43e0 	movw	r3, #15584	; 0x3ce0
20001d5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001d5e:	681b      	ldr	r3, [r3, #0]
20001d60:	f44f 5200 	mov.w	r2, #8192	; 0x2000
20001d64:	601a      	str	r2, [r3, #0]

		for (i = 0; i < 10; i++);				// delay a little bit to allow the busy flag to be set
20001d66:	f04f 0300 	mov.w	r3, #0
20001d6a:	617b      	str	r3, [r7, #20]
20001d6c:	e003      	b.n	20001d76 <writeNMreg+0xce>
20001d6e:	697b      	ldr	r3, [r7, #20]
20001d70:	f103 0301 	add.w	r3, r3, #1
20001d74:	617b      	str	r3, [r7, #20]
20001d76:	697b      	ldr	r3, [r7, #20]
20001d78:	2b09      	cmp	r3, #9
20001d7a:	ddf8      	ble.n	20001d6e <writeNMreg+0xc6>

		while((*status) & NM1_TX_BUSY_BIT);
20001d7c:	f643 43f8 	movw	r3, #15608	; 0x3cf8
20001d80:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001d84:	681b      	ldr	r3, [r3, #0]
20001d86:	681b      	ldr	r3, [r3, #0]
20001d88:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
20001d8c:	2b00      	cmp	r3, #0
20001d8e:	d1f5      	bne.n	20001d7c <writeNMreg+0xd4>
		break;

	default:
		break;
	}
}
20001d90:	f107 0718 	add.w	r7, r7, #24
20001d94:	46bd      	mov	sp, r7
20001d96:	bd80      	pop	{r7, pc}

20001d98 <sendNMcmd>:

//
// Send cmd to NM[nmid]
//
void sendNMcmd(int nmid, int cmd)
{
20001d98:	b480      	push	{r7}
20001d9a:	b085      	sub	sp, #20
20001d9c:	af00      	add	r7, sp, #0
20001d9e:	6078      	str	r0, [r7, #4]
20001da0:	6039      	str	r1, [r7, #0]
    int i;

    switch (nmid) {
20001da2:	687b      	ldr	r3, [r7, #4]
20001da4:	2b00      	cmp	r3, #0
20001da6:	d002      	beq.n	20001dae <sendNMcmd+0x16>
20001da8:	2b01      	cmp	r3, #1
20001daa:	d025      	beq.n	20001df8 <sendNMcmd+0x60>
20001dac:	e048      	b.n	20001e40 <sendNMcmd+0xa8>
    case 0:
        *n0d2 = cmd;
20001dae:	f643 43d4 	movw	r3, #15572	; 0x3cd4
20001db2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001db6:	681b      	ldr	r3, [r3, #0]
20001db8:	683a      	ldr	r2, [r7, #0]
20001dba:	601a      	str	r2, [r3, #0]
        *command = NM0_TX_START_BIT | NM0_TX_MODE_BIT;		// set to command send mode and start transmit
20001dbc:	f643 43e0 	movw	r3, #15584	; 0x3ce0
20001dc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001dc4:	681b      	ldr	r3, [r3, #0]
20001dc6:	f241 0210 	movw	r2, #4112	; 0x1010
20001dca:	601a      	str	r2, [r3, #0]

        for (i = 0; i < 10; i++);							// delay a little bit to allow the busy flag to be set
20001dcc:	f04f 0300 	mov.w	r3, #0
20001dd0:	60fb      	str	r3, [r7, #12]
20001dd2:	e003      	b.n	20001ddc <sendNMcmd+0x44>
20001dd4:	68fb      	ldr	r3, [r7, #12]
20001dd6:	f103 0301 	add.w	r3, r3, #1
20001dda:	60fb      	str	r3, [r7, #12]
20001ddc:	68fb      	ldr	r3, [r7, #12]
20001dde:	2b09      	cmp	r3, #9
20001de0:	ddf8      	ble.n	20001dd4 <sendNMcmd+0x3c>

        while((*status) & NM0_TX_BUSY_BIT);					// wait for Tx to complete
20001de2:	f643 43f8 	movw	r3, #15608	; 0x3cf8
20001de6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001dea:	681b      	ldr	r3, [r3, #0]
20001dec:	681b      	ldr	r3, [r3, #0]
20001dee:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
20001df2:	2b00      	cmp	r3, #0
20001df4:	d1f5      	bne.n	20001de2 <sendNMcmd+0x4a>

        break;
20001df6:	e023      	b.n	20001e40 <sendNMcmd+0xa8>

    case 1:
        *n1d2 = cmd;
20001df8:	f643 43dc 	movw	r3, #15580	; 0x3cdc
20001dfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001e00:	681b      	ldr	r3, [r3, #0]
20001e02:	683a      	ldr	r2, [r7, #0]
20001e04:	601a      	str	r2, [r3, #0]
        *command = NM1_TX_START_BIT | NM1_TX_MODE_BIT;		// set to command send mode and start transmit
20001e06:	f643 43e0 	movw	r3, #15584	; 0x3ce0
20001e0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001e0e:	681b      	ldr	r3, [r3, #0]
20001e10:	f242 0220 	movw	r2, #8224	; 0x2020
20001e14:	601a      	str	r2, [r3, #0]

        for (i = 0; i < 10; i++);							// delay a little bit to allow the busy flag to be set
20001e16:	f04f 0300 	mov.w	r3, #0
20001e1a:	60fb      	str	r3, [r7, #12]
20001e1c:	e003      	b.n	20001e26 <sendNMcmd+0x8e>
20001e1e:	68fb      	ldr	r3, [r7, #12]
20001e20:	f103 0301 	add.w	r3, r3, #1
20001e24:	60fb      	str	r3, [r7, #12]
20001e26:	68fb      	ldr	r3, [r7, #12]
20001e28:	2b09      	cmp	r3, #9
20001e2a:	ddf8      	ble.n	20001e1e <sendNMcmd+0x86>

        while((*status) & NM1_TX_BUSY_BIT);					// wait for Tx to complete
20001e2c:	f643 43f8 	movw	r3, #15608	; 0x3cf8
20001e30:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001e34:	681b      	ldr	r3, [r3, #0]
20001e36:	681b      	ldr	r3, [r3, #0]
20001e38:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
20001e3c:	2b00      	cmp	r3, #0
20001e3e:	d1f5      	bne.n	20001e2c <sendNMcmd+0x94>
        break;

    default:
        break;
    }
}
20001e40:	f107 0714 	add.w	r7, r7, #20
20001e44:	46bd      	mov	sp, r7
20001e46:	bc80      	pop	{r7}
20001e48:	4770      	bx	lr
20001e4a:	bf00      	nop

20001e4c <delay_us>:
		break;
	}
}

void delay_us(int us)
{
20001e4c:	b480      	push	{r7}
20001e4e:	b085      	sub	sp, #20
20001e50:	af00      	add	r7, sp, #0
20001e52:	6078      	str	r0, [r7, #4]
	int i;
	for (i = 0;  i < (us * 3); i++);
20001e54:	f04f 0300 	mov.w	r3, #0
20001e58:	60fb      	str	r3, [r7, #12]
20001e5a:	e003      	b.n	20001e64 <delay_us+0x18>
20001e5c:	68fb      	ldr	r3, [r7, #12]
20001e5e:	f103 0301 	add.w	r3, r3, #1
20001e62:	60fb      	str	r3, [r7, #12]
20001e64:	687a      	ldr	r2, [r7, #4]
20001e66:	4613      	mov	r3, r2
20001e68:	ea4f 0343 	mov.w	r3, r3, lsl #1
20001e6c:	441a      	add	r2, r3
20001e6e:	68fb      	ldr	r3, [r7, #12]
20001e70:	429a      	cmp	r2, r3
20001e72:	dcf3      	bgt.n	20001e5c <delay_us+0x10>
}
20001e74:	f107 0714 	add.w	r7, r7, #20
20001e78:	46bd      	mov	sp, r7
20001e7a:	bc80      	pop	{r7}
20001e7c:	4770      	bx	lr
20001e7e:	bf00      	nop

20001e80 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
20001e80:	b480      	push	{r7}
20001e82:	b083      	sub	sp, #12
20001e84:	af00      	add	r7, sp, #0
20001e86:	4603      	mov	r3, r0
20001e88:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
20001e8a:	f24e 1300 	movw	r3, #57600	; 0xe100
20001e8e:	f2ce 0300 	movt	r3, #57344	; 0xe000
20001e92:	f997 2007 	ldrsb.w	r2, [r7, #7]
20001e96:	ea4f 1252 	mov.w	r2, r2, lsr #5
20001e9a:	79f9      	ldrb	r1, [r7, #7]
20001e9c:	f001 011f 	and.w	r1, r1, #31
20001ea0:	f04f 0001 	mov.w	r0, #1
20001ea4:	fa00 f101 	lsl.w	r1, r0, r1
20001ea8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20001eac:	f107 070c 	add.w	r7, r7, #12
20001eb0:	46bd      	mov	sp, r7
20001eb2:	bc80      	pop	{r7}
20001eb4:	4770      	bx	lr
20001eb6:	bf00      	nop

20001eb8 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
20001eb8:	b480      	push	{r7}
20001eba:	b083      	sub	sp, #12
20001ebc:	af00      	add	r7, sp, #0
20001ebe:	4603      	mov	r3, r0
20001ec0:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
20001ec2:	f24e 1300 	movw	r3, #57600	; 0xe100
20001ec6:	f2ce 0300 	movt	r3, #57344	; 0xe000
20001eca:	f997 2007 	ldrsb.w	r2, [r7, #7]
20001ece:	ea4f 1252 	mov.w	r2, r2, lsr #5
20001ed2:	79f9      	ldrb	r1, [r7, #7]
20001ed4:	f001 011f 	and.w	r1, r1, #31
20001ed8:	f04f 0001 	mov.w	r0, #1
20001edc:	fa00 f101 	lsl.w	r1, r0, r1
20001ee0:	f102 0220 	add.w	r2, r2, #32
20001ee4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20001ee8:	f107 070c 	add.w	r7, r7, #12
20001eec:	46bd      	mov	sp, r7
20001eee:	bc80      	pop	{r7}
20001ef0:	4770      	bx	lr
20001ef2:	bf00      	nop

20001ef4 <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
20001ef4:	b480      	push	{r7}
20001ef6:	b083      	sub	sp, #12
20001ef8:	af00      	add	r7, sp, #0
20001efa:	4603      	mov	r3, r0
20001efc:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
20001efe:	f24e 1300 	movw	r3, #57600	; 0xe100
20001f02:	f2ce 0300 	movt	r3, #57344	; 0xe000
20001f06:	f997 2007 	ldrsb.w	r2, [r7, #7]
20001f0a:	ea4f 1252 	mov.w	r2, r2, lsr #5
20001f0e:	79f9      	ldrb	r1, [r7, #7]
20001f10:	f001 011f 	and.w	r1, r1, #31
20001f14:	f04f 0001 	mov.w	r0, #1
20001f18:	fa00 f101 	lsl.w	r1, r0, r1
20001f1c:	f102 0260 	add.w	r2, r2, #96	; 0x60
20001f20:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20001f24:	f107 070c 	add.w	r7, r7, #12
20001f28:	46bd      	mov	sp, r7
20001f2a:	bc80      	pop	{r7}
20001f2c:	4770      	bx	lr
20001f2e:	bf00      	nop

20001f30 <MSS_SPI_init>:
 */
void MSS_SPI_init
(
    mss_spi_instance_t * this_spi
)
{
20001f30:	b580      	push	{r7, lr}
20001f32:	b084      	sub	sp, #16
20001f34:	af00      	add	r7, sp, #0
20001f36:	6078      	str	r0, [r7, #4]
    uint16_t slave;
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
20001f38:	687a      	ldr	r2, [r7, #4]
20001f3a:	f244 0370 	movw	r3, #16496	; 0x4070
20001f3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001f42:	429a      	cmp	r2, r3
20001f44:	d007      	beq.n	20001f56 <MSS_SPI_init+0x26>
20001f46:	687a      	ldr	r2, [r7, #4]
20001f48:	f643 73ec 	movw	r3, #16364	; 0x3fec
20001f4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001f50:	429a      	cmp	r2, r3
20001f52:	d000      	beq.n	20001f56 <MSS_SPI_init+0x26>
20001f54:	be00      	bkpt	0x0000
     * Initialize SPI driver instance data. Relies on the majority
     * of data requiring 0 for initial state so we just need to fill
     * with 0s and finish off with a small number of non zero values.
     */
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
20001f56:	687b      	ldr	r3, [r7, #4]
20001f58:	791b      	ldrb	r3, [r3, #4]
20001f5a:	b25b      	sxtb	r3, r3
20001f5c:	4618      	mov	r0, r3
20001f5e:	f7ff ffab 	bl	20001eb8 <NVIC_DisableIRQ>

    memset(this_spi, 0, sizeof(mss_spi_instance_t));
20001f62:	6878      	ldr	r0, [r7, #4]
20001f64:	f04f 0100 	mov.w	r1, #0
20001f68:	f04f 0284 	mov.w	r2, #132	; 0x84
20001f6c:	f001 fd96 	bl	20003a9c <memset>
    
    this_spi->cmd_done = 1u;
20001f70:	687b      	ldr	r3, [r7, #4]
20001f72:	f04f 0201 	mov.w	r2, #1
20001f76:	625a      	str	r2, [r3, #36]	; 0x24

    for(slave = 0u; slave < (uint16_t)MSS_SPI_MAX_NB_OF_SLAVES; ++slave)
20001f78:	f04f 0300 	mov.w	r3, #0
20001f7c:	81fb      	strh	r3, [r7, #14]
20001f7e:	e00d      	b.n	20001f9c <MSS_SPI_init+0x6c>
    {
        this_spi->slaves_cfg[slave].ctrl_reg = NOT_CONFIGURED;
20001f80:	89fb      	ldrh	r3, [r7, #14]
20001f82:	687a      	ldr	r2, [r7, #4]
20001f84:	f103 0306 	add.w	r3, r3, #6
20001f88:	ea4f 03c3 	mov.w	r3, r3, lsl #3
20001f8c:	4413      	add	r3, r2
20001f8e:	f04f 32ff 	mov.w	r2, #4294967295
20001f92:	605a      	str	r2, [r3, #4]

    memset(this_spi, 0, sizeof(mss_spi_instance_t));
    
    this_spi->cmd_done = 1u;

    for(slave = 0u; slave < (uint16_t)MSS_SPI_MAX_NB_OF_SLAVES; ++slave)
20001f94:	89fb      	ldrh	r3, [r7, #14]
20001f96:	f103 0301 	add.w	r3, r3, #1
20001f9a:	81fb      	strh	r3, [r7, #14]
20001f9c:	89fb      	ldrh	r3, [r7, #14]
20001f9e:	2b07      	cmp	r3, #7
20001fa0:	d9ee      	bls.n	20001f80 <MSS_SPI_init+0x50>
    {
        this_spi->slaves_cfg[slave].ctrl_reg = NOT_CONFIGURED;
    }

    if(this_spi == &g_mss_spi0)
20001fa2:	687a      	ldr	r2, [r7, #4]
20001fa4:	f244 0370 	movw	r3, #16496	; 0x4070
20001fa8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001fac:	429a      	cmp	r2, r3
20001fae:	d126      	bne.n	20001ffe <MSS_SPI_init+0xce>
    {
        this_spi->hw_reg = ((SPI_TypeDef *) SPI0_BASE);
20001fb0:	687a      	ldr	r2, [r7, #4]
20001fb2:	f241 0300 	movw	r3, #4096	; 0x1000
20001fb6:	f2c4 0300 	movt	r3, #16384	; 0x4000
20001fba:	6013      	str	r3, [r2, #0]
        this_spi->irqn = SPI0_IRQn;
20001fbc:	687b      	ldr	r3, [r7, #4]
20001fbe:	f04f 0202 	mov.w	r2, #2
20001fc2:	711a      	strb	r2, [r3, #4]

        /* reset SPI0 */
        SYSREG->SOFT_RST_CR |= SYSREG_SPI0_SOFTRESET_MASK;
20001fc4:	f248 0300 	movw	r3, #32768	; 0x8000
20001fc8:	f2c4 0303 	movt	r3, #16387	; 0x4003
20001fcc:	f248 0200 	movw	r2, #32768	; 0x8000
20001fd0:	f2c4 0203 	movt	r2, #16387	; 0x4003
20001fd4:	6c92      	ldr	r2, [r2, #72]	; 0x48
20001fd6:	f442 7200 	orr.w	r2, r2, #512	; 0x200
20001fda:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended SPI0 interrupt */
        NVIC_ClearPendingIRQ(SPI0_IRQn);
20001fdc:	f04f 0002 	mov.w	r0, #2
20001fe0:	f7ff ff88 	bl	20001ef4 <NVIC_ClearPendingIRQ>
        /* Take SPI0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_SPI0_SOFTRESET_MASK;
20001fe4:	f248 0300 	movw	r3, #32768	; 0x8000
20001fe8:	f2c4 0303 	movt	r3, #16387	; 0x4003
20001fec:	f248 0200 	movw	r2, #32768	; 0x8000
20001ff0:	f2c4 0203 	movt	r2, #16387	; 0x4003
20001ff4:	6c92      	ldr	r2, [r2, #72]	; 0x48
20001ff6:	f422 7200 	bic.w	r2, r2, #512	; 0x200
20001ffa:	649a      	str	r2, [r3, #72]	; 0x48
20001ffc:	e025      	b.n	2000204a <MSS_SPI_init+0x11a>
    }
    else
    {
        this_spi->hw_reg = ((SPI_TypeDef *) SPI1_BASE);
20001ffe:	687a      	ldr	r2, [r7, #4]
20002000:	f241 0300 	movw	r3, #4096	; 0x1000
20002004:	f2c4 0301 	movt	r3, #16385	; 0x4001
20002008:	6013      	str	r3, [r2, #0]
        this_spi->irqn = SPI1_IRQn;
2000200a:	687b      	ldr	r3, [r7, #4]
2000200c:	f04f 0203 	mov.w	r2, #3
20002010:	711a      	strb	r2, [r3, #4]
        
        /* reset SPI1 */
        SYSREG->SOFT_RST_CR |= SYSREG_SPI1_SOFTRESET_MASK;
20002012:	f248 0300 	movw	r3, #32768	; 0x8000
20002016:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000201a:	f248 0200 	movw	r2, #32768	; 0x8000
2000201e:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002022:	6c92      	ldr	r2, [r2, #72]	; 0x48
20002024:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
20002028:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended SPI1 interrupt */
        NVIC_ClearPendingIRQ(SPI1_IRQn);
2000202a:	f04f 0003 	mov.w	r0, #3
2000202e:	f7ff ff61 	bl	20001ef4 <NVIC_ClearPendingIRQ>
        /* Take SPI1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_SPI1_SOFTRESET_MASK;
20002032:	f248 0300 	movw	r3, #32768	; 0x8000
20002036:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000203a:	f248 0200 	movw	r2, #32768	; 0x8000
2000203e:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002042:	6c92      	ldr	r2, [r2, #72]	; 0x48
20002044:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
20002048:	649a      	str	r2, [r3, #72]	; 0x48
    }
    
    /* De-assert reset bit. */
    this_spi->hw_reg->CONTROL &= ~CTRL_REG_RESET_MASK;
2000204a:	687b      	ldr	r3, [r7, #4]
2000204c:	681b      	ldr	r3, [r3, #0]
2000204e:	687a      	ldr	r2, [r7, #4]
20002050:	6812      	ldr	r2, [r2, #0]
20002052:	6812      	ldr	r2, [r2, #0]
20002054:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
20002058:	601a      	str	r2, [r3, #0]
}
2000205a:	f107 0710 	add.w	r7, r7, #16
2000205e:	46bd      	mov	sp, r7
20002060:	bd80      	pop	{r7, pc}
20002062:	bf00      	nop

20002064 <recover_from_rx_overflow>:
 */
static void recover_from_rx_overflow
(
    mss_spi_instance_t * this_spi
)
{
20002064:	b580      	push	{r7, lr}
20002066:	b08a      	sub	sp, #40	; 0x28
20002068:	af00      	add	r7, sp, #0
2000206a:	6078      	str	r0, [r7, #4]
    uint32_t slave_select;
    
    /*
     * Read current SPI hardware block configuration.
     */
    control_reg = this_spi->hw_reg->CONTROL;
2000206c:	687b      	ldr	r3, [r7, #4]
2000206e:	681b      	ldr	r3, [r3, #0]
20002070:	681b      	ldr	r3, [r3, #0]
20002072:	60fb      	str	r3, [r7, #12]
    clk_gen = this_spi->hw_reg->CLK_GEN;
20002074:	687b      	ldr	r3, [r7, #4]
20002076:	681b      	ldr	r3, [r3, #0]
20002078:	699b      	ldr	r3, [r3, #24]
2000207a:	613b      	str	r3, [r7, #16]
    frame_size = this_spi->hw_reg->TXRXDF_SIZE;
2000207c:	687b      	ldr	r3, [r7, #4]
2000207e:	681b      	ldr	r3, [r3, #0]
20002080:	685b      	ldr	r3, [r3, #4]
20002082:	617b      	str	r3, [r7, #20]
    control2 = this_spi->hw_reg->CONTROL2;
20002084:	687b      	ldr	r3, [r7, #4]
20002086:	681b      	ldr	r3, [r3, #0]
20002088:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2000208a:	61bb      	str	r3, [r7, #24]
    packet_size = this_spi->hw_reg->PKTSIZE;
2000208c:	687b      	ldr	r3, [r7, #4]
2000208e:	681b      	ldr	r3, [r3, #0]
20002090:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20002092:	61fb      	str	r3, [r7, #28]
    cmd_size = this_spi->hw_reg->CMDSIZE;
20002094:	687b      	ldr	r3, [r7, #4]
20002096:	681b      	ldr	r3, [r3, #0]
20002098:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2000209a:	623b      	str	r3, [r7, #32]
    slave_select = this_spi->hw_reg->SLAVE_SELECT;
2000209c:	687b      	ldr	r3, [r7, #4]
2000209e:	681b      	ldr	r3, [r3, #0]
200020a0:	69db      	ldr	r3, [r3, #28]
200020a2:	627b      	str	r3, [r7, #36]	; 0x24
     
    /*
     * Reset the SPI hardware block.
     */
    if(this_spi == &g_mss_spi0)
200020a4:	687a      	ldr	r2, [r7, #4]
200020a6:	f244 0370 	movw	r3, #16496	; 0x4070
200020aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
200020ae:	429a      	cmp	r2, r3
200020b0:	d12e      	bne.n	20002110 <recover_from_rx_overflow+0xac>
    {
        this_spi->hw_reg = ((SPI_TypeDef *) SPI0_BASE);
200020b2:	687a      	ldr	r2, [r7, #4]
200020b4:	f241 0300 	movw	r3, #4096	; 0x1000
200020b8:	f2c4 0300 	movt	r3, #16384	; 0x4000
200020bc:	6013      	str	r3, [r2, #0]
        this_spi->irqn = SPI0_IRQn;
200020be:	687b      	ldr	r3, [r7, #4]
200020c0:	f04f 0202 	mov.w	r2, #2
200020c4:	711a      	strb	r2, [r3, #4]

        /* reset SPI0 */
        SYSREG->SOFT_RST_CR |= SYSREG_SPI0_SOFTRESET_MASK;
200020c6:	f248 0300 	movw	r3, #32768	; 0x8000
200020ca:	f2c4 0303 	movt	r3, #16387	; 0x4003
200020ce:	f248 0200 	movw	r2, #32768	; 0x8000
200020d2:	f2c4 0203 	movt	r2, #16387	; 0x4003
200020d6:	6c92      	ldr	r2, [r2, #72]	; 0x48
200020d8:	f442 7200 	orr.w	r2, r2, #512	; 0x200
200020dc:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended SPI0 interrupt */
        NVIC_ClearPendingIRQ(SPI0_IRQn);
200020de:	f04f 0002 	mov.w	r0, #2
200020e2:	f7ff ff07 	bl	20001ef4 <NVIC_ClearPendingIRQ>
        /* Take SPI0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_SPI0_SOFTRESET_MASK;
200020e6:	f248 0300 	movw	r3, #32768	; 0x8000
200020ea:	f2c4 0303 	movt	r3, #16387	; 0x4003
200020ee:	f248 0200 	movw	r2, #32768	; 0x8000
200020f2:	f2c4 0203 	movt	r2, #16387	; 0x4003
200020f6:	6c92      	ldr	r2, [r2, #72]	; 0x48
200020f8:	f422 7200 	bic.w	r2, r2, #512	; 0x200
200020fc:	649a      	str	r2, [r3, #72]	; 0x48

        this_spi->hw_reg->CONTROL &= ~CTRL_REG_RESET_MASK;
200020fe:	687b      	ldr	r3, [r7, #4]
20002100:	681b      	ldr	r3, [r3, #0]
20002102:	687a      	ldr	r2, [r7, #4]
20002104:	6812      	ldr	r2, [r2, #0]
20002106:	6812      	ldr	r2, [r2, #0]
20002108:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
2000210c:	601a      	str	r2, [r3, #0]
2000210e:	e02d      	b.n	2000216c <recover_from_rx_overflow+0x108>
    }
    else
    {
        this_spi->hw_reg = ((SPI_TypeDef *) SPI1_BASE);
20002110:	687a      	ldr	r2, [r7, #4]
20002112:	f241 0300 	movw	r3, #4096	; 0x1000
20002116:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000211a:	6013      	str	r3, [r2, #0]
        this_spi->irqn = SPI1_IRQn;
2000211c:	687b      	ldr	r3, [r7, #4]
2000211e:	f04f 0203 	mov.w	r2, #3
20002122:	711a      	strb	r2, [r3, #4]
        
        /* reset SPI1 */
        SYSREG->SOFT_RST_CR |= SYSREG_SPI1_SOFTRESET_MASK;
20002124:	f248 0300 	movw	r3, #32768	; 0x8000
20002128:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000212c:	f248 0200 	movw	r2, #32768	; 0x8000
20002130:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002134:	6c92      	ldr	r2, [r2, #72]	; 0x48
20002136:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
2000213a:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended SPI1 interrupt */
        NVIC_ClearPendingIRQ(SPI1_IRQn);
2000213c:	f04f 0003 	mov.w	r0, #3
20002140:	f7ff fed8 	bl	20001ef4 <NVIC_ClearPendingIRQ>
        /* Take SPI1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_SPI1_SOFTRESET_MASK;
20002144:	f248 0300 	movw	r3, #32768	; 0x8000
20002148:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000214c:	f248 0200 	movw	r2, #32768	; 0x8000
20002150:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002154:	6c92      	ldr	r2, [r2, #72]	; 0x48
20002156:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
2000215a:	649a      	str	r2, [r3, #72]	; 0x48
        
        this_spi->hw_reg->CONTROL &= ~CTRL_REG_RESET_MASK;
2000215c:	687b      	ldr	r3, [r7, #4]
2000215e:	681b      	ldr	r3, [r3, #0]
20002160:	687a      	ldr	r2, [r7, #4]
20002162:	6812      	ldr	r2, [r2, #0]
20002164:	6812      	ldr	r2, [r2, #0]
20002166:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
2000216a:	601a      	str	r2, [r3, #0]
    }
    
    /*
     * Restore SPI hardware block configuration.
     */
    control_reg &= ~(uint32_t)CTRL_ENABLE_MASK;
2000216c:	68fb      	ldr	r3, [r7, #12]
2000216e:	f023 0301 	bic.w	r3, r3, #1
20002172:	60fb      	str	r3, [r7, #12]
    this_spi->hw_reg->CONTROL = control_reg;
20002174:	687b      	ldr	r3, [r7, #4]
20002176:	681b      	ldr	r3, [r3, #0]
20002178:	68fa      	ldr	r2, [r7, #12]
2000217a:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CLK_GEN = clk_gen;
2000217c:	687b      	ldr	r3, [r7, #4]
2000217e:	681b      	ldr	r3, [r3, #0]
20002180:	693a      	ldr	r2, [r7, #16]
20002182:	619a      	str	r2, [r3, #24]
    this_spi->hw_reg->TXRXDF_SIZE = frame_size;
20002184:	687b      	ldr	r3, [r7, #4]
20002186:	681b      	ldr	r3, [r3, #0]
20002188:	697a      	ldr	r2, [r7, #20]
2000218a:	605a      	str	r2, [r3, #4]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
2000218c:	687b      	ldr	r3, [r7, #4]
2000218e:	681b      	ldr	r3, [r3, #0]
20002190:	687a      	ldr	r2, [r7, #4]
20002192:	6812      	ldr	r2, [r2, #0]
20002194:	6812      	ldr	r2, [r2, #0]
20002196:	f042 0201 	orr.w	r2, r2, #1
2000219a:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL2 = control2;
2000219c:	687b      	ldr	r3, [r7, #4]
2000219e:	681b      	ldr	r3, [r3, #0]
200021a0:	69ba      	ldr	r2, [r7, #24]
200021a2:	629a      	str	r2, [r3, #40]	; 0x28
    this_spi->hw_reg->PKTSIZE = packet_size;
200021a4:	687b      	ldr	r3, [r7, #4]
200021a6:	681b      	ldr	r3, [r3, #0]
200021a8:	69fa      	ldr	r2, [r7, #28]
200021aa:	631a      	str	r2, [r3, #48]	; 0x30
    this_spi->hw_reg->CMDSIZE = cmd_size;
200021ac:	687b      	ldr	r3, [r7, #4]
200021ae:	681b      	ldr	r3, [r3, #0]
200021b0:	6a3a      	ldr	r2, [r7, #32]
200021b2:	635a      	str	r2, [r3, #52]	; 0x34
    this_spi->hw_reg->SLAVE_SELECT = slave_select;
200021b4:	687b      	ldr	r3, [r7, #4]
200021b6:	681b      	ldr	r3, [r3, #0]
200021b8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
200021ba:	61da      	str	r2, [r3, #28]
}
200021bc:	f107 0728 	add.w	r7, r7, #40	; 0x28
200021c0:	46bd      	mov	sp, r7
200021c2:	bd80      	pop	{r7, pc}

200021c4 <MSS_SPI_configure_master_mode>:
    mss_spi_slave_t         slave,
    mss_spi_protocol_mode_t protocol_mode,
    uint32_t                clk_div,
    uint8_t                 frame_bit_length
)
{
200021c4:	b580      	push	{r7, lr}
200021c6:	b086      	sub	sp, #24
200021c8:	af00      	add	r7, sp, #0
200021ca:	60f8      	str	r0, [r7, #12]
200021cc:	607a      	str	r2, [r7, #4]
200021ce:	603b      	str	r3, [r7, #0]
200021d0:	460b      	mov	r3, r1
200021d2:	72fb      	strb	r3, [r7, #11]
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
200021d4:	68fa      	ldr	r2, [r7, #12]
200021d6:	f244 0370 	movw	r3, #16496	; 0x4070
200021da:	f2c2 0300 	movt	r3, #8192	; 0x2000
200021de:	429a      	cmp	r2, r3
200021e0:	d007      	beq.n	200021f2 <MSS_SPI_configure_master_mode+0x2e>
200021e2:	68fa      	ldr	r2, [r7, #12]
200021e4:	f643 73ec 	movw	r3, #16364	; 0x3fec
200021e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200021ec:	429a      	cmp	r2, r3
200021ee:	d000      	beq.n	200021f2 <MSS_SPI_configure_master_mode+0x2e>
200021f0:	be00      	bkpt	0x0000
    ASSERT(slave < MSS_SPI_MAX_NB_OF_SLAVES);
200021f2:	7afb      	ldrb	r3, [r7, #11]
200021f4:	2b07      	cmp	r3, #7
200021f6:	d900      	bls.n	200021fa <MSS_SPI_configure_master_mode+0x36>
200021f8:	be00      	bkpt	0x0000
    ASSERT(frame_bit_length <= MAX_FRAME_LENGTH);
200021fa:	f897 3020 	ldrb.w	r3, [r7, #32]
200021fe:	2b20      	cmp	r3, #32
20002200:	d900      	bls.n	20002204 <MSS_SPI_configure_master_mode+0x40>
20002202:	be00      	bkpt	0x0000
     /* Check that the requested clock divider is within range and an even number. */
    ASSERT(clk_div >= 2u);
20002204:	683b      	ldr	r3, [r7, #0]
20002206:	2b01      	cmp	r3, #1
20002208:	d800      	bhi.n	2000220c <MSS_SPI_configure_master_mode+0x48>
2000220a:	be00      	bkpt	0x0000
    ASSERT(clk_div <= 512u);
2000220c:	683b      	ldr	r3, [r7, #0]
2000220e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
20002212:	d900      	bls.n	20002216 <MSS_SPI_configure_master_mode+0x52>
20002214:	be00      	bkpt	0x0000
    ASSERT(0u == (clk_div & 0x00000001));
20002216:	683b      	ldr	r3, [r7, #0]
20002218:	f003 0301 	and.w	r3, r3, #1
2000221c:	2b00      	cmp	r3, #0
2000221e:	d000      	beq.n	20002222 <MSS_SPI_configure_master_mode+0x5e>
20002220:	be00      	bkpt	0x0000
   
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
20002222:	68fb      	ldr	r3, [r7, #12]
20002224:	791b      	ldrb	r3, [r3, #4]
20002226:	b25b      	sxtb	r3, r3
20002228:	4618      	mov	r0, r3
2000222a:	f7ff fe45 	bl	20001eb8 <NVIC_DisableIRQ>

    /* Reset slave transfer mode to unknown to wipe slate clean */
    this_spi->slave_xfer_mode = MSS_SPI_SLAVE_XFER_NONE;
2000222e:	68fb      	ldr	r3, [r7, #12]
20002230:	f04f 0200 	mov.w	r2, #0
20002234:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

    /* Set the mode. */
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
20002238:	68fb      	ldr	r3, [r7, #12]
2000223a:	681b      	ldr	r3, [r3, #0]
2000223c:	68fa      	ldr	r2, [r7, #12]
2000223e:	6812      	ldr	r2, [r2, #0]
20002240:	6812      	ldr	r2, [r2, #0]
20002242:	f022 0201 	bic.w	r2, r2, #1
20002246:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL |= CTRL_MASTER_MASK;
20002248:	68fb      	ldr	r3, [r7, #12]
2000224a:	681b      	ldr	r3, [r3, #0]
2000224c:	68fa      	ldr	r2, [r7, #12]
2000224e:	6812      	ldr	r2, [r2, #0]
20002250:	6812      	ldr	r2, [r2, #0]
20002252:	f042 0202 	orr.w	r2, r2, #2
20002256:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
20002258:	68fb      	ldr	r3, [r7, #12]
2000225a:	681b      	ldr	r3, [r3, #0]
2000225c:	68fa      	ldr	r2, [r7, #12]
2000225e:	6812      	ldr	r2, [r2, #0]
20002260:	6812      	ldr	r2, [r2, #0]
20002262:	f042 0201 	orr.w	r2, r2, #1
20002266:	601a      	str	r2, [r3, #0]
    /*
     * Keep track of the required register configuration for this slave. These
     * values will be used by the MSS_SPI_set_slave_select() function to configure
     * the master to match the slave being selected.
     */
    if(slave < MSS_SPI_MAX_NB_OF_SLAVES)     
20002268:	7afb      	ldrb	r3, [r7, #11]
2000226a:	2b07      	cmp	r3, #7
2000226c:	d847      	bhi.n	200022fe <MSS_SPI_configure_master_mode+0x13a>
        * Setting the SPS bit ensures the slave select remains asserted even
        * if we don't keep the TX FIFO filled in block mode. We only do it for
        * Motorola modes and if you need the slave selected deselected between
        * frames in modes 0 or 2 then remove SPS_MASK from below.
        */
        if((MSS_SPI_MODE0 == protocol_mode) || (MSS_SPI_MODE1 == protocol_mode) ||
2000226e:	687b      	ldr	r3, [r7, #4]
20002270:	2b00      	cmp	r3, #0
20002272:	d00b      	beq.n	2000228c <MSS_SPI_configure_master_mode+0xc8>
20002274:	687b      	ldr	r3, [r7, #4]
20002276:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000227a:	d007      	beq.n	2000228c <MSS_SPI_configure_master_mode+0xc8>
2000227c:	687b      	ldr	r3, [r7, #4]
2000227e:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20002282:	d003      	beq.n	2000228c <MSS_SPI_configure_master_mode+0xc8>
20002284:	687b      	ldr	r3, [r7, #4]
20002286:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
2000228a:	d10f      	bne.n	200022ac <MSS_SPI_configure_master_mode+0xe8>
           (MSS_SPI_MODE2 == protocol_mode) || (MSS_SPI_MODE3 == protocol_mode))
        {
            this_spi->slaves_cfg[slave].ctrl_reg = MASTER_MODE_MASK | SPS_MASK |
2000228c:	7afa      	ldrb	r2, [r7, #11]
2000228e:	6879      	ldr	r1, [r7, #4]
20002290:	f240 1302 	movw	r3, #258	; 0x102
20002294:	f2c3 4300 	movt	r3, #13312	; 0x3400
20002298:	ea41 0303 	orr.w	r3, r1, r3
2000229c:	68f9      	ldr	r1, [r7, #12]
2000229e:	f102 0206 	add.w	r2, r2, #6
200022a2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
200022a6:	440a      	add	r2, r1
200022a8:	6053      	str	r3, [r2, #4]
        * Setting the SPS bit ensures the slave select remains asserted even
        * if we don't keep the TX FIFO filled in block mode. We only do it for
        * Motorola modes and if you need the slave selected deselected between
        * frames in modes 0 or 2 then remove SPS_MASK from below.
        */
        if((MSS_SPI_MODE0 == protocol_mode) || (MSS_SPI_MODE1 == protocol_mode) ||
200022aa:	e00e      	b.n	200022ca <MSS_SPI_configure_master_mode+0x106>
                                                   (uint32_t)protocol_mode | 
                                                   ((uint32_t)1 << TXRXDFCOUNT_SHIFT);
        }
        else
        {
            this_spi->slaves_cfg[slave].ctrl_reg = MASTER_MODE_MASK |
200022ac:	7afa      	ldrb	r2, [r7, #11]
200022ae:	6879      	ldr	r1, [r7, #4]
200022b0:	f240 1302 	movw	r3, #258	; 0x102
200022b4:	f2c3 0300 	movt	r3, #12288	; 0x3000
200022b8:	ea41 0303 	orr.w	r3, r1, r3
200022bc:	68f9      	ldr	r1, [r7, #12]
200022be:	f102 0206 	add.w	r2, r2, #6
200022c2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
200022c6:	440a      	add	r2, r1
200022c8:	6053      	str	r3, [r2, #4]
                                                   BIGFIFO_MASK | CTRL_CLKMODE_MASK |
                                                   (uint32_t)protocol_mode | 
                                                   ((uint32_t)1 << TXRXDFCOUNT_SHIFT);
        }
        this_spi->slaves_cfg[slave].txrxdf_size_reg = frame_bit_length;
200022ca:	7afb      	ldrb	r3, [r7, #11]
200022cc:	68fa      	ldr	r2, [r7, #12]
200022ce:	f103 0306 	add.w	r3, r3, #6
200022d2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
200022d6:	4413      	add	r3, r2
200022d8:	f897 2020 	ldrb.w	r2, [r7, #32]
200022dc:	721a      	strb	r2, [r3, #8]

        clk_gen = (clk_div / 2u) - 1u;
200022de:	683b      	ldr	r3, [r7, #0]
200022e0:	ea4f 0353 	mov.w	r3, r3, lsr #1
200022e4:	f103 33ff 	add.w	r3, r3, #4294967295
200022e8:	617b      	str	r3, [r7, #20]
        this_spi->slaves_cfg[slave].clk_gen = (uint8_t)clk_gen;
200022ea:	7afb      	ldrb	r3, [r7, #11]
200022ec:	697a      	ldr	r2, [r7, #20]
200022ee:	b2d2      	uxtb	r2, r2
200022f0:	68f9      	ldr	r1, [r7, #12]
200022f2:	f103 0306 	add.w	r3, r3, #6
200022f6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
200022fa:	440b      	add	r3, r1
200022fc:	725a      	strb	r2, [r3, #9]
    }
    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
200022fe:	68fb      	ldr	r3, [r7, #12]
20002300:	791b      	ldrb	r3, [r3, #4]
20002302:	b25b      	sxtb	r3, r3
20002304:	4618      	mov	r0, r3
20002306:	f7ff fdbb 	bl	20001e80 <NVIC_EnableIRQ>
}
2000230a:	f107 0718 	add.w	r7, r7, #24
2000230e:	46bd      	mov	sp, r7
20002310:	bd80      	pop	{r7, pc}
20002312:	bf00      	nop

20002314 <MSS_SPI_set_slave_select>:
void MSS_SPI_set_slave_select
(
    mss_spi_instance_t * this_spi,
    mss_spi_slave_t slave
)
{
20002314:	b580      	push	{r7, lr}
20002316:	b084      	sub	sp, #16
20002318:	af00      	add	r7, sp, #0
2000231a:	6078      	str	r0, [r7, #4]
2000231c:	460b      	mov	r3, r1
2000231e:	70fb      	strb	r3, [r7, #3]
    uint32_t rx_overflow;
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
20002320:	687a      	ldr	r2, [r7, #4]
20002322:	f244 0370 	movw	r3, #16496	; 0x4070
20002326:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000232a:	429a      	cmp	r2, r3
2000232c:	d007      	beq.n	2000233e <MSS_SPI_set_slave_select+0x2a>
2000232e:	687a      	ldr	r2, [r7, #4]
20002330:	f643 73ec 	movw	r3, #16364	; 0x3fec
20002334:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002338:	429a      	cmp	r2, r3
2000233a:	d000      	beq.n	2000233e <MSS_SPI_set_slave_select+0x2a>
2000233c:	be00      	bkpt	0x0000
    
    /* This function is only intended to be used with an SPI master. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) == CTRL_MASTER_MASK);
2000233e:	687b      	ldr	r3, [r7, #4]
20002340:	681b      	ldr	r3, [r3, #0]
20002342:	681b      	ldr	r3, [r3, #0]
20002344:	f003 0302 	and.w	r3, r3, #2
20002348:	2b00      	cmp	r3, #0
2000234a:	d100      	bne.n	2000234e <MSS_SPI_set_slave_select+0x3a>
2000234c:	be00      	bkpt	0x0000
    
    ASSERT(this_spi->slaves_cfg[slave].ctrl_reg != NOT_CONFIGURED);
2000234e:	78fb      	ldrb	r3, [r7, #3]
20002350:	687a      	ldr	r2, [r7, #4]
20002352:	f103 0306 	add.w	r3, r3, #6
20002356:	ea4f 03c3 	mov.w	r3, r3, lsl #3
2000235a:	4413      	add	r3, r2
2000235c:	685b      	ldr	r3, [r3, #4]
2000235e:	f1b3 3fff 	cmp.w	r3, #4294967295
20002362:	d100      	bne.n	20002366 <MSS_SPI_set_slave_select+0x52>
20002364:	be00      	bkpt	0x0000

    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
20002366:	687b      	ldr	r3, [r7, #4]
20002368:	791b      	ldrb	r3, [r3, #4]
2000236a:	b25b      	sxtb	r3, r3
2000236c:	4618      	mov	r0, r3
2000236e:	f7ff fda3 	bl	20001eb8 <NVIC_DisableIRQ>

    /* Recover from receive overflow. */
    rx_overflow = this_spi->hw_reg->STATUS & RX_OVERFLOW_MASK;
20002372:	687b      	ldr	r3, [r7, #4]
20002374:	681b      	ldr	r3, [r3, #0]
20002376:	689b      	ldr	r3, [r3, #8]
20002378:	f003 0304 	and.w	r3, r3, #4
2000237c:	60fb      	str	r3, [r7, #12]
    if(rx_overflow)
2000237e:	68fb      	ldr	r3, [r7, #12]
20002380:	2b00      	cmp	r3, #0
20002382:	d002      	beq.n	2000238a <MSS_SPI_set_slave_select+0x76>
    {
         recover_from_rx_overflow(this_spi);
20002384:	6878      	ldr	r0, [r7, #4]
20002386:	f7ff fe6d 	bl	20002064 <recover_from_rx_overflow>
    }
    
    /* Set the clock rate. */
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
2000238a:	687b      	ldr	r3, [r7, #4]
2000238c:	681b      	ldr	r3, [r3, #0]
2000238e:	687a      	ldr	r2, [r7, #4]
20002390:	6812      	ldr	r2, [r2, #0]
20002392:	6812      	ldr	r2, [r2, #0]
20002394:	f022 0201 	bic.w	r2, r2, #1
20002398:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL = this_spi->slaves_cfg[slave].ctrl_reg;
2000239a:	687b      	ldr	r3, [r7, #4]
2000239c:	681a      	ldr	r2, [r3, #0]
2000239e:	78fb      	ldrb	r3, [r7, #3]
200023a0:	6879      	ldr	r1, [r7, #4]
200023a2:	f103 0306 	add.w	r3, r3, #6
200023a6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
200023aa:	440b      	add	r3, r1
200023ac:	685b      	ldr	r3, [r3, #4]
200023ae:	6013      	str	r3, [r2, #0]
    this_spi->hw_reg->CLK_GEN = this_spi->slaves_cfg[slave].clk_gen;
200023b0:	687b      	ldr	r3, [r7, #4]
200023b2:	681a      	ldr	r2, [r3, #0]
200023b4:	78fb      	ldrb	r3, [r7, #3]
200023b6:	6879      	ldr	r1, [r7, #4]
200023b8:	f103 0306 	add.w	r3, r3, #6
200023bc:	ea4f 03c3 	mov.w	r3, r3, lsl #3
200023c0:	440b      	add	r3, r1
200023c2:	7a5b      	ldrb	r3, [r3, #9]
200023c4:	6193      	str	r3, [r2, #24]
    this_spi->hw_reg->TXRXDF_SIZE = this_spi->slaves_cfg[slave].txrxdf_size_reg;
200023c6:	687b      	ldr	r3, [r7, #4]
200023c8:	681a      	ldr	r2, [r3, #0]
200023ca:	78fb      	ldrb	r3, [r7, #3]
200023cc:	6879      	ldr	r1, [r7, #4]
200023ce:	f103 0306 	add.w	r3, r3, #6
200023d2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
200023d6:	440b      	add	r3, r1
200023d8:	7a1b      	ldrb	r3, [r3, #8]
200023da:	6053      	str	r3, [r2, #4]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
200023dc:	687b      	ldr	r3, [r7, #4]
200023de:	681b      	ldr	r3, [r3, #0]
200023e0:	687a      	ldr	r2, [r7, #4]
200023e2:	6812      	ldr	r2, [r2, #0]
200023e4:	6812      	ldr	r2, [r2, #0]
200023e6:	f042 0201 	orr.w	r2, r2, #1
200023ea:	601a      	str	r2, [r3, #0]
    
    /* Set slave select */
    this_spi->hw_reg->SLAVE_SELECT |= ((uint32_t)1 << (uint32_t)slave);
200023ec:	687b      	ldr	r3, [r7, #4]
200023ee:	681b      	ldr	r3, [r3, #0]
200023f0:	687a      	ldr	r2, [r7, #4]
200023f2:	6812      	ldr	r2, [r2, #0]
200023f4:	69d1      	ldr	r1, [r2, #28]
200023f6:	78fa      	ldrb	r2, [r7, #3]
200023f8:	f04f 0001 	mov.w	r0, #1
200023fc:	fa00 f202 	lsl.w	r2, r0, r2
20002400:	ea41 0202 	orr.w	r2, r1, r2
20002404:	61da      	str	r2, [r3, #28]
    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
20002406:	687b      	ldr	r3, [r7, #4]
20002408:	791b      	ldrb	r3, [r3, #4]
2000240a:	b25b      	sxtb	r3, r3
2000240c:	4618      	mov	r0, r3
2000240e:	f7ff fd37 	bl	20001e80 <NVIC_EnableIRQ>
}
20002412:	f107 0710 	add.w	r7, r7, #16
20002416:	46bd      	mov	sp, r7
20002418:	bd80      	pop	{r7, pc}
2000241a:	bf00      	nop

2000241c <MSS_SPI_clear_slave_select>:
void MSS_SPI_clear_slave_select
(
    mss_spi_instance_t * this_spi,
    mss_spi_slave_t slave
)
{
2000241c:	b580      	push	{r7, lr}
2000241e:	b084      	sub	sp, #16
20002420:	af00      	add	r7, sp, #0
20002422:	6078      	str	r0, [r7, #4]
20002424:	460b      	mov	r3, r1
20002426:	70fb      	strb	r3, [r7, #3]
    uint32_t rx_overflow;
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
20002428:	687a      	ldr	r2, [r7, #4]
2000242a:	f244 0370 	movw	r3, #16496	; 0x4070
2000242e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002432:	429a      	cmp	r2, r3
20002434:	d007      	beq.n	20002446 <MSS_SPI_clear_slave_select+0x2a>
20002436:	687a      	ldr	r2, [r7, #4]
20002438:	f643 73ec 	movw	r3, #16364	; 0x3fec
2000243c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002440:	429a      	cmp	r2, r3
20002442:	d000      	beq.n	20002446 <MSS_SPI_clear_slave_select+0x2a>
20002444:	be00      	bkpt	0x0000
    
    /* This function is only intended to be used with an SPI master. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) == CTRL_MASTER_MASK);
20002446:	687b      	ldr	r3, [r7, #4]
20002448:	681b      	ldr	r3, [r3, #0]
2000244a:	681b      	ldr	r3, [r3, #0]
2000244c:	f003 0302 	and.w	r3, r3, #2
20002450:	2b00      	cmp	r3, #0
20002452:	d100      	bne.n	20002456 <MSS_SPI_clear_slave_select+0x3a>
20002454:	be00      	bkpt	0x0000

    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
20002456:	687b      	ldr	r3, [r7, #4]
20002458:	791b      	ldrb	r3, [r3, #4]
2000245a:	b25b      	sxtb	r3, r3
2000245c:	4618      	mov	r0, r3
2000245e:	f7ff fd2b 	bl	20001eb8 <NVIC_DisableIRQ>

    /* Recover from receive overflow. */
    rx_overflow = this_spi->hw_reg->STATUS & RX_OVERFLOW_MASK;
20002462:	687b      	ldr	r3, [r7, #4]
20002464:	681b      	ldr	r3, [r3, #0]
20002466:	689b      	ldr	r3, [r3, #8]
20002468:	f003 0304 	and.w	r3, r3, #4
2000246c:	60fb      	str	r3, [r7, #12]
    if(rx_overflow)
2000246e:	68fb      	ldr	r3, [r7, #12]
20002470:	2b00      	cmp	r3, #0
20002472:	d002      	beq.n	2000247a <MSS_SPI_clear_slave_select+0x5e>
    {
         recover_from_rx_overflow(this_spi);
20002474:	6878      	ldr	r0, [r7, #4]
20002476:	f7ff fdf5 	bl	20002064 <recover_from_rx_overflow>
    }
    
    this_spi->hw_reg->SLAVE_SELECT &= ~((uint32_t)1 << (uint32_t)slave);
2000247a:	687b      	ldr	r3, [r7, #4]
2000247c:	681b      	ldr	r3, [r3, #0]
2000247e:	687a      	ldr	r2, [r7, #4]
20002480:	6812      	ldr	r2, [r2, #0]
20002482:	69d1      	ldr	r1, [r2, #28]
20002484:	78fa      	ldrb	r2, [r7, #3]
20002486:	f04f 0001 	mov.w	r0, #1
2000248a:	fa00 f202 	lsl.w	r2, r0, r2
2000248e:	ea6f 0202 	mvn.w	r2, r2
20002492:	ea01 0202 	and.w	r2, r1, r2
20002496:	61da      	str	r2, [r3, #28]
    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
20002498:	687b      	ldr	r3, [r7, #4]
2000249a:	791b      	ldrb	r3, [r3, #4]
2000249c:	b25b      	sxtb	r3, r3
2000249e:	4618      	mov	r0, r3
200024a0:	f7ff fcee 	bl	20001e80 <NVIC_EnableIRQ>
}
200024a4:	f107 0710 	add.w	r7, r7, #16
200024a8:	46bd      	mov	sp, r7
200024aa:	bd80      	pop	{r7, pc}

200024ac <MSS_SPI_transfer_block>:
    const uint8_t * cmd_buffer,
    uint16_t cmd_byte_size,
    uint8_t * rd_buffer,
    uint16_t rd_byte_size
)
{
200024ac:	b580      	push	{r7, lr}
200024ae:	b08e      	sub	sp, #56	; 0x38
200024b0:	af00      	add	r7, sp, #0
200024b2:	60f8      	str	r0, [r7, #12]
200024b4:	60b9      	str	r1, [r7, #8]
200024b6:	603b      	str	r3, [r7, #0]
200024b8:	4613      	mov	r3, r2
200024ba:	80fb      	strh	r3, [r7, #6]
    uint16_t transfer_idx = 0u;
200024bc:	f04f 0300 	mov.w	r3, #0
200024c0:	837b      	strh	r3, [r7, #26]
    uint16_t tx_idx;
    uint16_t rx_idx;
    uint32_t frame_count;
    volatile uint32_t rx_raw;
    uint16_t transit = 0u;
200024c2:	f04f 0300 	mov.w	r3, #0
200024c6:	84fb      	strh	r3, [r7, #38]	; 0x26
    uint32_t rx_overflow;
    uint32_t rx_fifo_empty;
    
    uint16_t transfer_size;     /* Total number of bytes transfered. */
    
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
200024c8:	68fa      	ldr	r2, [r7, #12]
200024ca:	f244 0370 	movw	r3, #16496	; 0x4070
200024ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
200024d2:	429a      	cmp	r2, r3
200024d4:	d007      	beq.n	200024e6 <MSS_SPI_transfer_block+0x3a>
200024d6:	68fa      	ldr	r2, [r7, #12]
200024d8:	f643 73ec 	movw	r3, #16364	; 0x3fec
200024dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
200024e0:	429a      	cmp	r2, r3
200024e2:	d000      	beq.n	200024e6 <MSS_SPI_transfer_block+0x3a>
200024e4:	be00      	bkpt	0x0000
    
    /* This function is only intended to be used with an SPI master. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) == CTRL_MASTER_MASK);
200024e6:	68fb      	ldr	r3, [r7, #12]
200024e8:	681b      	ldr	r3, [r3, #0]
200024ea:	681b      	ldr	r3, [r3, #0]
200024ec:	f003 0302 	and.w	r3, r3, #2
200024f0:	2b00      	cmp	r3, #0
200024f2:	d100      	bne.n	200024f6 <MSS_SPI_transfer_block+0x4a>
200024f4:	be00      	bkpt	0x0000
    
    /* Compute number of bytes to transfer. */
    transfer_size = cmd_byte_size + rd_byte_size;
200024f6:	88fa      	ldrh	r2, [r7, #6]
200024f8:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
200024fc:	4413      	add	r3, r2
200024fe:	86fb      	strh	r3, [r7, #54]	; 0x36
    
    /* Adjust to 1 byte transfer to cater for DMA transfers. */
    if(0u == transfer_size)
20002500:	8efb      	ldrh	r3, [r7, #54]	; 0x36
20002502:	2b00      	cmp	r3, #0
20002504:	d103      	bne.n	2000250e <MSS_SPI_transfer_block+0x62>
    {
        frame_count = 1u;
20002506:	f04f 0301 	mov.w	r3, #1
2000250a:	623b      	str	r3, [r7, #32]
2000250c:	e001      	b.n	20002512 <MSS_SPI_transfer_block+0x66>
    }
    else
    {
        frame_count = transfer_size;
2000250e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
20002510:	623b      	str	r3, [r7, #32]
    }

    /* Flush the Tx and Rx FIFOs. */
    this_spi->hw_reg->COMMAND |= (TX_FIFO_RESET_MASK | RX_FIFO_RESET_MASK);
20002512:	68fb      	ldr	r3, [r7, #12]
20002514:	681b      	ldr	r3, [r3, #0]
20002516:	68fa      	ldr	r2, [r7, #12]
20002518:	6812      	ldr	r2, [r2, #0]
2000251a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
2000251c:	f042 020c 	orr.w	r2, r2, #12
20002520:	62da      	str	r2, [r3, #44]	; 0x2c
    
    /* Recover from receive overflow. */
    rx_overflow = this_spi->hw_reg->STATUS & RX_OVERFLOW_MASK;
20002522:	68fb      	ldr	r3, [r7, #12]
20002524:	681b      	ldr	r3, [r3, #0]
20002526:	689b      	ldr	r3, [r3, #8]
20002528:	f003 0304 	and.w	r3, r3, #4
2000252c:	62fb      	str	r3, [r7, #44]	; 0x2c
    if(rx_overflow)
2000252e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
20002530:	2b00      	cmp	r3, #0
20002532:	d002      	beq.n	2000253a <MSS_SPI_transfer_block+0x8e>
    {
         recover_from_rx_overflow(this_spi);
20002534:	68f8      	ldr	r0, [r7, #12]
20002536:	f7ff fd95 	bl	20002064 <recover_from_rx_overflow>
    }
    
    /* Set frame size to 8 bits and the frame count to the transfer size. */
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
2000253a:	68fb      	ldr	r3, [r7, #12]
2000253c:	681b      	ldr	r3, [r3, #0]
2000253e:	68fa      	ldr	r2, [r7, #12]
20002540:	6812      	ldr	r2, [r2, #0]
20002542:	6812      	ldr	r2, [r2, #0]
20002544:	f022 0201 	bic.w	r2, r2, #1
20002548:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK) | ( (frame_count << TXRXDFCOUNT_SHIFT) & TXRXDFCOUNT_MASK);
2000254a:	68fb      	ldr	r3, [r7, #12]
2000254c:	6819      	ldr	r1, [r3, #0]
2000254e:	68fb      	ldr	r3, [r7, #12]
20002550:	681b      	ldr	r3, [r3, #0]
20002552:	681b      	ldr	r3, [r3, #0]
20002554:	f240 02ff 	movw	r2, #255	; 0xff
20002558:	f6cf 7200 	movt	r2, #65280	; 0xff00
2000255c:	ea03 0202 	and.w	r2, r3, r2
20002560:	6a3b      	ldr	r3, [r7, #32]
20002562:	ea4f 2003 	mov.w	r0, r3, lsl #8
20002566:	f64f 7300 	movw	r3, #65280	; 0xff00
2000256a:	f2c0 03ff 	movt	r3, #255	; 0xff
2000256e:	ea00 0303 	and.w	r3, r0, r3
20002572:	ea42 0303 	orr.w	r3, r2, r3
20002576:	600b      	str	r3, [r1, #0]
    this_spi->hw_reg->TXRXDF_SIZE = MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE;
20002578:	68fb      	ldr	r3, [r7, #12]
2000257a:	681b      	ldr	r3, [r3, #0]
2000257c:	f04f 0208 	mov.w	r2, #8
20002580:	605a      	str	r2, [r3, #4]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
20002582:	68fb      	ldr	r3, [r7, #12]
20002584:	681b      	ldr	r3, [r3, #0]
20002586:	68fa      	ldr	r2, [r7, #12]
20002588:	6812      	ldr	r2, [r2, #0]
2000258a:	6812      	ldr	r2, [r2, #0]
2000258c:	f042 0201 	orr.w	r2, r2, #1
20002590:	601a      	str	r2, [r3, #0]

    /* Flush the receive FIFO. */
    rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
20002592:	68fb      	ldr	r3, [r7, #12]
20002594:	681b      	ldr	r3, [r3, #0]
20002596:	689b      	ldr	r3, [r3, #8]
20002598:	f003 0340 	and.w	r3, r3, #64	; 0x40
2000259c:	633b      	str	r3, [r7, #48]	; 0x30
    while(0u == rx_fifo_empty)
2000259e:	e009      	b.n	200025b4 <MSS_SPI_transfer_block+0x108>
    {
        rx_raw = this_spi->hw_reg->RX_DATA;
200025a0:	68fb      	ldr	r3, [r7, #12]
200025a2:	681b      	ldr	r3, [r3, #0]
200025a4:	691b      	ldr	r3, [r3, #16]
200025a6:	617b      	str	r3, [r7, #20]
        rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
200025a8:	68fb      	ldr	r3, [r7, #12]
200025aa:	681b      	ldr	r3, [r3, #0]
200025ac:	689b      	ldr	r3, [r3, #8]
200025ae:	f003 0340 	and.w	r3, r3, #64	; 0x40
200025b2:	633b      	str	r3, [r7, #48]	; 0x30
    this_spi->hw_reg->TXRXDF_SIZE = MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE;
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;

    /* Flush the receive FIFO. */
    rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
    while(0u == rx_fifo_empty)
200025b4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
200025b6:	2b00      	cmp	r3, #0
200025b8:	d0f2      	beq.n	200025a0 <MSS_SPI_transfer_block+0xf4>
    {
        rx_raw = this_spi->hw_reg->RX_DATA;
        rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
    }
    
    tx_idx = 0u;
200025ba:	f04f 0300 	mov.w	r3, #0
200025be:	83bb      	strh	r3, [r7, #28]
    rx_idx = 0u;
200025c0:	f04f 0300 	mov.w	r3, #0
200025c4:	83fb      	strh	r3, [r7, #30]
    if(tx_idx < cmd_byte_size)
200025c6:	8bba      	ldrh	r2, [r7, #28]
200025c8:	88fb      	ldrh	r3, [r7, #6]
200025ca:	429a      	cmp	r2, r3
200025cc:	d20f      	bcs.n	200025ee <MSS_SPI_transfer_block+0x142>
    {
        this_spi->hw_reg->TX_DATA = cmd_buffer[tx_idx];
200025ce:	68fb      	ldr	r3, [r7, #12]
200025d0:	681b      	ldr	r3, [r3, #0]
200025d2:	8bb9      	ldrh	r1, [r7, #28]
200025d4:	68ba      	ldr	r2, [r7, #8]
200025d6:	440a      	add	r2, r1
200025d8:	7812      	ldrb	r2, [r2, #0]
200025da:	615a      	str	r2, [r3, #20]
        ++tx_idx;
200025dc:	8bbb      	ldrh	r3, [r7, #28]
200025de:	f103 0301 	add.w	r3, r3, #1
200025e2:	83bb      	strh	r3, [r7, #28]
        ++transit;
200025e4:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
200025e6:	f103 0301 	add.w	r3, r3, #1
200025ea:	84fb      	strh	r3, [r7, #38]	; 0x26
        }
    }
    /* Perform the remainder of the transfer by sending a byte every time a byte
     * has been received. This should ensure that no Rx overflow can happen in
     * case of an interrupt occurs during this function. */
    while(transfer_idx < transfer_size)
200025ec:	e06a      	b.n	200026c4 <MSS_SPI_transfer_block+0x218>
        ++tx_idx;
        ++transit;
    }
    else
    {
        if(tx_idx < transfer_size)
200025ee:	8bba      	ldrh	r2, [r7, #28]
200025f0:	8efb      	ldrh	r3, [r7, #54]	; 0x36
200025f2:	429a      	cmp	r2, r3
200025f4:	d266      	bcs.n	200026c4 <MSS_SPI_transfer_block+0x218>
        {
            this_spi->hw_reg->TX_DATA = 0x00u;
200025f6:	68fb      	ldr	r3, [r7, #12]
200025f8:	681b      	ldr	r3, [r3, #0]
200025fa:	f04f 0200 	mov.w	r2, #0
200025fe:	615a      	str	r2, [r3, #20]
            ++tx_idx;
20002600:	8bbb      	ldrh	r3, [r7, #28]
20002602:	f103 0301 	add.w	r3, r3, #1
20002606:	83bb      	strh	r3, [r7, #28]
            ++transit;
20002608:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
2000260a:	f103 0301 	add.w	r3, r3, #1
2000260e:	84fb      	strh	r3, [r7, #38]	; 0x26
        }
    }
    /* Perform the remainder of the transfer by sending a byte every time a byte
     * has been received. This should ensure that no Rx overflow can happen in
     * case of an interrupt occurs during this function. */
    while(transfer_idx < transfer_size)
20002610:	e058      	b.n	200026c4 <MSS_SPI_transfer_block+0x218>
    {
        rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
20002612:	68fb      	ldr	r3, [r7, #12]
20002614:	681b      	ldr	r3, [r3, #0]
20002616:	689b      	ldr	r3, [r3, #8]
20002618:	f003 0340 	and.w	r3, r3, #64	; 0x40
2000261c:	633b      	str	r3, [r7, #48]	; 0x30
        if(0u == rx_fifo_empty)
2000261e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
20002620:	2b00      	cmp	r3, #0
20002622:	d11e      	bne.n	20002662 <MSS_SPI_transfer_block+0x1b6>
        {
            /* Process received byte. */
            rx_raw = this_spi->hw_reg->RX_DATA;
20002624:	68fb      	ldr	r3, [r7, #12]
20002626:	681b      	ldr	r3, [r3, #0]
20002628:	691b      	ldr	r3, [r3, #16]
2000262a:	617b      	str	r3, [r7, #20]
            if(transfer_idx >= cmd_byte_size)
2000262c:	8b7a      	ldrh	r2, [r7, #26]
2000262e:	88fb      	ldrh	r3, [r7, #6]
20002630:	429a      	cmp	r2, r3
20002632:	d30e      	bcc.n	20002652 <MSS_SPI_transfer_block+0x1a6>
            {
                if(rx_idx < rd_byte_size)
20002634:	8bfa      	ldrh	r2, [r7, #30]
20002636:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
2000263a:	429a      	cmp	r2, r3
2000263c:	d205      	bcs.n	2000264a <MSS_SPI_transfer_block+0x19e>
                {
                    rd_buffer[rx_idx] = (uint8_t)rx_raw;   
2000263e:	8bfa      	ldrh	r2, [r7, #30]
20002640:	683b      	ldr	r3, [r7, #0]
20002642:	4413      	add	r3, r2
20002644:	697a      	ldr	r2, [r7, #20]
20002646:	b2d2      	uxtb	r2, r2
20002648:	701a      	strb	r2, [r3, #0]
                }
                ++rx_idx;
2000264a:	8bfb      	ldrh	r3, [r7, #30]
2000264c:	f103 0301 	add.w	r3, r3, #1
20002650:	83fb      	strh	r3, [r7, #30]
            }
            ++transfer_idx;
20002652:	8b7b      	ldrh	r3, [r7, #26]
20002654:	f103 0301 	add.w	r3, r3, #1
20002658:	837b      	strh	r3, [r7, #26]
            --transit;
2000265a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
2000265c:	f103 33ff 	add.w	r3, r3, #4294967295
20002660:	84fb      	strh	r3, [r7, #38]	; 0x26
        }

        tx_fifo_full = this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK;
20002662:	68fb      	ldr	r3, [r7, #12]
20002664:	681b      	ldr	r3, [r3, #0]
20002666:	689b      	ldr	r3, [r3, #8]
20002668:	f403 7380 	and.w	r3, r3, #256	; 0x100
2000266c:	62bb      	str	r3, [r7, #40]	; 0x28
        if(0u == tx_fifo_full)
2000266e:	6abb      	ldr	r3, [r7, #40]	; 0x28
20002670:	2b00      	cmp	r3, #0
20002672:	d127      	bne.n	200026c4 <MSS_SPI_transfer_block+0x218>
        {
            if(transit < RX_FIFO_SIZE)
20002674:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
20002676:	2b03      	cmp	r3, #3
20002678:	d824      	bhi.n	200026c4 <MSS_SPI_transfer_block+0x218>
            {
                /* Send another byte. */
                if(tx_idx < cmd_byte_size)
2000267a:	8bba      	ldrh	r2, [r7, #28]
2000267c:	88fb      	ldrh	r3, [r7, #6]
2000267e:	429a      	cmp	r2, r3
20002680:	d20f      	bcs.n	200026a2 <MSS_SPI_transfer_block+0x1f6>
                {
                    this_spi->hw_reg->TX_DATA = cmd_buffer[tx_idx];
20002682:	68fb      	ldr	r3, [r7, #12]
20002684:	681b      	ldr	r3, [r3, #0]
20002686:	8bb9      	ldrh	r1, [r7, #28]
20002688:	68ba      	ldr	r2, [r7, #8]
2000268a:	440a      	add	r2, r1
2000268c:	7812      	ldrb	r2, [r2, #0]
2000268e:	615a      	str	r2, [r3, #20]
                    ++tx_idx;
20002690:	8bbb      	ldrh	r3, [r7, #28]
20002692:	f103 0301 	add.w	r3, r3, #1
20002696:	83bb      	strh	r3, [r7, #28]
                    ++transit;
20002698:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
2000269a:	f103 0301 	add.w	r3, r3, #1
2000269e:	84fb      	strh	r3, [r7, #38]	; 0x26
200026a0:	e010      	b.n	200026c4 <MSS_SPI_transfer_block+0x218>
                }
                else
                {
                    if(tx_idx < transfer_size)
200026a2:	8bba      	ldrh	r2, [r7, #28]
200026a4:	8efb      	ldrh	r3, [r7, #54]	; 0x36
200026a6:	429a      	cmp	r2, r3
200026a8:	d20c      	bcs.n	200026c4 <MSS_SPI_transfer_block+0x218>
                    {
                        this_spi->hw_reg->TX_DATA = 0x00u;
200026aa:	68fb      	ldr	r3, [r7, #12]
200026ac:	681b      	ldr	r3, [r3, #0]
200026ae:	f04f 0200 	mov.w	r2, #0
200026b2:	615a      	str	r2, [r3, #20]
                        ++tx_idx;
200026b4:	8bbb      	ldrh	r3, [r7, #28]
200026b6:	f103 0301 	add.w	r3, r3, #1
200026ba:	83bb      	strh	r3, [r7, #28]
                        ++transit;
200026bc:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
200026be:	f103 0301 	add.w	r3, r3, #1
200026c2:	84fb      	strh	r3, [r7, #38]	; 0x26
        }
    }
    /* Perform the remainder of the transfer by sending a byte every time a byte
     * has been received. This should ensure that no Rx overflow can happen in
     * case of an interrupt occurs during this function. */
    while(transfer_idx < transfer_size)
200026c4:	8b7a      	ldrh	r2, [r7, #26]
200026c6:	8efb      	ldrh	r3, [r7, #54]	; 0x36
200026c8:	429a      	cmp	r2, r3
200026ca:	d3a2      	bcc.n	20002612 <MSS_SPI_transfer_block+0x166>
                    }
                }
            }
        }
    }
}
200026cc:	f107 0738 	add.w	r7, r7, #56	; 0x38
200026d0:	46bd      	mov	sp, r7
200026d2:	bd80      	pop	{r7, pc}

200026d4 <MSS_SPI_enable>:
 */
void MSS_SPI_enable
(
    mss_spi_instance_t * this_spi
)
{
200026d4:	b580      	push	{r7, lr}
200026d6:	b082      	sub	sp, #8
200026d8:	af00      	add	r7, sp, #0
200026da:	6078      	str	r0, [r7, #4]
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
200026dc:	687b      	ldr	r3, [r7, #4]
200026de:	791b      	ldrb	r3, [r3, #4]
200026e0:	b25b      	sxtb	r3, r3
200026e2:	4618      	mov	r0, r3
200026e4:	f7ff fbe8 	bl	20001eb8 <NVIC_DisableIRQ>

    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
200026e8:	687b      	ldr	r3, [r7, #4]
200026ea:	681b      	ldr	r3, [r3, #0]
200026ec:	687a      	ldr	r2, [r7, #4]
200026ee:	6812      	ldr	r2, [r2, #0]
200026f0:	6812      	ldr	r2, [r2, #0]
200026f2:	f042 0201 	orr.w	r2, r2, #1
200026f6:	601a      	str	r2, [r3, #0]
    
    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
200026f8:	687b      	ldr	r3, [r7, #4]
200026fa:	791b      	ldrb	r3, [r3, #4]
200026fc:	b25b      	sxtb	r3, r3
200026fe:	4618      	mov	r0, r3
20002700:	f7ff fbbe 	bl	20001e80 <NVIC_EnableIRQ>
}
20002704:	f107 0708 	add.w	r7, r7, #8
20002708:	46bd      	mov	sp, r7
2000270a:	bd80      	pop	{r7, pc}

2000270c <MSS_SPI_disable>:
 */
void MSS_SPI_disable
(
    mss_spi_instance_t * this_spi
)
{
2000270c:	b580      	push	{r7, lr}
2000270e:	b082      	sub	sp, #8
20002710:	af00      	add	r7, sp, #0
20002712:	6078      	str	r0, [r7, #4]
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
20002714:	687b      	ldr	r3, [r7, #4]
20002716:	791b      	ldrb	r3, [r3, #4]
20002718:	b25b      	sxtb	r3, r3
2000271a:	4618      	mov	r0, r3
2000271c:	f7ff fbcc 	bl	20001eb8 <NVIC_DisableIRQ>

    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
20002720:	687b      	ldr	r3, [r7, #4]
20002722:	681b      	ldr	r3, [r3, #0]
20002724:	687a      	ldr	r2, [r7, #4]
20002726:	6812      	ldr	r2, [r2, #0]
20002728:	6812      	ldr	r2, [r2, #0]
2000272a:	f022 0201 	bic.w	r2, r2, #1
2000272e:	601a      	str	r2, [r3, #0]

    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
20002730:	687b      	ldr	r3, [r7, #4]
20002732:	791b      	ldrb	r3, [r3, #4]
20002734:	b25b      	sxtb	r3, r3
20002736:	4618      	mov	r0, r3
20002738:	f7ff fba2 	bl	20001e80 <NVIC_EnableIRQ>
}
2000273c:	f107 0708 	add.w	r7, r7, #8
20002740:	46bd      	mov	sp, r7
20002742:	bd80      	pop	{r7, pc}

20002744 <MSS_SPI_set_transfer_byte_count>:
void MSS_SPI_set_transfer_byte_count
(
    mss_spi_instance_t * this_spi,
    uint16_t byte_count
)
{
20002744:	b580      	push	{r7, lr}
20002746:	b082      	sub	sp, #8
20002748:	af00      	add	r7, sp, #0
2000274a:	6078      	str	r0, [r7, #4]
2000274c:	460b      	mov	r3, r1
2000274e:	807b      	strh	r3, [r7, #2]
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );
20002750:	687b      	ldr	r3, [r7, #4]
20002752:	791b      	ldrb	r3, [r3, #4]
20002754:	b25b      	sxtb	r3, r3
20002756:	4618      	mov	r0, r3
20002758:	f7ff fbae 	bl	20001eb8 <NVIC_DisableIRQ>

    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK)
2000275c:	687b      	ldr	r3, [r7, #4]
2000275e:	6819      	ldr	r1, [r3, #0]
20002760:	687b      	ldr	r3, [r7, #4]
20002762:	681b      	ldr	r3, [r3, #0]
20002764:	681b      	ldr	r3, [r3, #0]
20002766:	f240 02ff 	movw	r2, #255	; 0xff
2000276a:	f6cf 7200 	movt	r2, #65280	; 0xff00
2000276e:	ea03 0202 	and.w	r2, r3, r2
                                | (((uint32_t)byte_count << TXRXDFCOUNT_SHIFT) & TXRXDFCOUNT_MASK);
20002772:	887b      	ldrh	r3, [r7, #2]
20002774:	ea4f 2003 	mov.w	r0, r3, lsl #8
20002778:	f64f 7300 	movw	r3, #65280	; 0xff00
2000277c:	f2c0 03ff 	movt	r3, #255	; 0xff
20002780:	ea00 0303 	and.w	r3, r0, r3
)
{
    /* Shut down interrupts from the MSS SPI while we do this */
    NVIC_DisableIRQ( this_spi->irqn );

    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK)
20002784:	ea42 0303 	orr.w	r3, r2, r3
20002788:	600b      	str	r3, [r1, #0]
                                | (((uint32_t)byte_count << TXRXDFCOUNT_SHIFT) & TXRXDFCOUNT_MASK);
                                
    /* This value can only be updated when the MSS SPI is disabled */
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
2000278a:	687b      	ldr	r3, [r7, #4]
2000278c:	681b      	ldr	r3, [r3, #0]
2000278e:	687a      	ldr	r2, [r7, #4]
20002790:	6812      	ldr	r2, [r2, #0]
20002792:	6812      	ldr	r2, [r2, #0]
20002794:	f022 0201 	bic.w	r2, r2, #1
20002798:	601a      	str	r2, [r3, #0]
    this_spi->hw_reg->TXRXDF_SIZE = MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE;
2000279a:	687b      	ldr	r3, [r7, #4]
2000279c:	681b      	ldr	r3, [r3, #0]
2000279e:	f04f 0208 	mov.w	r2, #8
200027a2:	605a      	str	r2, [r3, #4]
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
200027a4:	687b      	ldr	r3, [r7, #4]
200027a6:	681b      	ldr	r3, [r3, #0]
200027a8:	687a      	ldr	r2, [r7, #4]
200027aa:	6812      	ldr	r2, [r2, #0]
200027ac:	6812      	ldr	r2, [r2, #0]
200027ae:	f042 0201 	orr.w	r2, r2, #1
200027b2:	601a      	str	r2, [r3, #0]
    /* Reenable interrupts */
    NVIC_EnableIRQ( this_spi->irqn );
200027b4:	687b      	ldr	r3, [r7, #4]
200027b6:	791b      	ldrb	r3, [r3, #4]
200027b8:	b25b      	sxtb	r3, r3
200027ba:	4618      	mov	r0, r3
200027bc:	f7ff fb60 	bl	20001e80 <NVIC_EnableIRQ>
}
200027c0:	f107 0708 	add.w	r7, r7, #8
200027c4:	46bd      	mov	sp, r7
200027c6:	bd80      	pop	{r7, pc}

200027c8 <fill_slave_tx_fifo>:
 */
static void fill_slave_tx_fifo
(
    mss_spi_instance_t * this_spi
)
{
200027c8:	b480      	push	{r7}
200027ca:	b085      	sub	sp, #20
200027cc:	af00      	add	r7, sp, #0
200027ce:	6078      	str	r0, [r7, #4]
    uint32_t guard = 0u;
200027d0:	f04f 0300 	mov.w	r3, #0
200027d4:	60fb      	str	r3, [r7, #12]

    while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
200027d6:	e00e      	b.n	200027f6 <fill_slave_tx_fifo+0x2e>
          (this_spi->slave_tx_idx < this_spi->slave_tx_size))
    {
        /* Sending from primary slave transmit buffer */
        this_spi->hw_reg->TX_DATA = this_spi->slave_tx_buffer[this_spi->slave_tx_idx];
200027d8:	687b      	ldr	r3, [r7, #4]
200027da:	681b      	ldr	r3, [r3, #0]
200027dc:	687a      	ldr	r2, [r7, #4]
200027de:	6891      	ldr	r1, [r2, #8]
200027e0:	687a      	ldr	r2, [r7, #4]
200027e2:	6912      	ldr	r2, [r2, #16]
200027e4:	440a      	add	r2, r1
200027e6:	7812      	ldrb	r2, [r2, #0]
200027e8:	615a      	str	r2, [r3, #20]
        ++this_spi->slave_tx_idx;
200027ea:	687b      	ldr	r3, [r7, #4]
200027ec:	691b      	ldr	r3, [r3, #16]
200027ee:	f103 0201 	add.w	r2, r3, #1
200027f2:	687b      	ldr	r3, [r7, #4]
200027f4:	611a      	str	r2, [r3, #16]
    mss_spi_instance_t * this_spi
)
{
    uint32_t guard = 0u;

    while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
200027f6:	687b      	ldr	r3, [r7, #4]
200027f8:	681b      	ldr	r3, [r3, #0]
200027fa:	689b      	ldr	r3, [r3, #8]
200027fc:	f403 7380 	and.w	r3, r3, #256	; 0x100
20002800:	2b00      	cmp	r3, #0
20002802:	d105      	bne.n	20002810 <fill_slave_tx_fifo+0x48>
          (this_spi->slave_tx_idx < this_spi->slave_tx_size))
20002804:	687b      	ldr	r3, [r7, #4]
20002806:	691a      	ldr	r2, [r3, #16]
20002808:	687b      	ldr	r3, [r7, #4]
2000280a:	68db      	ldr	r3, [r3, #12]
    mss_spi_instance_t * this_spi
)
{
    uint32_t guard = 0u;

    while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
2000280c:	429a      	cmp	r2, r3
2000280e:	d3e3      	bcc.n	200027d8 <fill_slave_tx_fifo+0x10>
        /* Sending from primary slave transmit buffer */
        this_spi->hw_reg->TX_DATA = this_spi->slave_tx_buffer[this_spi->slave_tx_idx];
        ++this_spi->slave_tx_idx;
    }

    if(this_spi->slave_tx_idx >= this_spi->slave_tx_size)
20002810:	687b      	ldr	r3, [r7, #4]
20002812:	691a      	ldr	r2, [r3, #16]
20002814:	687b      	ldr	r3, [r7, #4]
20002816:	68db      	ldr	r3, [r3, #12]
20002818:	429a      	cmp	r2, r3
2000281a:	d31c      	bcc.n	20002856 <fill_slave_tx_fifo+0x8e>
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
2000281c:	e00e      	b.n	2000283c <fill_slave_tx_fifo+0x74>
              (this_spi->resp_buff_tx_idx < this_spi->resp_buff_size))
        {
            /* Sending from command response buffer */
            this_spi->hw_reg->TX_DATA = this_spi->resp_tx_buffer[this_spi->resp_buff_tx_idx];
2000281e:	687b      	ldr	r3, [r7, #4]
20002820:	681b      	ldr	r3, [r3, #0]
20002822:	687a      	ldr	r2, [r7, #4]
20002824:	6951      	ldr	r1, [r2, #20]
20002826:	687a      	ldr	r2, [r7, #4]
20002828:	69d2      	ldr	r2, [r2, #28]
2000282a:	440a      	add	r2, r1
2000282c:	7812      	ldrb	r2, [r2, #0]
2000282e:	615a      	str	r2, [r3, #20]
            ++this_spi->resp_buff_tx_idx;
20002830:	687b      	ldr	r3, [r7, #4]
20002832:	69db      	ldr	r3, [r3, #28]
20002834:	f103 0201 	add.w	r2, r3, #1
20002838:	687b      	ldr	r3, [r7, #4]
2000283a:	61da      	str	r2, [r3, #28]
        ++this_spi->slave_tx_idx;
    }

    if(this_spi->slave_tx_idx >= this_spi->slave_tx_size)
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
2000283c:	687b      	ldr	r3, [r7, #4]
2000283e:	681b      	ldr	r3, [r3, #0]
20002840:	689b      	ldr	r3, [r3, #8]
20002842:	f403 7380 	and.w	r3, r3, #256	; 0x100
20002846:	2b00      	cmp	r3, #0
20002848:	d105      	bne.n	20002856 <fill_slave_tx_fifo+0x8e>
              (this_spi->resp_buff_tx_idx < this_spi->resp_buff_size))
2000284a:	687b      	ldr	r3, [r7, #4]
2000284c:	69da      	ldr	r2, [r3, #28]
2000284e:	687b      	ldr	r3, [r7, #4]
20002850:	699b      	ldr	r3, [r3, #24]
        ++this_spi->slave_tx_idx;
    }

    if(this_spi->slave_tx_idx >= this_spi->slave_tx_size)
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
20002852:	429a      	cmp	r2, r3
20002854:	d3e3      	bcc.n	2000281e <fill_slave_tx_fifo+0x56>
            this_spi->hw_reg->TX_DATA = this_spi->resp_tx_buffer[this_spi->resp_buff_tx_idx];
            ++this_spi->resp_buff_tx_idx;
        }
    }

    if((0u != this_spi->cmd_done) && (this_spi->slave_tx_idx >= this_spi->slave_tx_size) &&
20002856:	687b      	ldr	r3, [r7, #4]
20002858:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000285a:	2b00      	cmp	r3, #0
2000285c:	d01f      	beq.n	2000289e <fill_slave_tx_fifo+0xd6>
2000285e:	687b      	ldr	r3, [r7, #4]
20002860:	691a      	ldr	r2, [r3, #16]
20002862:	687b      	ldr	r3, [r7, #4]
20002864:	68db      	ldr	r3, [r3, #12]
20002866:	429a      	cmp	r2, r3
20002868:	d319      	bcc.n	2000289e <fill_slave_tx_fifo+0xd6>
       (this_spi->resp_buff_tx_idx >= this_spi->resp_buff_size))
2000286a:	687b      	ldr	r3, [r7, #4]
2000286c:	69da      	ldr	r2, [r3, #28]
2000286e:	687b      	ldr	r3, [r7, #4]
20002870:	699b      	ldr	r3, [r3, #24]
            this_spi->hw_reg->TX_DATA = this_spi->resp_tx_buffer[this_spi->resp_buff_tx_idx];
            ++this_spi->resp_buff_tx_idx;
        }
    }

    if((0u != this_spi->cmd_done) && (this_spi->slave_tx_idx >= this_spi->slave_tx_size) &&
20002872:	429a      	cmp	r2, r3
20002874:	d313      	bcc.n	2000289e <fill_slave_tx_fifo+0xd6>
       (this_spi->resp_buff_tx_idx >= this_spi->resp_buff_size))
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
20002876:	e008      	b.n	2000288a <fill_slave_tx_fifo+0xc2>
              (guard < BIG_FIFO_SIZE))
        {
            /* Nothing left so pad with 0s for consistency */
            this_spi->hw_reg->TX_DATA = 0x00u;
20002878:	687b      	ldr	r3, [r7, #4]
2000287a:	681b      	ldr	r3, [r3, #0]
2000287c:	f04f 0200 	mov.w	r2, #0
20002880:	615a      	str	r2, [r3, #20]
             * We use the guard count to cover the unlikely event that we are
             * never seeing the TX FIFO full because the data is being pulled
             * out as fast as we can stuff it in. In this event we never spend
             * more than a full FIFOs worth of time spinning here.
             */
            guard++;
20002882:	68fb      	ldr	r3, [r7, #12]
20002884:	f103 0301 	add.w	r3, r3, #1
20002888:	60fb      	str	r3, [r7, #12]
    }

    if((0u != this_spi->cmd_done) && (this_spi->slave_tx_idx >= this_spi->slave_tx_size) &&
       (this_spi->resp_buff_tx_idx >= this_spi->resp_buff_size))
    {
        while((0u == (this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK)) &&
2000288a:	687b      	ldr	r3, [r7, #4]
2000288c:	681b      	ldr	r3, [r3, #0]
2000288e:	689b      	ldr	r3, [r3, #8]
20002890:	f403 7380 	and.w	r3, r3, #256	; 0x100
20002894:	2b00      	cmp	r3, #0
20002896:	d102      	bne.n	2000289e <fill_slave_tx_fifo+0xd6>
20002898:	68fb      	ldr	r3, [r7, #12]
2000289a:	2b1f      	cmp	r3, #31
2000289c:	d9ec      	bls.n	20002878 <fill_slave_tx_fifo+0xb0>
             */
            guard++;
        }
    }

}
2000289e:	f107 0714 	add.w	r7, r7, #20
200028a2:	46bd      	mov	sp, r7
200028a4:	bc80      	pop	{r7}
200028a6:	4770      	bx	lr

200028a8 <read_slave_rx_fifo>:
 */
static void read_slave_rx_fifo
(
    mss_spi_instance_t * this_spi
)
{
200028a8:	b580      	push	{r7, lr}
200028aa:	b084      	sub	sp, #16
200028ac:	af00      	add	r7, sp, #0
200028ae:	6078      	str	r0, [r7, #4]
    volatile uint32_t rx_frame;
    
    if(MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode)
200028b0:	687b      	ldr	r3, [r7, #4]
200028b2:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
200028b6:	2b02      	cmp	r3, #2
200028b8:	d115      	bne.n	200028e6 <read_slave_rx_fifo+0x3e>
    {
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
200028ba:	e00c      	b.n	200028d6 <read_slave_rx_fifo+0x2e>
        {
            /* Single frame handling mode. */
            rx_frame = this_spi->hw_reg->RX_DATA;
200028bc:	687b      	ldr	r3, [r7, #4]
200028be:	681b      	ldr	r3, [r3, #0]
200028c0:	691b      	ldr	r3, [r3, #16]
200028c2:	60fb      	str	r3, [r7, #12]
            if(0u != this_spi->frame_rx_handler)
200028c4:	687b      	ldr	r3, [r7, #4]
200028c6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
200028c8:	2b00      	cmp	r3, #0
200028ca:	d004      	beq.n	200028d6 <read_slave_rx_fifo+0x2e>
            {
                this_spi->frame_rx_handler( rx_frame );
200028cc:	687b      	ldr	r3, [r7, #4]
200028ce:	6f5b      	ldr	r3, [r3, #116]	; 0x74
200028d0:	68fa      	ldr	r2, [r7, #12]
200028d2:	4610      	mov	r0, r2
200028d4:	4798      	blx	r3
{
    volatile uint32_t rx_frame;
    
    if(MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode)
    {
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
200028d6:	687b      	ldr	r3, [r7, #4]
200028d8:	681b      	ldr	r3, [r3, #0]
200028da:	689b      	ldr	r3, [r3, #8]
200028dc:	f003 0340 	and.w	r3, r3, #64	; 0x40
200028e0:	2b00      	cmp	r3, #0
200028e2:	d0eb      	beq.n	200028bc <read_slave_rx_fifo+0x14>
200028e4:	e032      	b.n	2000294c <read_slave_rx_fifo+0xa4>
            {
                this_spi->frame_rx_handler( rx_frame );
            }
        }
    }
    else if(MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode)
200028e6:	687b      	ldr	r3, [r7, #4]
200028e8:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
200028ec:	2b01      	cmp	r3, #1
200028ee:	d125      	bne.n	2000293c <read_slave_rx_fifo+0x94>
    {
        /* Block handling mode. */
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK)) /* Something needs to be read from FIFO */
200028f0:	e017      	b.n	20002922 <read_slave_rx_fifo+0x7a>
        {
            rx_frame = this_spi->hw_reg->RX_DATA;
200028f2:	687b      	ldr	r3, [r7, #4]
200028f4:	681b      	ldr	r3, [r3, #0]
200028f6:	691b      	ldr	r3, [r3, #16]
200028f8:	60fb      	str	r3, [r7, #12]
            if(this_spi->slave_rx_idx < this_spi->slave_rx_size)
200028fa:	687b      	ldr	r3, [r7, #4]
200028fc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
200028fe:	687b      	ldr	r3, [r7, #4]
20002900:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20002902:	429a      	cmp	r2, r3
20002904:	d207      	bcs.n	20002916 <read_slave_rx_fifo+0x6e>
            {
                this_spi->slave_rx_buffer[this_spi->slave_rx_idx] = (uint8_t)rx_frame;
20002906:	687b      	ldr	r3, [r7, #4]
20002908:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2000290a:	687b      	ldr	r3, [r7, #4]
2000290c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000290e:	4413      	add	r3, r2
20002910:	68fa      	ldr	r2, [r7, #12]
20002912:	b2d2      	uxtb	r2, r2
20002914:	701a      	strb	r2, [r3, #0]
            }

            ++this_spi->slave_rx_idx;
20002916:	687b      	ldr	r3, [r7, #4]
20002918:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000291a:	f103 0201 	add.w	r2, r3, #1
2000291e:	687b      	ldr	r3, [r7, #4]
20002920:	631a      	str	r2, [r3, #48]	; 0x30
        }
    }
    else if(MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode)
    {
        /* Block handling mode. */
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK)) /* Something needs to be read from FIFO */
20002922:	687b      	ldr	r3, [r7, #4]
20002924:	681b      	ldr	r3, [r3, #0]
20002926:	689b      	ldr	r3, [r3, #8]
20002928:	f003 0340 	and.w	r3, r3, #64	; 0x40
2000292c:	2b00      	cmp	r3, #0
2000292e:	d0e0      	beq.n	200028f2 <read_slave_rx_fifo+0x4a>
20002930:	e00c      	b.n	2000294c <read_slave_rx_fifo+0xa4>
    else
    {
        /* Should not happen... Just purge FIFO */
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
        {
            rx_frame = this_spi->hw_reg->RX_DATA;
20002932:	687b      	ldr	r3, [r7, #4]
20002934:	681b      	ldr	r3, [r3, #0]
20002936:	691b      	ldr	r3, [r3, #16]
20002938:	60fb      	str	r3, [r7, #12]
2000293a:	e000      	b.n	2000293e <read_slave_rx_fifo+0x96>
        }
    }
    else
    {
        /* Should not happen... Just purge FIFO */
        while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
2000293c:	bf00      	nop
2000293e:	687b      	ldr	r3, [r7, #4]
20002940:	681b      	ldr	r3, [r3, #0]
20002942:	689b      	ldr	r3, [r3, #8]
20002944:	f003 0340 	and.w	r3, r3, #64	; 0x40
20002948:	2b00      	cmp	r3, #0
2000294a:	d0f2      	beq.n	20002932 <read_slave_rx_fifo+0x8a>
        {
            rx_frame = this_spi->hw_reg->RX_DATA;
        }
    }
}
2000294c:	f107 0710 	add.w	r7, r7, #16
20002950:	46bd      	mov	sp, r7
20002952:	bd80      	pop	{r7, pc}

20002954 <mss_spi_isr>:
 */
static void mss_spi_isr
(
    mss_spi_instance_t * this_spi
)
{    
20002954:	b580      	push	{r7, lr}
20002956:	b086      	sub	sp, #24
20002958:	af00      	add	r7, sp, #0
2000295a:	6078      	str	r0, [r7, #4]
    volatile uint32_t rx_frame;
    __I  uint32_t *this_mis = &this_spi->hw_reg->MIS;
2000295c:	687b      	ldr	r3, [r7, #4]
2000295e:	681b      	ldr	r3, [r3, #0]
20002960:	f103 0320 	add.w	r3, r3, #32
20002964:	613b      	str	r3, [r7, #16]

    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));
20002966:	687a      	ldr	r2, [r7, #4]
20002968:	f244 0370 	movw	r3, #16496	; 0x4070
2000296c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002970:	429a      	cmp	r2, r3
20002972:	d007      	beq.n	20002984 <mss_spi_isr+0x30>
20002974:	687a      	ldr	r2, [r7, #4]
20002976:	f643 73ec 	movw	r3, #16364	; 0x3fec
2000297a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000297e:	429a      	cmp	r2, r3
20002980:	d000      	beq.n	20002984 <mss_spi_isr+0x30>
20002982:	be00      	bkpt	0x0000
  
    if(0u != (*this_mis & RXDONE_IRQ_MASK))
20002984:	693b      	ldr	r3, [r7, #16]
20002986:	681b      	ldr	r3, [r3, #0]
20002988:	f003 0302 	and.w	r3, r3, #2
2000298c:	2b00      	cmp	r3, #0
2000298e:	d052      	beq.n	20002a36 <mss_spi_isr+0xe2>
    {
        if(MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode)
20002990:	687b      	ldr	r3, [r7, #4]
20002992:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
20002996:	2b02      	cmp	r3, #2
20002998:	d115      	bne.n	200029c6 <mss_spi_isr+0x72>
        {
            /* Single frame handling mode. */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
2000299a:	e00c      	b.n	200029b6 <mss_spi_isr+0x62>
            {
                rx_frame = this_spi->hw_reg->RX_DATA;
2000299c:	687b      	ldr	r3, [r7, #4]
2000299e:	681b      	ldr	r3, [r3, #0]
200029a0:	691b      	ldr	r3, [r3, #16]
200029a2:	60fb      	str	r3, [r7, #12]
                if(0u != this_spi->frame_rx_handler)
200029a4:	687b      	ldr	r3, [r7, #4]
200029a6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
200029a8:	2b00      	cmp	r3, #0
200029aa:	d004      	beq.n	200029b6 <mss_spi_isr+0x62>
                {
                    this_spi->frame_rx_handler( rx_frame );
200029ac:	687b      	ldr	r3, [r7, #4]
200029ae:	6f5b      	ldr	r3, [r3, #116]	; 0x74
200029b0:	68fa      	ldr	r2, [r7, #12]
200029b2:	4610      	mov	r0, r2
200029b4:	4798      	blx	r3
    if(0u != (*this_mis & RXDONE_IRQ_MASK))
    {
        if(MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode)
        {
            /* Single frame handling mode. */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
200029b6:	687b      	ldr	r3, [r7, #4]
200029b8:	681b      	ldr	r3, [r3, #0]
200029ba:	689b      	ldr	r3, [r3, #8]
200029bc:	f003 0340 	and.w	r3, r3, #64	; 0x40
200029c0:	2b00      	cmp	r3, #0
200029c2:	d0eb      	beq.n	2000299c <mss_spi_isr+0x48>
200029c4:	e032      	b.n	20002a2c <mss_spi_isr+0xd8>
                {
                    this_spi->frame_rx_handler( rx_frame );
                }
            }
        }
        else if(MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode)
200029c6:	687b      	ldr	r3, [r7, #4]
200029c8:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
200029cc:	2b01      	cmp	r3, #1
200029ce:	d125      	bne.n	20002a1c <mss_spi_isr+0xc8>
        {
            /* Block handling mode. */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK)) /* Something needs to be read from FIFO */
200029d0:	e017      	b.n	20002a02 <mss_spi_isr+0xae>
            {
                rx_frame = this_spi->hw_reg->RX_DATA;                /* Read from FIFO irrespective */
200029d2:	687b      	ldr	r3, [r7, #4]
200029d4:	681b      	ldr	r3, [r3, #0]
200029d6:	691b      	ldr	r3, [r3, #16]
200029d8:	60fb      	str	r3, [r7, #12]
                if(this_spi->slave_rx_idx < this_spi->slave_rx_size) /* Write to array if required */
200029da:	687b      	ldr	r3, [r7, #4]
200029dc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
200029de:	687b      	ldr	r3, [r7, #4]
200029e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200029e2:	429a      	cmp	r2, r3
200029e4:	d207      	bcs.n	200029f6 <mss_spi_isr+0xa2>
                {
                    this_spi->slave_rx_buffer[this_spi->slave_rx_idx] = (uint8_t)rx_frame;
200029e6:	687b      	ldr	r3, [r7, #4]
200029e8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
200029ea:	687b      	ldr	r3, [r7, #4]
200029ec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200029ee:	4413      	add	r3, r2
200029f0:	68fa      	ldr	r2, [r7, #12]
200029f2:	b2d2      	uxtb	r2, r2
200029f4:	701a      	strb	r2, [r3, #0]
                }

                ++this_spi->slave_rx_idx;            
200029f6:	687b      	ldr	r3, [r7, #4]
200029f8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200029fa:	f103 0201 	add.w	r2, r3, #1
200029fe:	687b      	ldr	r3, [r7, #4]
20002a00:	631a      	str	r2, [r3, #48]	; 0x30
            }
        }
        else if(MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode)
        {
            /* Block handling mode. */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK)) /* Something needs to be read from FIFO */
20002a02:	687b      	ldr	r3, [r7, #4]
20002a04:	681b      	ldr	r3, [r3, #0]
20002a06:	689b      	ldr	r3, [r3, #8]
20002a08:	f003 0340 	and.w	r3, r3, #64	; 0x40
20002a0c:	2b00      	cmp	r3, #0
20002a0e:	d0e0      	beq.n	200029d2 <mss_spi_isr+0x7e>
20002a10:	e00c      	b.n	20002a2c <mss_spi_isr+0xd8>
        else
        {
            /* No slave handling in place so just purge FIFO */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
            {
                rx_frame = this_spi->hw_reg->RX_DATA;
20002a12:	687b      	ldr	r3, [r7, #4]
20002a14:	681b      	ldr	r3, [r3, #0]
20002a16:	691b      	ldr	r3, [r3, #16]
20002a18:	60fb      	str	r3, [r7, #12]
20002a1a:	e000      	b.n	20002a1e <mss_spi_isr+0xca>
            }
        }
        else
        {
            /* No slave handling in place so just purge FIFO */
            while(0u == (this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK))
20002a1c:	bf00      	nop
20002a1e:	687b      	ldr	r3, [r7, #4]
20002a20:	681b      	ldr	r3, [r3, #0]
20002a22:	689b      	ldr	r3, [r3, #8]
20002a24:	f003 0340 	and.w	r3, r3, #64	; 0x40
20002a28:	2b00      	cmp	r3, #0
20002a2a:	d0f2      	beq.n	20002a12 <mss_spi_isr+0xbe>
            {
                rx_frame = this_spi->hw_reg->RX_DATA;
            }
        }

        this_spi->hw_reg->INT_CLEAR = RXDONE_IRQ_MASK;
20002a2c:	687b      	ldr	r3, [r7, #4]
20002a2e:	681b      	ldr	r3, [r3, #0]
20002a30:	f04f 0202 	mov.w	r2, #2
20002a34:	60da      	str	r2, [r3, #12]
    }

   /* Handle transmit. */
    if(0u != (*this_mis & TXDONE_IRQ_MASK))
20002a36:	693b      	ldr	r3, [r7, #16]
20002a38:	681b      	ldr	r3, [r3, #0]
20002a3a:	f003 0301 	and.w	r3, r3, #1
20002a3e:	b2db      	uxtb	r3, r3
20002a40:	2b00      	cmp	r3, #0
20002a42:	d012      	beq.n	20002a6a <mss_spi_isr+0x116>
    {
        if( MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode )
20002a44:	687b      	ldr	r3, [r7, #4]
20002a46:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
20002a4a:	2b02      	cmp	r3, #2
20002a4c:	d105      	bne.n	20002a5a <mss_spi_isr+0x106>
        {
           /* Reload slave tx frame into Tx data register. */
            this_spi->hw_reg->TX_DATA = this_spi->slave_tx_frame;
20002a4e:	687b      	ldr	r3, [r7, #4]
20002a50:	681b      	ldr	r3, [r3, #0]
20002a52:	687a      	ldr	r2, [r7, #4]
20002a54:	6f92      	ldr	r2, [r2, #120]	; 0x78
20002a56:	615a      	str	r2, [r3, #20]
20002a58:	e002      	b.n	20002a60 <mss_spi_isr+0x10c>
        }
        else /* Must be block mode so load FIFO to the max */
        {
            fill_slave_tx_fifo(this_spi);
20002a5a:	6878      	ldr	r0, [r7, #4]
20002a5c:	f7ff feb4 	bl	200027c8 <fill_slave_tx_fifo>
        }

        this_spi->hw_reg->INT_CLEAR = TXDONE_IRQ_MASK;
20002a60:	687b      	ldr	r3, [r7, #4]
20002a62:	681b      	ldr	r3, [r3, #0]
20002a64:	f04f 0201 	mov.w	r2, #1
20002a68:	60da      	str	r2, [r3, #12]
    }
    
    /* Handle command interrupt. */
    if(0u != (*this_mis & CMD_IRQ_MASK))
20002a6a:	693b      	ldr	r3, [r7, #16]
20002a6c:	681b      	ldr	r3, [r3, #0]
20002a6e:	f003 0310 	and.w	r3, r3, #16
20002a72:	2b00      	cmp	r3, #0
20002a74:	d023      	beq.n	20002abe <mss_spi_isr+0x16a>
    {
        read_slave_rx_fifo(this_spi);
20002a76:	6878      	ldr	r0, [r7, #4]
20002a78:	f7ff ff16 	bl	200028a8 <read_slave_rx_fifo>
        
        /*
         * Call the command handler if one exists.
         */
        if(0u != this_spi->cmd_handler)
20002a7c:	687b      	ldr	r3, [r7, #4]
20002a7e:	6a1b      	ldr	r3, [r3, #32]
20002a80:	2b00      	cmp	r3, #0
20002a82:	d00b      	beq.n	20002a9c <mss_spi_isr+0x148>
        {
            (*this_spi->cmd_handler)(this_spi->slave_rx_buffer, this_spi->slave_rx_idx);
20002a84:	687b      	ldr	r3, [r7, #4]
20002a86:	6a1b      	ldr	r3, [r3, #32]
20002a88:	687a      	ldr	r2, [r7, #4]
20002a8a:	6a91      	ldr	r1, [r2, #40]	; 0x28
20002a8c:	687a      	ldr	r2, [r7, #4]
20002a8e:	6b12      	ldr	r2, [r2, #48]	; 0x30
20002a90:	4608      	mov	r0, r1
20002a92:	4611      	mov	r1, r2
20002a94:	4798      	blx	r3
            fill_slave_tx_fifo(this_spi);
20002a96:	6878      	ldr	r0, [r7, #4]
20002a98:	f7ff fe96 	bl	200027c8 <fill_slave_tx_fifo>
        }
        /* Set cmd_done to indicate it is now safe to 0 fill TX FIFO */
        this_spi->cmd_done = 1u;
20002a9c:	687b      	ldr	r3, [r7, #4]
20002a9e:	f04f 0201 	mov.w	r2, #1
20002aa2:	625a      	str	r2, [r3, #36]	; 0x24
        /* Disable command interrupt until slave select becomes de-asserted to avoid retriggering. */
        this_spi->hw_reg->CONTROL2 &= ~(uint32_t)C2_ENABLE_CMD_IRQ_MASK;
20002aa4:	687b      	ldr	r3, [r7, #4]
20002aa6:	681b      	ldr	r3, [r3, #0]
20002aa8:	687a      	ldr	r2, [r7, #4]
20002aaa:	6812      	ldr	r2, [r2, #0]
20002aac:	6a92      	ldr	r2, [r2, #40]	; 0x28
20002aae:	f022 0210 	bic.w	r2, r2, #16
20002ab2:	629a      	str	r2, [r3, #40]	; 0x28
        this_spi->hw_reg->INT_CLEAR = CMD_IRQ_MASK;
20002ab4:	687b      	ldr	r3, [r7, #4]
20002ab6:	681b      	ldr	r3, [r3, #0]
20002ab8:	f04f 0210 	mov.w	r2, #16
20002abc:	60da      	str	r2, [r3, #12]
    }

    if(0u != (*this_mis & RXOVFLOW_IRQ_MASK))
20002abe:	693b      	ldr	r3, [r7, #16]
20002ac0:	681b      	ldr	r3, [r3, #0]
20002ac2:	f003 0304 	and.w	r3, r3, #4
20002ac6:	2b00      	cmp	r3, #0
20002ac8:	d00f      	beq.n	20002aea <mss_spi_isr+0x196>
    {
        /*
         * Receive overflow, not a lot we can do for this. Reset the receive
         *  FIFO, clear the interrupt and hope it doesn't happen again...
         */
        this_spi->hw_reg->COMMAND |= RX_FIFO_RESET_MASK;
20002aca:	687b      	ldr	r3, [r7, #4]
20002acc:	681b      	ldr	r3, [r3, #0]
20002ace:	687a      	ldr	r2, [r7, #4]
20002ad0:	6812      	ldr	r2, [r2, #0]
20002ad2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
20002ad4:	f042 0204 	orr.w	r2, r2, #4
20002ad8:	62da      	str	r2, [r3, #44]	; 0x2c
        recover_from_rx_overflow(this_spi);
20002ada:	6878      	ldr	r0, [r7, #4]
20002adc:	f7ff fac2 	bl	20002064 <recover_from_rx_overflow>
        this_spi->hw_reg->INT_CLEAR = RXOVFLOW_IRQ_MASK;
20002ae0:	687b      	ldr	r3, [r7, #4]
20002ae2:	681b      	ldr	r3, [r3, #0]
20002ae4:	f04f 0204 	mov.w	r2, #4
20002ae8:	60da      	str	r2, [r3, #12]
     * slave TX FIFO data setup (if there is one).
     * In block mode this will probably not be very successful as we will
     * be out of synch with the master but the reset on SSEND will hopefully
     * take care of that for the next transfer.
     */
    if(0u != (*this_mis & TXURUN_IRQ_MASK))
20002aea:	693b      	ldr	r3, [r7, #16]
20002aec:	681b      	ldr	r3, [r3, #0]
20002aee:	f003 0308 	and.w	r3, r3, #8
20002af2:	2b00      	cmp	r3, #0
20002af4:	d031      	beq.n	20002b5a <mss_spi_isr+0x206>
    {
        this_spi->hw_reg->COMMAND |= TX_FIFO_RESET_MASK;
20002af6:	687b      	ldr	r3, [r7, #4]
20002af8:	681b      	ldr	r3, [r3, #0]
20002afa:	687a      	ldr	r2, [r7, #4]
20002afc:	6812      	ldr	r2, [r2, #0]
20002afe:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
20002b00:	f042 0208 	orr.w	r2, r2, #8
20002b04:	62da      	str	r2, [r3, #44]	; 0x2c
        if( MSS_SPI_SLAVE_XFER_FRAME == this_spi->slave_xfer_mode )
20002b06:	687b      	ldr	r3, [r7, #4]
20002b08:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
20002b0c:	2b02      	cmp	r3, #2
20002b0e:	d113      	bne.n	20002b38 <mss_spi_isr+0x1e4>
        {
            this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK)
20002b10:	687b      	ldr	r3, [r7, #4]
20002b12:	681a      	ldr	r2, [r3, #0]
20002b14:	687b      	ldr	r3, [r7, #4]
20002b16:	681b      	ldr	r3, [r3, #0]
20002b18:	6819      	ldr	r1, [r3, #0]
20002b1a:	f240 03ff 	movw	r3, #255	; 0xff
20002b1e:	f6cf 7300 	movt	r3, #65280	; 0xff00
20002b22:	ea01 0303 	and.w	r3, r1, r3
20002b26:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20002b2a:	6013      	str	r3, [r2, #0]
                                        | ((uint32_t)1u << TXRXDFCOUNT_SHIFT);
           /* Reload slave tx frame into Tx data register. */
            this_spi->hw_reg->TX_DATA = this_spi->slave_tx_frame;
20002b2c:	687b      	ldr	r3, [r7, #4]
20002b2e:	681b      	ldr	r3, [r3, #0]
20002b30:	687a      	ldr	r2, [r7, #4]
20002b32:	6f92      	ldr	r2, [r2, #120]	; 0x78
20002b34:	615a      	str	r2, [r3, #20]
20002b36:	e00b      	b.n	20002b50 <mss_spi_isr+0x1fc>
        }
        else if( MSS_SPI_SLAVE_XFER_BLOCK == this_spi->slave_xfer_mode )
20002b38:	687b      	ldr	r3, [r7, #4]
20002b3a:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
20002b3e:	2b01      	cmp	r3, #1
20002b40:	d106      	bne.n	20002b50 <mss_spi_isr+0x1fc>
        {
            /* Block mode so reload FIFO to the max */
            this_spi->slave_tx_idx = 0u;
20002b42:	687b      	ldr	r3, [r7, #4]
20002b44:	f04f 0200 	mov.w	r2, #0
20002b48:	611a      	str	r2, [r3, #16]
            fill_slave_tx_fifo(this_spi);
20002b4a:	6878      	ldr	r0, [r7, #4]
20002b4c:	f7ff fe3c 	bl	200027c8 <fill_slave_tx_fifo>
        else
        {
            /* Not frame or block mode? Can't do anything here... */
        }

        this_spi->hw_reg->INT_CLEAR = TXURUN_IRQ_MASK;
20002b50:	687b      	ldr	r3, [r7, #4]
20002b52:	681b      	ldr	r3, [r3, #0]
20002b54:	f04f 0208 	mov.w	r2, #8
20002b58:	60da      	str	r2, [r3, #12]
    /*
     * Handle slave select becoming de-asserted. Only enables if
     * we are operating in block mode, in frame mode we do everything
     * in the receive and transmit interrupt handlers.
     */
    if(0u != (*this_mis & SSEND_IRQ_MASK))
20002b5a:	693b      	ldr	r3, [r7, #16]
20002b5c:	681b      	ldr	r3, [r3, #0]
20002b5e:	f003 0320 	and.w	r3, r3, #32
20002b62:	2b00      	cmp	r3, #0
20002b64:	d049      	beq.n	20002bfa <mss_spi_isr+0x2a6>
    {
        uint32_t rx_size;
        
        read_slave_rx_fifo(this_spi);
20002b66:	6878      	ldr	r0, [r7, #4]
20002b68:	f7ff fe9e 	bl	200028a8 <read_slave_rx_fifo>
        rx_size = this_spi->slave_rx_idx;
20002b6c:	687b      	ldr	r3, [r7, #4]
20002b6e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20002b70:	617b      	str	r3, [r7, #20]
        /*
         * Re-enable command interrupt if required and clear all the response
         * buffer state in readiness for next response. This must be done
         * before reloading the TX FIFO.
         */
        if(0 != this_spi->cmd_handler)
20002b72:	687b      	ldr	r3, [r7, #4]
20002b74:	6a1b      	ldr	r3, [r3, #32]
20002b76:	2b00      	cmp	r3, #0
20002b78:	d01c      	beq.n	20002bb4 <mss_spi_isr+0x260>
        {
            this_spi->cmd_done = 0u;
20002b7a:	687b      	ldr	r3, [r7, #4]
20002b7c:	f04f 0200 	mov.w	r2, #0
20002b80:	625a      	str	r2, [r3, #36]	; 0x24
            this_spi->resp_tx_buffer = 0u;
20002b82:	687b      	ldr	r3, [r7, #4]
20002b84:	f04f 0200 	mov.w	r2, #0
20002b88:	615a      	str	r2, [r3, #20]
            this_spi->resp_buff_size = 0u;
20002b8a:	687b      	ldr	r3, [r7, #4]
20002b8c:	f04f 0200 	mov.w	r2, #0
20002b90:	619a      	str	r2, [r3, #24]
            this_spi->resp_buff_tx_idx = 0u;
20002b92:	687b      	ldr	r3, [r7, #4]
20002b94:	f04f 0200 	mov.w	r2, #0
20002b98:	61da      	str	r2, [r3, #28]
            this_spi->hw_reg->INT_CLEAR = CMD_IRQ_MASK;
20002b9a:	687b      	ldr	r3, [r7, #4]
20002b9c:	681b      	ldr	r3, [r3, #0]
20002b9e:	f04f 0210 	mov.w	r2, #16
20002ba2:	60da      	str	r2, [r3, #12]
            this_spi->hw_reg->CONTROL2 |= C2_ENABLE_CMD_IRQ_MASK;
20002ba4:	687b      	ldr	r3, [r7, #4]
20002ba6:	681b      	ldr	r3, [r3, #0]
20002ba8:	687a      	ldr	r2, [r7, #4]
20002baa:	6812      	ldr	r2, [r2, #0]
20002bac:	6a92      	ldr	r2, [r2, #40]	; 0x28
20002bae:	f042 0210 	orr.w	r2, r2, #16
20002bb2:	629a      	str	r2, [r3, #40]	; 0x28
        /* 
         * Reset the transmit index to 0 to restart transmit at the start of the
         * transmit buffer in the next transaction. This also requires flushing
         * the Tx FIFO and refilling it with the start of Tx data buffer.
         */
        this_spi->slave_tx_idx = 0u;
20002bb4:	687b      	ldr	r3, [r7, #4]
20002bb6:	f04f 0200 	mov.w	r2, #0
20002bba:	611a      	str	r2, [r3, #16]
        this_spi->hw_reg->COMMAND |= (TX_FIFO_RESET_MASK | RX_FIFO_RESET_MASK);
20002bbc:	687b      	ldr	r3, [r7, #4]
20002bbe:	681b      	ldr	r3, [r3, #0]
20002bc0:	687a      	ldr	r2, [r7, #4]
20002bc2:	6812      	ldr	r2, [r2, #0]
20002bc4:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
20002bc6:	f042 020c 	orr.w	r2, r2, #12
20002bca:	62da      	str	r2, [r3, #44]	; 0x2c
        fill_slave_tx_fifo(this_spi);
20002bcc:	6878      	ldr	r0, [r7, #4]
20002bce:	f7ff fdfb 	bl	200027c8 <fill_slave_tx_fifo>
        
        /* Prepare to receive next packet. */
        this_spi->slave_rx_idx = 0u;
20002bd2:	687b      	ldr	r3, [r7, #4]
20002bd4:	f04f 0200 	mov.w	r2, #0
20002bd8:	631a      	str	r2, [r3, #48]	; 0x30
        /*
         * Call the receive handler if one exists.
         */
        if(0u != this_spi->block_rx_handler)
20002bda:	687b      	ldr	r3, [r7, #4]
20002bdc:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
20002bde:	2b00      	cmp	r3, #0
20002be0:	d006      	beq.n	20002bf0 <mss_spi_isr+0x29c>
        {
            (*this_spi->block_rx_handler)(this_spi->slave_rx_buffer, rx_size);
20002be2:	687b      	ldr	r3, [r7, #4]
20002be4:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
20002be6:	687a      	ldr	r2, [r7, #4]
20002be8:	6a92      	ldr	r2, [r2, #40]	; 0x28
20002bea:	4610      	mov	r0, r2
20002bec:	6979      	ldr	r1, [r7, #20]
20002bee:	4798      	blx	r3
        }
        
        this_spi->hw_reg->INT_CLEAR = SSEND_IRQ_MASK;
20002bf0:	687b      	ldr	r3, [r7, #4]
20002bf2:	681b      	ldr	r3, [r3, #0]
20002bf4:	f04f 0220 	mov.w	r2, #32
20002bf8:	60da      	str	r2, [r3, #12]
    }
}
20002bfa:	f107 0718 	add.w	r7, r7, #24
20002bfe:	46bd      	mov	sp, r7
20002c00:	bd80      	pop	{r7, pc}
20002c02:	bf00      	nop

20002c04 <SPI0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void SPI0_IRQHandler(void)
#else
void SPI0_IRQHandler( void )
#endif
{
20002c04:	4668      	mov	r0, sp
20002c06:	f020 0107 	bic.w	r1, r0, #7
20002c0a:	468d      	mov	sp, r1
20002c0c:	b589      	push	{r0, r3, r7, lr}
20002c0e:	af00      	add	r7, sp, #0
    mss_spi_isr(&g_mss_spi0);
20002c10:	f244 0070 	movw	r0, #16496	; 0x4070
20002c14:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002c18:	f7ff fe9c 	bl	20002954 <mss_spi_isr>
}
20002c1c:	46bd      	mov	sp, r7
20002c1e:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
20002c22:	4685      	mov	sp, r0
20002c24:	4770      	bx	lr
20002c26:	bf00      	nop

20002c28 <SPI1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void SPI1_IRQHandler(void)
#else
void SPI1_IRQHandler(void)
#endif
{
20002c28:	4668      	mov	r0, sp
20002c2a:	f020 0107 	bic.w	r1, r0, #7
20002c2e:	468d      	mov	sp, r1
20002c30:	b589      	push	{r0, r3, r7, lr}
20002c32:	af00      	add	r7, sp, #0
    mss_spi_isr(&g_mss_spi1);
20002c34:	f643 70ec 	movw	r0, #16364	; 0x3fec
20002c38:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002c3c:	f7ff fe8a 	bl	20002954 <mss_spi_isr>
}
20002c40:	46bd      	mov	sp, r7
20002c42:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
20002c46:	4685      	mov	sp, r0
20002c48:	4770      	bx	lr
20002c4a:	bf00      	nop

20002c4c <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
20002c4c:	b480      	push	{r7}
20002c4e:	b083      	sub	sp, #12
20002c50:	af00      	add	r7, sp, #0
20002c52:	4603      	mov	r3, r0
20002c54:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
20002c56:	f24e 1300 	movw	r3, #57600	; 0xe100
20002c5a:	f2ce 0300 	movt	r3, #57344	; 0xe000
20002c5e:	f997 2007 	ldrsb.w	r2, [r7, #7]
20002c62:	ea4f 1252 	mov.w	r2, r2, lsr #5
20002c66:	79f9      	ldrb	r1, [r7, #7]
20002c68:	f001 011f 	and.w	r1, r1, #31
20002c6c:	f04f 0001 	mov.w	r0, #1
20002c70:	fa00 f101 	lsl.w	r1, r0, r1
20002c74:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20002c78:	f107 070c 	add.w	r7, r7, #12
20002c7c:	46bd      	mov	sp, r7
20002c7e:	bc80      	pop	{r7}
20002c80:	4770      	bx	lr
20002c82:	bf00      	nop

20002c84 <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
20002c84:	b480      	push	{r7}
20002c86:	b083      	sub	sp, #12
20002c88:	af00      	add	r7, sp, #0
20002c8a:	4603      	mov	r3, r0
20002c8c:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
20002c8e:	f24e 1300 	movw	r3, #57600	; 0xe100
20002c92:	f2ce 0300 	movt	r3, #57344	; 0xe000
20002c96:	f997 2007 	ldrsb.w	r2, [r7, #7]
20002c9a:	ea4f 1252 	mov.w	r2, r2, lsr #5
20002c9e:	79f9      	ldrb	r1, [r7, #7]
20002ca0:	f001 011f 	and.w	r1, r1, #31
20002ca4:	f04f 0001 	mov.w	r0, #1
20002ca8:	fa00 f101 	lsl.w	r1, r0, r1
20002cac:	f102 0260 	add.w	r2, r2, #96	; 0x60
20002cb0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20002cb4:	f107 070c 	add.w	r7, r7, #12
20002cb8:	46bd      	mov	sp, r7
20002cba:	bc80      	pop	{r7}
20002cbc:	4770      	bx	lr
20002cbe:	bf00      	nop

20002cc0 <PDMA_init>:

/***************************************************************************//**
 * See mss_pdma.h for description of this function.
 */
void PDMA_init(void)
{
20002cc0:	b580      	push	{r7, lr}
20002cc2:	b082      	sub	sp, #8
20002cc4:	af00      	add	r7, sp, #0
    int32_t i;
    
    /* Reset PDMA block. */
    SYSREG->SOFT_RST_CR |= PDMA_SOFT_RESET;
20002cc6:	f248 0300 	movw	r3, #32768	; 0x8000
20002cca:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002cce:	f248 0200 	movw	r2, #32768	; 0x8000
20002cd2:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002cd6:	6c92      	ldr	r2, [r2, #72]	; 0x48
20002cd8:	f042 0220 	orr.w	r2, r2, #32
20002cdc:	649a      	str	r2, [r3, #72]	; 0x48
    
    /* Clear any previously pended MSS PDMA interrupt */
    NVIC_ClearPendingIRQ(DMA_IRQn);
20002cde:	f04f 000d 	mov.w	r0, #13
20002ce2:	f7ff ffcf 	bl	20002c84 <NVIC_ClearPendingIRQ>
        
    /* Take PDMA controller out of reset*/
    SYSREG->SOFT_RST_CR &= ~PDMA_SOFT_RESET;
20002ce6:	f248 0300 	movw	r3, #32768	; 0x8000
20002cea:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002cee:	f248 0200 	movw	r2, #32768	; 0x8000
20002cf2:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002cf6:	6c92      	ldr	r2, [r2, #72]	; 0x48
20002cf8:	f022 0220 	bic.w	r2, r2, #32
20002cfc:	649a      	str	r2, [r3, #72]	; 0x48
    
    /* Initialize channels state information. */
    for(i = 0; i < NB_OF_PDMA_CHANNELS; ++i)
20002cfe:	f04f 0300 	mov.w	r3, #0
20002d02:	607b      	str	r3, [r7, #4]
20002d04:	e024      	b.n	20002d50 <PDMA_init+0x90>
    {
        g_pdma_next_channel[i] = NEXT_CHANNEL_A;
20002d06:	687a      	ldr	r2, [r7, #4]
20002d08:	f643 736c 	movw	r3, #16236	; 0x3f6c
20002d0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002d10:	f04f 0100 	mov.w	r1, #0
20002d14:	5499      	strb	r1, [r3, r2]
        g_pdma_started_a[i] = CHANNEL_STOPPED;
20002d16:	687a      	ldr	r2, [r7, #4]
20002d18:	f643 7374 	movw	r3, #16244	; 0x3f74
20002d1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002d20:	f04f 0100 	mov.w	r1, #0
20002d24:	5499      	strb	r1, [r3, r2]
        g_pdma_started_b[i] = CHANNEL_STOPPED;
20002d26:	687a      	ldr	r2, [r7, #4]
20002d28:	f643 737c 	movw	r3, #16252	; 0x3f7c
20002d2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002d30:	f04f 0100 	mov.w	r1, #0
20002d34:	5499      	strb	r1, [r3, r2]
        g_pdma_isr_table[i] = 0;
20002d36:	687a      	ldr	r2, [r7, #4]
20002d38:	f643 7384 	movw	r3, #16260	; 0x3f84
20002d3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002d40:	f04f 0100 	mov.w	r1, #0
20002d44:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        
    /* Take PDMA controller out of reset*/
    SYSREG->SOFT_RST_CR &= ~PDMA_SOFT_RESET;
    
    /* Initialize channels state information. */
    for(i = 0; i < NB_OF_PDMA_CHANNELS; ++i)
20002d48:	687b      	ldr	r3, [r7, #4]
20002d4a:	f103 0301 	add.w	r3, r3, #1
20002d4e:	607b      	str	r3, [r7, #4]
20002d50:	687b      	ldr	r3, [r7, #4]
20002d52:	2b07      	cmp	r3, #7
20002d54:	ddd7      	ble.n	20002d06 <PDMA_init+0x46>
        g_pdma_next_channel[i] = NEXT_CHANNEL_A;
        g_pdma_started_a[i] = CHANNEL_STOPPED;
        g_pdma_started_b[i] = CHANNEL_STOPPED;
        g_pdma_isr_table[i] = 0;
    }
}
20002d56:	f107 0708 	add.w	r7, r7, #8
20002d5a:	46bd      	mov	sp, r7
20002d5c:	bd80      	pop	{r7, pc}
20002d5e:	bf00      	nop

20002d60 <PDMA_configure>:
    pdma_channel_id_t channel_id,
    pdma_src_dest_t src_dest,
    uint32_t channel_cfg,
    uint8_t write_adjust
)
{
20002d60:	b580      	push	{r7, lr}
20002d62:	b098      	sub	sp, #96	; 0x60
20002d64:	af00      	add	r7, sp, #0
20002d66:	60ba      	str	r2, [r7, #8]
20002d68:	4602      	mov	r2, r0
20002d6a:	73fa      	strb	r2, [r7, #15]
20002d6c:	460a      	mov	r2, r1
20002d6e:	73ba      	strb	r2, [r7, #14]
20002d70:	71fb      	strb	r3, [r7, #7]
        CHANNEL_N_CTRL_PDMA_MASK | ( (uint32_t)12 << CHANNEL_N_PERIPH_SELECT_SHIFT) | CHANNEL_N_DIRECTION_MASK, /* PDMA_TO_FIC_1_DMAREADY_1 */
        CHANNEL_N_CTRL_PDMA_MASK | ( (uint32_t)13 << CHANNEL_N_PERIPH_SELECT_SHIFT),                            /* PDMA_FROM_FIC_1_DMAREADY_0 */
        CHANNEL_N_CTRL_PDMA_MASK | ( (uint32_t)13 << CHANNEL_N_PERIPH_SELECT_SHIFT) | CHANNEL_N_DIRECTION_MASK, /* PDMA_TO_FIC_1_DMAREADY_0 */
        CHANNEL_N_CTRL_PDMA_MASK | ( (uint32_t)14 << CHANNEL_N_PERIPH_SELECT_SHIFT),                            /* PDMA_FROM_COMBLK */
        CHANNEL_N_CTRL_PDMA_MASK | ( (uint32_t)15 << CHANNEL_N_PERIPH_SELECT_SHIFT) | CHANNEL_N_DIRECTION_MASK  /* PDMA_TO_COMBLK */
    };
20002d72:	f643 3380 	movw	r3, #15232	; 0x3b80
20002d76:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002d7a:	f107 0110 	add.w	r1, r7, #16
20002d7e:	461a      	mov	r2, r3
20002d80:	f04f 0350 	mov.w	r3, #80	; 0x50
20002d84:	4608      	mov	r0, r1
20002d86:	4611      	mov	r1, r2
20002d88:	461a      	mov	r2, r3
20002d8a:	f000 fdbf 	bl	2000390c <memcpy>
    
    /* Reset the channel. */
    PDMA->CHANNEL[channel_id].CRTL |= CHANNEL_RESET_MASK;
20002d8e:	f243 0300 	movw	r3, #12288	; 0x3000
20002d92:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002d96:	7bf9      	ldrb	r1, [r7, #15]
20002d98:	f243 0200 	movw	r2, #12288	; 0x3000
20002d9c:	f2c4 0200 	movt	r2, #16384	; 0x4000
20002da0:	7bf8      	ldrb	r0, [r7, #15]
20002da2:	f100 0001 	add.w	r0, r0, #1
20002da6:	ea4f 1040 	mov.w	r0, r0, lsl #5
20002daa:	4402      	add	r2, r0
20002dac:	6812      	ldr	r2, [r2, #0]
20002dae:	f042 0220 	orr.w	r2, r2, #32
20002db2:	f101 0101 	add.w	r1, r1, #1
20002db6:	ea4f 1141 	mov.w	r1, r1, lsl #5
20002dba:	440b      	add	r3, r1
20002dbc:	601a      	str	r2, [r3, #0]
    PDMA->CHANNEL[channel_id].CRTL &= ~CHANNEL_RESET_MASK;
20002dbe:	f243 0300 	movw	r3, #12288	; 0x3000
20002dc2:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002dc6:	7bf9      	ldrb	r1, [r7, #15]
20002dc8:	f243 0200 	movw	r2, #12288	; 0x3000
20002dcc:	f2c4 0200 	movt	r2, #16384	; 0x4000
20002dd0:	7bf8      	ldrb	r0, [r7, #15]
20002dd2:	f100 0001 	add.w	r0, r0, #1
20002dd6:	ea4f 1040 	mov.w	r0, r0, lsl #5
20002dda:	4402      	add	r2, r0
20002ddc:	6812      	ldr	r2, [r2, #0]
20002dde:	f022 0220 	bic.w	r2, r2, #32
20002de2:	f101 0101 	add.w	r1, r1, #1
20002de6:	ea4f 1141 	mov.w	r1, r1, lsl #5
20002dea:	440b      	add	r3, r1
20002dec:	601a      	str	r2, [r3, #0]

    /* Configure PDMA channel's data source and destination. */
    if(src_dest != PDMA_MEM_TO_MEM)
20002dee:	7bbb      	ldrb	r3, [r7, #14]
20002df0:	2b14      	cmp	r3, #20
20002df2:	d01f      	beq.n	20002e34 <PDMA_configure+0xd4>
    {
        PDMA->CHANNEL[channel_id].CRTL |= src_dest_to_ctrl_reg_lut[src_dest];
20002df4:	f243 0300 	movw	r3, #12288	; 0x3000
20002df8:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002dfc:	7bf9      	ldrb	r1, [r7, #15]
20002dfe:	f243 0200 	movw	r2, #12288	; 0x3000
20002e02:	f2c4 0200 	movt	r2, #16384	; 0x4000
20002e06:	7bf8      	ldrb	r0, [r7, #15]
20002e08:	f100 0001 	add.w	r0, r0, #1
20002e0c:	ea4f 1040 	mov.w	r0, r0, lsl #5
20002e10:	4402      	add	r2, r0
20002e12:	6810      	ldr	r0, [r2, #0]
20002e14:	7bba      	ldrb	r2, [r7, #14]
20002e16:	ea4f 0282 	mov.w	r2, r2, lsl #2
20002e1a:	f107 0c60 	add.w	ip, r7, #96	; 0x60
20002e1e:	4462      	add	r2, ip
20002e20:	f852 2c50 	ldr.w	r2, [r2, #-80]
20002e24:	ea40 0202 	orr.w	r2, r0, r2
20002e28:	f101 0101 	add.w	r1, r1, #1
20002e2c:	ea4f 1141 	mov.w	r1, r1, lsl #5
20002e30:	440b      	add	r3, r1
20002e32:	601a      	str	r2, [r3, #0]
    }
    
    /* Configure PDMA channel trnasfer size, priority, source and destination address increment. */
    PDMA->CHANNEL[channel_id].CRTL |= channel_cfg;
20002e34:	f243 0300 	movw	r3, #12288	; 0x3000
20002e38:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002e3c:	7bf9      	ldrb	r1, [r7, #15]
20002e3e:	f243 0200 	movw	r2, #12288	; 0x3000
20002e42:	f2c4 0200 	movt	r2, #16384	; 0x4000
20002e46:	7bf8      	ldrb	r0, [r7, #15]
20002e48:	f100 0001 	add.w	r0, r0, #1
20002e4c:	ea4f 1040 	mov.w	r0, r0, lsl #5
20002e50:	4402      	add	r2, r0
20002e52:	6810      	ldr	r0, [r2, #0]
20002e54:	68ba      	ldr	r2, [r7, #8]
20002e56:	ea40 0202 	orr.w	r2, r0, r2
20002e5a:	f101 0101 	add.w	r1, r1, #1
20002e5e:	ea4f 1141 	mov.w	r1, r1, lsl #5
20002e62:	440b      	add	r3, r1
20002e64:	601a      	str	r2, [r3, #0]

    /* Posted write adjust. */
    PDMA->CHANNEL[channel_id].CRTL |= ((uint32_t)write_adjust << CHAN_POSTED_WRITE_ADJUST_SHIFT);
20002e66:	f243 0300 	movw	r3, #12288	; 0x3000
20002e6a:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002e6e:	7bf9      	ldrb	r1, [r7, #15]
20002e70:	f243 0200 	movw	r2, #12288	; 0x3000
20002e74:	f2c4 0200 	movt	r2, #16384	; 0x4000
20002e78:	7bf8      	ldrb	r0, [r7, #15]
20002e7a:	f100 0001 	add.w	r0, r0, #1
20002e7e:	ea4f 1040 	mov.w	r0, r0, lsl #5
20002e82:	4402      	add	r2, r0
20002e84:	6810      	ldr	r0, [r2, #0]
20002e86:	79fa      	ldrb	r2, [r7, #7]
20002e88:	ea4f 3282 	mov.w	r2, r2, lsl #14
20002e8c:	ea40 0202 	orr.w	r2, r0, r2
20002e90:	f101 0101 	add.w	r1, r1, #1
20002e94:	ea4f 1141 	mov.w	r1, r1, lsl #5
20002e98:	440b      	add	r3, r1
20002e9a:	601a      	str	r2, [r3, #0]
}
20002e9c:	f107 0760 	add.w	r7, r7, #96	; 0x60
20002ea0:	46bd      	mov	sp, r7
20002ea2:	bd80      	pop	{r7, pc}

20002ea4 <PDMA_start>:
    pdma_channel_id_t channel_id,
    uint32_t src_addr,
    uint32_t dest_addr,
    uint16_t transfer_count
)
{
20002ea4:	b480      	push	{r7}
20002ea6:	b085      	sub	sp, #20
20002ea8:	af00      	add	r7, sp, #0
20002eaa:	60b9      	str	r1, [r7, #8]
20002eac:	607a      	str	r2, [r7, #4]
20002eae:	4602      	mov	r2, r0
20002eb0:	73fa      	strb	r2, [r7, #15]
20002eb2:	807b      	strh	r3, [r7, #2]
    /* Pause transfer. */
    PDMA->CHANNEL[channel_id].CRTL |= PAUSE_MASK;
20002eb4:	f243 0300 	movw	r3, #12288	; 0x3000
20002eb8:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002ebc:	7bf9      	ldrb	r1, [r7, #15]
20002ebe:	f243 0200 	movw	r2, #12288	; 0x3000
20002ec2:	f2c4 0200 	movt	r2, #16384	; 0x4000
20002ec6:	7bf8      	ldrb	r0, [r7, #15]
20002ec8:	f100 0001 	add.w	r0, r0, #1
20002ecc:	ea4f 1040 	mov.w	r0, r0, lsl #5
20002ed0:	4402      	add	r2, r0
20002ed2:	6812      	ldr	r2, [r2, #0]
20002ed4:	f042 0210 	orr.w	r2, r2, #16
20002ed8:	f101 0101 	add.w	r1, r1, #1
20002edc:	ea4f 1141 	mov.w	r1, r1, lsl #5
20002ee0:	440b      	add	r3, r1
20002ee2:	601a      	str	r2, [r3, #0]
    
    /* Clear complete transfers. */
    if(PDMA->CHANNEL[channel_id].STATUS & PORT_A_COMPLETE_MASK)
20002ee4:	f243 0300 	movw	r3, #12288	; 0x3000
20002ee8:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002eec:	7bfa      	ldrb	r2, [r7, #15]
20002eee:	f102 0201 	add.w	r2, r2, #1
20002ef2:	ea4f 1242 	mov.w	r2, r2, lsl #5
20002ef6:	4413      	add	r3, r2
20002ef8:	f103 0304 	add.w	r3, r3, #4
20002efc:	681b      	ldr	r3, [r3, #0]
20002efe:	f003 0301 	and.w	r3, r3, #1
20002f02:	b2db      	uxtb	r3, r3
20002f04:	2b00      	cmp	r3, #0
20002f06:	d01f      	beq.n	20002f48 <PDMA_start+0xa4>
    {
        PDMA->CHANNEL[channel_id].CRTL |= CLEAR_PORT_A_DONE_MASK;
20002f08:	f243 0300 	movw	r3, #12288	; 0x3000
20002f0c:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002f10:	7bf9      	ldrb	r1, [r7, #15]
20002f12:	f243 0200 	movw	r2, #12288	; 0x3000
20002f16:	f2c4 0200 	movt	r2, #16384	; 0x4000
20002f1a:	7bf8      	ldrb	r0, [r7, #15]
20002f1c:	f100 0001 	add.w	r0, r0, #1
20002f20:	ea4f 1040 	mov.w	r0, r0, lsl #5
20002f24:	4402      	add	r2, r0
20002f26:	6812      	ldr	r2, [r2, #0]
20002f28:	f042 0280 	orr.w	r2, r2, #128	; 0x80
20002f2c:	f101 0101 	add.w	r1, r1, #1
20002f30:	ea4f 1141 	mov.w	r1, r1, lsl #5
20002f34:	440b      	add	r3, r1
20002f36:	601a      	str	r2, [r3, #0]
        g_pdma_started_a[channel_id] = CHANNEL_STOPPED;
20002f38:	7bfa      	ldrb	r2, [r7, #15]
20002f3a:	f643 7374 	movw	r3, #16244	; 0x3f74
20002f3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002f42:	f04f 0100 	mov.w	r1, #0
20002f46:	5499      	strb	r1, [r3, r2]
    }
    if(PDMA->CHANNEL[channel_id].STATUS & PORT_B_COMPLETE_MASK)
20002f48:	f243 0300 	movw	r3, #12288	; 0x3000
20002f4c:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002f50:	7bfa      	ldrb	r2, [r7, #15]
20002f52:	f102 0201 	add.w	r2, r2, #1
20002f56:	ea4f 1242 	mov.w	r2, r2, lsl #5
20002f5a:	4413      	add	r3, r2
20002f5c:	f103 0304 	add.w	r3, r3, #4
20002f60:	681b      	ldr	r3, [r3, #0]
20002f62:	f003 0302 	and.w	r3, r3, #2
20002f66:	2b00      	cmp	r3, #0
20002f68:	d01f      	beq.n	20002faa <PDMA_start+0x106>
    {
        PDMA->CHANNEL[channel_id].CRTL |= CLEAR_PORT_B_DONE_MASK;
20002f6a:	f243 0300 	movw	r3, #12288	; 0x3000
20002f6e:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002f72:	7bf9      	ldrb	r1, [r7, #15]
20002f74:	f243 0200 	movw	r2, #12288	; 0x3000
20002f78:	f2c4 0200 	movt	r2, #16384	; 0x4000
20002f7c:	7bf8      	ldrb	r0, [r7, #15]
20002f7e:	f100 0001 	add.w	r0, r0, #1
20002f82:	ea4f 1040 	mov.w	r0, r0, lsl #5
20002f86:	4402      	add	r2, r0
20002f88:	6812      	ldr	r2, [r2, #0]
20002f8a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
20002f8e:	f101 0101 	add.w	r1, r1, #1
20002f92:	ea4f 1141 	mov.w	r1, r1, lsl #5
20002f96:	440b      	add	r3, r1
20002f98:	601a      	str	r2, [r3, #0]
        g_pdma_started_b[channel_id] = CHANNEL_STOPPED;
20002f9a:	7bfa      	ldrb	r2, [r7, #15]
20002f9c:	f643 737c 	movw	r3, #16252	; 0x3f7c
20002fa0:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002fa4:	f04f 0100 	mov.w	r1, #0
20002fa8:	5499      	strb	r1, [r3, r2]
    }
    
    /* Load source, destination and transfer count. */
    if(PDMA->CHANNEL[channel_id].STATUS & BUFFER_B_SELECT_MASK)
20002faa:	f243 0300 	movw	r3, #12288	; 0x3000
20002fae:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002fb2:	7bfa      	ldrb	r2, [r7, #15]
20002fb4:	f102 0201 	add.w	r2, r2, #1
20002fb8:	ea4f 1242 	mov.w	r2, r2, lsl #5
20002fbc:	4413      	add	r3, r2
20002fbe:	f103 0304 	add.w	r3, r3, #4
20002fc2:	681b      	ldr	r3, [r3, #0]
20002fc4:	f003 0304 	and.w	r3, r3, #4
20002fc8:	2b00      	cmp	r3, #0
20002fca:	d034      	beq.n	20003036 <PDMA_start+0x192>
    {
        g_pdma_next_channel[channel_id] = NEXT_CHANNEL_A;
20002fcc:	7bfa      	ldrb	r2, [r7, #15]
20002fce:	f643 736c 	movw	r3, #16236	; 0x3f6c
20002fd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002fd6:	f04f 0100 	mov.w	r1, #0
20002fda:	5499      	strb	r1, [r3, r2]
        g_pdma_started_b[channel_id] = CHANNEL_STARTED;
20002fdc:	7bfa      	ldrb	r2, [r7, #15]
20002fde:	f643 737c 	movw	r3, #16252	; 0x3f7c
20002fe2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002fe6:	f04f 0101 	mov.w	r1, #1
20002fea:	5499      	strb	r1, [r3, r2]
        
        PDMA->CHANNEL[channel_id].BUFFER_B_SRC_ADDR = src_addr;
20002fec:	f243 0300 	movw	r3, #12288	; 0x3000
20002ff0:	f2c4 0300 	movt	r3, #16384	; 0x4000
20002ff4:	7bfa      	ldrb	r2, [r7, #15]
20002ff6:	ea4f 1242 	mov.w	r2, r2, lsl #5
20002ffa:	4413      	add	r3, r2
20002ffc:	f103 0334 	add.w	r3, r3, #52	; 0x34
20003000:	68ba      	ldr	r2, [r7, #8]
20003002:	601a      	str	r2, [r3, #0]
        PDMA->CHANNEL[channel_id].BUFFER_B_DEST_ADDR = dest_addr;
20003004:	f243 0300 	movw	r3, #12288	; 0x3000
20003008:	f2c4 0300 	movt	r3, #16384	; 0x4000
2000300c:	7bfa      	ldrb	r2, [r7, #15]
2000300e:	ea4f 1242 	mov.w	r2, r2, lsl #5
20003012:	4413      	add	r3, r2
20003014:	f103 0338 	add.w	r3, r3, #56	; 0x38
20003018:	687a      	ldr	r2, [r7, #4]
2000301a:	601a      	str	r2, [r3, #0]
        PDMA->CHANNEL[channel_id].BUFFER_B_TRANSFER_COUNT = transfer_count;
2000301c:	f243 0300 	movw	r3, #12288	; 0x3000
20003020:	f2c4 0300 	movt	r3, #16384	; 0x4000
20003024:	7bf9      	ldrb	r1, [r7, #15]
20003026:	887a      	ldrh	r2, [r7, #2]
20003028:	ea4f 1141 	mov.w	r1, r1, lsl #5
2000302c:	440b      	add	r3, r1
2000302e:	f103 033c 	add.w	r3, r3, #60	; 0x3c
20003032:	601a      	str	r2, [r3, #0]
20003034:	e033      	b.n	2000309e <PDMA_start+0x1fa>
    }
    else
    {
        g_pdma_next_channel[channel_id] = NEXT_CHANNEL_B;
20003036:	7bfa      	ldrb	r2, [r7, #15]
20003038:	f643 736c 	movw	r3, #16236	; 0x3f6c
2000303c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003040:	f04f 0101 	mov.w	r1, #1
20003044:	5499      	strb	r1, [r3, r2]
        g_pdma_started_a[channel_id] = CHANNEL_STARTED;
20003046:	7bfa      	ldrb	r2, [r7, #15]
20003048:	f643 7374 	movw	r3, #16244	; 0x3f74
2000304c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003050:	f04f 0101 	mov.w	r1, #1
20003054:	5499      	strb	r1, [r3, r2]
        
        PDMA->CHANNEL[channel_id].BUFFER_A_SRC_ADDR = src_addr;
20003056:	f243 0300 	movw	r3, #12288	; 0x3000
2000305a:	f2c4 0300 	movt	r3, #16384	; 0x4000
2000305e:	7bfa      	ldrb	r2, [r7, #15]
20003060:	ea4f 1242 	mov.w	r2, r2, lsl #5
20003064:	4413      	add	r3, r2
20003066:	f103 0328 	add.w	r3, r3, #40	; 0x28
2000306a:	68ba      	ldr	r2, [r7, #8]
2000306c:	601a      	str	r2, [r3, #0]
        PDMA->CHANNEL[channel_id].BUFFER_A_DEST_ADDR = dest_addr;
2000306e:	f243 0300 	movw	r3, #12288	; 0x3000
20003072:	f2c4 0300 	movt	r3, #16384	; 0x4000
20003076:	7bfa      	ldrb	r2, [r7, #15]
20003078:	ea4f 1242 	mov.w	r2, r2, lsl #5
2000307c:	4413      	add	r3, r2
2000307e:	f103 032c 	add.w	r3, r3, #44	; 0x2c
20003082:	687a      	ldr	r2, [r7, #4]
20003084:	601a      	str	r2, [r3, #0]
        PDMA->CHANNEL[channel_id].BUFFER_A_TRANSFER_COUNT = transfer_count;
20003086:	f243 0300 	movw	r3, #12288	; 0x3000
2000308a:	f2c4 0300 	movt	r3, #16384	; 0x4000
2000308e:	7bf9      	ldrb	r1, [r7, #15]
20003090:	887a      	ldrh	r2, [r7, #2]
20003092:	ea4f 1141 	mov.w	r1, r1, lsl #5
20003096:	440b      	add	r3, r1
20003098:	f103 0330 	add.w	r3, r3, #48	; 0x30
2000309c:	601a      	str	r2, [r3, #0]
    }
    
    /* Start transfer */
    PDMA->CHANNEL[channel_id].CRTL &= ~PAUSE_MASK;
2000309e:	f243 0300 	movw	r3, #12288	; 0x3000
200030a2:	f2c4 0300 	movt	r3, #16384	; 0x4000
200030a6:	7bf9      	ldrb	r1, [r7, #15]
200030a8:	f243 0200 	movw	r2, #12288	; 0x3000
200030ac:	f2c4 0200 	movt	r2, #16384	; 0x4000
200030b0:	7bf8      	ldrb	r0, [r7, #15]
200030b2:	f100 0001 	add.w	r0, r0, #1
200030b6:	ea4f 1040 	mov.w	r0, r0, lsl #5
200030ba:	4402      	add	r2, r0
200030bc:	6812      	ldr	r2, [r2, #0]
200030be:	f022 0210 	bic.w	r2, r2, #16
200030c2:	f101 0101 	add.w	r1, r1, #1
200030c6:	ea4f 1141 	mov.w	r1, r1, lsl #5
200030ca:	440b      	add	r3, r1
200030cc:	601a      	str	r2, [r3, #0]
}
200030ce:	f107 0714 	add.w	r7, r7, #20
200030d2:	46bd      	mov	sp, r7
200030d4:	bc80      	pop	{r7}
200030d6:	4770      	bx	lr

200030d8 <get_channel_id_from_status>:

static pdma_channel_id_t get_channel_id_from_status
(
    uint16_t status
)
{
200030d8:	b480      	push	{r7}
200030da:	b085      	sub	sp, #20
200030dc:	af00      	add	r7, sp, #0
200030de:	4603      	mov	r3, r0
200030e0:	80fb      	strh	r3, [r7, #6]
    pdma_channel_id_t channel_id = PDMA_CHANNEL_0;
200030e2:	f04f 0300 	mov.w	r3, #0
200030e6:	73fb      	strb	r3, [r7, #15]
    
    if(status & CHANNEL_0_STATUS_BITS_MASK)
200030e8:	88fb      	ldrh	r3, [r7, #6]
200030ea:	f003 0303 	and.w	r3, r3, #3
200030ee:	2b00      	cmp	r3, #0
200030f0:	d003      	beq.n	200030fa <get_channel_id_from_status+0x22>
    {
        channel_id = PDMA_CHANNEL_0;
200030f2:	f04f 0300 	mov.w	r3, #0
200030f6:	73fb      	strb	r3, [r7, #15]
200030f8:	e03f      	b.n	2000317a <get_channel_id_from_status+0xa2>
    }
    else if(status & CHANNEL_1_STATUS_BITS_MASK)
200030fa:	88fb      	ldrh	r3, [r7, #6]
200030fc:	f003 030c 	and.w	r3, r3, #12
20003100:	2b00      	cmp	r3, #0
20003102:	d003      	beq.n	2000310c <get_channel_id_from_status+0x34>
    {
        channel_id = PDMA_CHANNEL_1;
20003104:	f04f 0301 	mov.w	r3, #1
20003108:	73fb      	strb	r3, [r7, #15]
2000310a:	e036      	b.n	2000317a <get_channel_id_from_status+0xa2>
    }
    else if(status & CHANNEL_2_STATUS_BITS_MASK)
2000310c:	88fb      	ldrh	r3, [r7, #6]
2000310e:	f003 0330 	and.w	r3, r3, #48	; 0x30
20003112:	2b00      	cmp	r3, #0
20003114:	d003      	beq.n	2000311e <get_channel_id_from_status+0x46>
    {
        channel_id = PDMA_CHANNEL_2;
20003116:	f04f 0302 	mov.w	r3, #2
2000311a:	73fb      	strb	r3, [r7, #15]
2000311c:	e02d      	b.n	2000317a <get_channel_id_from_status+0xa2>
    }
    else if(status & CHANNEL_3_STATUS_BITS_MASK)
2000311e:	88fb      	ldrh	r3, [r7, #6]
20003120:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
20003124:	2b00      	cmp	r3, #0
20003126:	d003      	beq.n	20003130 <get_channel_id_from_status+0x58>
    {
        channel_id = PDMA_CHANNEL_3;
20003128:	f04f 0303 	mov.w	r3, #3
2000312c:	73fb      	strb	r3, [r7, #15]
2000312e:	e024      	b.n	2000317a <get_channel_id_from_status+0xa2>
    }
    else if(status & CHANNEL_4_STATUS_BITS_MASK)
20003130:	88fb      	ldrh	r3, [r7, #6]
20003132:	f403 7340 	and.w	r3, r3, #768	; 0x300
20003136:	2b00      	cmp	r3, #0
20003138:	d003      	beq.n	20003142 <get_channel_id_from_status+0x6a>
    {
        channel_id = PDMA_CHANNEL_4;
2000313a:	f04f 0304 	mov.w	r3, #4
2000313e:	73fb      	strb	r3, [r7, #15]
20003140:	e01b      	b.n	2000317a <get_channel_id_from_status+0xa2>
    }
    else if(status & CHANNEL_5_STATUS_BITS_MASK)
20003142:	88fb      	ldrh	r3, [r7, #6]
20003144:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
20003148:	2b00      	cmp	r3, #0
2000314a:	d003      	beq.n	20003154 <get_channel_id_from_status+0x7c>
    {
        channel_id = PDMA_CHANNEL_5;
2000314c:	f04f 0305 	mov.w	r3, #5
20003150:	73fb      	strb	r3, [r7, #15]
20003152:	e012      	b.n	2000317a <get_channel_id_from_status+0xa2>
    }
    else if(status & CHANNEL_6_STATUS_BITS_MASK)
20003154:	88fb      	ldrh	r3, [r7, #6]
20003156:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
2000315a:	2b00      	cmp	r3, #0
2000315c:	d003      	beq.n	20003166 <get_channel_id_from_status+0x8e>
    {
        channel_id = PDMA_CHANNEL_6;
2000315e:	f04f 0306 	mov.w	r3, #6
20003162:	73fb      	strb	r3, [r7, #15]
20003164:	e009      	b.n	2000317a <get_channel_id_from_status+0xa2>
    }
    else if(status & CHANNEL_7_STATUS_BITS_MASK)
20003166:	88fb      	ldrh	r3, [r7, #6]
20003168:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
2000316c:	2b00      	cmp	r3, #0
2000316e:	d003      	beq.n	20003178 <get_channel_id_from_status+0xa0>
    {
        channel_id = PDMA_CHANNEL_7;
20003170:	f04f 0307 	mov.w	r3, #7
20003174:	73fb      	strb	r3, [r7, #15]
20003176:	e000      	b.n	2000317a <get_channel_id_from_status+0xa2>
    }
    else
    {
        ASSERT(0);
20003178:	be00      	bkpt	0x0000
    }
    return channel_id;
2000317a:	7bfb      	ldrb	r3, [r7, #15]
}
2000317c:	4618      	mov	r0, r3
2000317e:	f107 0714 	add.w	r7, r7, #20
20003182:	46bd      	mov	sp, r7
20003184:	bc80      	pop	{r7}
20003186:	4770      	bx	lr

20003188 <DMA_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void DMA_IRQHandler(void)
#else
void DMA_IRQHandler(void)
#endif
{
20003188:	4668      	mov	r0, sp
2000318a:	f020 0107 	bic.w	r1, r0, #7
2000318e:	468d      	mov	sp, r1
20003190:	b581      	push	{r0, r7, lr}
20003192:	b087      	sub	sp, #28
20003194:	af00      	add	r7, sp, #0
        (uint16_t)0x00C0, /* PDMA_CHANNEL_3 */
        (uint16_t)0x0300, /* PDMA_CHANNEL_4 */
        (uint16_t)0x0C00, /* PDMA_CHANNEL_5 */
        (uint16_t)0x3000, /* PDMA_CHANNEL_6 */
        (uint16_t)0xC000, /* PDMA_CHANNEL_7 */
    };
20003196:	f643 3370 	movw	r3, #15216	; 0x3b70
2000319a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000319e:	f107 0c04 	add.w	ip, r7, #4
200031a2:	cb0f      	ldmia	r3!, {r0, r1, r2, r3}
200031a4:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}

    status = (uint16_t)PDMA->BUFFER_STATUS;
200031a8:	f243 0300 	movw	r3, #12288	; 0x3000
200031ac:	f2c4 0300 	movt	r3, #16384	; 0x4000
200031b0:	685b      	ldr	r3, [r3, #4]
200031b2:	82bb      	strh	r3, [r7, #20]
    
    do {
        channel_id = get_channel_id_from_status(status);
200031b4:	8abb      	ldrh	r3, [r7, #20]
200031b6:	4618      	mov	r0, r3
200031b8:	f7ff ff8e 	bl	200030d8 <get_channel_id_from_status>
200031bc:	4603      	mov	r3, r0
200031be:	75fb      	strb	r3, [r7, #23]
        status &= (uint16_t)~g_pdma_status_mask[channel_id];
200031c0:	7dfb      	ldrb	r3, [r7, #23]
200031c2:	ea4f 0343 	mov.w	r3, r3, lsl #1
200031c6:	f107 0218 	add.w	r2, r7, #24
200031ca:	4413      	add	r3, r2
200031cc:	f833 3c14 	ldrh.w	r3, [r3, #-20]
200031d0:	ea6f 0303 	mvn.w	r3, r3
200031d4:	b29a      	uxth	r2, r3
200031d6:	8abb      	ldrh	r3, [r7, #20]
200031d8:	ea02 0303 	and.w	r3, r2, r3
200031dc:	82bb      	strh	r3, [r7, #20]
        if ( 0 != g_pdma_isr_table[channel_id])
200031de:	7dfa      	ldrb	r2, [r7, #23]
200031e0:	f643 7384 	movw	r3, #16260	; 0x3f84
200031e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200031e8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
200031ec:	2b00      	cmp	r3, #0
200031ee:	d007      	beq.n	20003200 <DMA_IRQHandler+0x78>
        {
            g_pdma_isr_table[channel_id]();
200031f0:	7dfa      	ldrb	r2, [r7, #23]
200031f2:	f643 7384 	movw	r3, #16260	; 0x3f84
200031f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
200031fa:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
200031fe:	4798      	blx	r3
        }
    } while(0u != status);
20003200:	8abb      	ldrh	r3, [r7, #20]
20003202:	2b00      	cmp	r3, #0
20003204:	d1d6      	bne.n	200031b4 <DMA_IRQHandler+0x2c>
}
20003206:	f107 071c 	add.w	r7, r7, #28
2000320a:	46bd      	mov	sp, r7
2000320c:	e8bd 4081 	ldmia.w	sp!, {r0, r7, lr}
20003210:	4685      	mov	sp, r0
20003212:	4770      	bx	lr

20003214 <PDMA_set_irq_handler>:
void PDMA_set_irq_handler
(
    pdma_channel_id_t channel_id,
    pdma_channel_isr_t handler
)
{
20003214:	b580      	push	{r7, lr}
20003216:	b082      	sub	sp, #8
20003218:	af00      	add	r7, sp, #0
2000321a:	4603      	mov	r3, r0
2000321c:	6039      	str	r1, [r7, #0]
2000321e:	71fb      	strb	r3, [r7, #7]
    /* Save address of handler function in PDMA driver ISR lookup table. */
    g_pdma_isr_table[channel_id] = handler;
20003220:	79fa      	ldrb	r2, [r7, #7]
20003222:	f643 7384 	movw	r3, #16260	; 0x3f84
20003226:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000322a:	6839      	ldr	r1, [r7, #0]
2000322c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    
    /* Enable PDMA channel's interrupt. */
    PDMA->CHANNEL[channel_id].CRTL |= PDMA_IRQ_ENABLE_MASK;
20003230:	f243 0300 	movw	r3, #12288	; 0x3000
20003234:	f2c4 0300 	movt	r3, #16384	; 0x4000
20003238:	79f9      	ldrb	r1, [r7, #7]
2000323a:	f243 0200 	movw	r2, #12288	; 0x3000
2000323e:	f2c4 0200 	movt	r2, #16384	; 0x4000
20003242:	79f8      	ldrb	r0, [r7, #7]
20003244:	f100 0001 	add.w	r0, r0, #1
20003248:	ea4f 1040 	mov.w	r0, r0, lsl #5
2000324c:	4402      	add	r2, r0
2000324e:	6812      	ldr	r2, [r2, #0]
20003250:	f042 0240 	orr.w	r2, r2, #64	; 0x40
20003254:	f101 0101 	add.w	r1, r1, #1
20003258:	ea4f 1141 	mov.w	r1, r1, lsl #5
2000325c:	440b      	add	r3, r1
2000325e:	601a      	str	r2, [r3, #0]
    
    /* Enable PDMA interrupt in Cortex-M3 NVIC. */
    NVIC_EnableIRQ(DMA_IRQn);
20003260:	f04f 000d 	mov.w	r0, #13
20003264:	f7ff fcf2 	bl	20002c4c <NVIC_EnableIRQ>
}
20003268:	f107 0708 	add.w	r7, r7, #8
2000326c:	46bd      	mov	sp, r7
2000326e:	bd80      	pop	{r7, pc}

20003270 <PDMA_enable_irq>:

/***************************************************************************//**
 * See mss_pdma.h for description of this function.
 */
void PDMA_enable_irq( pdma_channel_id_t channel_id )
{
20003270:	b580      	push	{r7, lr}
20003272:	b082      	sub	sp, #8
20003274:	af00      	add	r7, sp, #0
20003276:	4603      	mov	r3, r0
20003278:	71fb      	strb	r3, [r7, #7]
    PDMA->CHANNEL[channel_id].CRTL |= PDMA_IRQ_ENABLE_MASK;
2000327a:	f243 0300 	movw	r3, #12288	; 0x3000
2000327e:	f2c4 0300 	movt	r3, #16384	; 0x4000
20003282:	79f9      	ldrb	r1, [r7, #7]
20003284:	f243 0200 	movw	r2, #12288	; 0x3000
20003288:	f2c4 0200 	movt	r2, #16384	; 0x4000
2000328c:	79f8      	ldrb	r0, [r7, #7]
2000328e:	f100 0001 	add.w	r0, r0, #1
20003292:	ea4f 1040 	mov.w	r0, r0, lsl #5
20003296:	4402      	add	r2, r0
20003298:	6812      	ldr	r2, [r2, #0]
2000329a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
2000329e:	f101 0101 	add.w	r1, r1, #1
200032a2:	ea4f 1141 	mov.w	r1, r1, lsl #5
200032a6:	440b      	add	r3, r1
200032a8:	601a      	str	r2, [r3, #0]
    NVIC_EnableIRQ(DMA_IRQn);
200032aa:	f04f 000d 	mov.w	r0, #13
200032ae:	f7ff fccd 	bl	20002c4c <NVIC_EnableIRQ>
}
200032b2:	f107 0708 	add.w	r7, r7, #8
200032b6:	46bd      	mov	sp, r7
200032b8:	bd80      	pop	{r7, pc}
200032ba:	bf00      	nop

200032bc <PDMA_clear_irq>:
 */
void PDMA_clear_irq
(
    pdma_channel_id_t channel_id
)
{
200032bc:	b480      	push	{r7}
200032be:	b083      	sub	sp, #12
200032c0:	af00      	add	r7, sp, #0
200032c2:	4603      	mov	r3, r0
200032c4:	71fb      	strb	r3, [r7, #7]
    /* Clear interrupt in PDMA controller. */
    PDMA->CHANNEL[channel_id].CRTL |= CLEAR_PORT_A_DONE_MASK;
200032c6:	f243 0300 	movw	r3, #12288	; 0x3000
200032ca:	f2c4 0300 	movt	r3, #16384	; 0x4000
200032ce:	79f9      	ldrb	r1, [r7, #7]
200032d0:	f243 0200 	movw	r2, #12288	; 0x3000
200032d4:	f2c4 0200 	movt	r2, #16384	; 0x4000
200032d8:	79f8      	ldrb	r0, [r7, #7]
200032da:	f100 0001 	add.w	r0, r0, #1
200032de:	ea4f 1040 	mov.w	r0, r0, lsl #5
200032e2:	4402      	add	r2, r0
200032e4:	6812      	ldr	r2, [r2, #0]
200032e6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
200032ea:	f101 0101 	add.w	r1, r1, #1
200032ee:	ea4f 1141 	mov.w	r1, r1, lsl #5
200032f2:	440b      	add	r3, r1
200032f4:	601a      	str	r2, [r3, #0]
    PDMA->CHANNEL[channel_id].CRTL |= CLEAR_PORT_B_DONE_MASK;
200032f6:	f243 0300 	movw	r3, #12288	; 0x3000
200032fa:	f2c4 0300 	movt	r3, #16384	; 0x4000
200032fe:	79f9      	ldrb	r1, [r7, #7]
20003300:	f243 0200 	movw	r2, #12288	; 0x3000
20003304:	f2c4 0200 	movt	r2, #16384	; 0x4000
20003308:	79f8      	ldrb	r0, [r7, #7]
2000330a:	f100 0001 	add.w	r0, r0, #1
2000330e:	ea4f 1040 	mov.w	r0, r0, lsl #5
20003312:	4402      	add	r2, r0
20003314:	6812      	ldr	r2, [r2, #0]
20003316:	f442 7280 	orr.w	r2, r2, #256	; 0x100
2000331a:	f101 0101 	add.w	r1, r1, #1
2000331e:	ea4f 1141 	mov.w	r1, r1, lsl #5
20003322:	440b      	add	r3, r1
20003324:	601a      	str	r2, [r3, #0]
}
20003326:	f107 070c 	add.w	r7, r7, #12
2000332a:	46bd      	mov	sp, r7
2000332c:	bc80      	pop	{r7}
2000332e:	4770      	bx	lr

20003330 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
20003330:	b480      	push	{r7}
20003332:	b083      	sub	sp, #12
20003334:	af00      	add	r7, sp, #0
20003336:	4603      	mov	r3, r0
20003338:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
2000333a:	f24e 1300 	movw	r3, #57600	; 0xe100
2000333e:	f2ce 0300 	movt	r3, #57344	; 0xe000
20003342:	f997 2007 	ldrsb.w	r2, [r7, #7]
20003346:	ea4f 1252 	mov.w	r2, r2, lsr #5
2000334a:	79f9      	ldrb	r1, [r7, #7]
2000334c:	f001 011f 	and.w	r1, r1, #31
20003350:	f04f 0001 	mov.w	r0, #1
20003354:	fa00 f101 	lsl.w	r1, r0, r1
20003358:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
2000335c:	f107 070c 	add.w	r7, r7, #12
20003360:	46bd      	mov	sp, r7
20003362:	bc80      	pop	{r7}
20003364:	4770      	bx	lr
20003366:	bf00      	nop

20003368 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
20003368:	b480      	push	{r7}
2000336a:	b083      	sub	sp, #12
2000336c:	af00      	add	r7, sp, #0
2000336e:	4603      	mov	r3, r0
20003370:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
20003372:	f24e 1300 	movw	r3, #57600	; 0xe100
20003376:	f2ce 0300 	movt	r3, #57344	; 0xe000
2000337a:	f997 2007 	ldrsb.w	r2, [r7, #7]
2000337e:	ea4f 1252 	mov.w	r2, r2, lsr #5
20003382:	79f9      	ldrb	r1, [r7, #7]
20003384:	f001 011f 	and.w	r1, r1, #31
20003388:	f04f 0001 	mov.w	r0, #1
2000338c:	fa00 f101 	lsl.w	r1, r0, r1
20003390:	f102 0220 	add.w	r2, r2, #32
20003394:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20003398:	f107 070c 	add.w	r7, r7, #12
2000339c:	46bd      	mov	sp, r7
2000339e:	bc80      	pop	{r7}
200033a0:	4770      	bx	lr
200033a2:	bf00      	nop

200033a4 <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
200033a4:	b480      	push	{r7}
200033a6:	b083      	sub	sp, #12
200033a8:	af00      	add	r7, sp, #0
200033aa:	4603      	mov	r3, r0
200033ac:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
200033ae:	f24e 1300 	movw	r3, #57600	; 0xe100
200033b2:	f2ce 0300 	movt	r3, #57344	; 0xe000
200033b6:	f997 2007 	ldrsb.w	r2, [r7, #7]
200033ba:	ea4f 1252 	mov.w	r2, r2, lsr #5
200033be:	79f9      	ldrb	r1, [r7, #7]
200033c0:	f001 011f 	and.w	r1, r1, #31
200033c4:	f04f 0001 	mov.w	r0, #1
200033c8:	fa00 f101 	lsl.w	r1, r0, r1
200033cc:	f102 0260 	add.w	r2, r2, #96	; 0x60
200033d0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
200033d4:	f107 070c 	add.w	r7, r7, #12
200033d8:	46bd      	mov	sp, r7
200033da:	bc80      	pop	{r7}
200033dc:	4770      	bx	lr
200033de:	bf00      	nop

200033e0 <MSS_GPIO_init>:
/*-------------------------------------------------------------------------*//**
 * MSS_GPIO_init
 * See "mss_gpio.h" for details of how to use this function.
 */
void MSS_GPIO_init( void )
{
200033e0:	b580      	push	{r7, lr}
200033e2:	b082      	sub	sp, #8
200033e4:	af00      	add	r7, sp, #0
    uint32_t inc;
    
    /* reset MSS GPIO hardware */
    SYSREG->SOFT_RST_CR |= SYSREG_GPIO_SOFTRESET_MASK;
200033e6:	f248 0300 	movw	r3, #32768	; 0x8000
200033ea:	f2c4 0303 	movt	r3, #16387	; 0x4003
200033ee:	f248 0200 	movw	r2, #32768	; 0x8000
200033f2:	f2c4 0203 	movt	r2, #16387	; 0x4003
200033f6:	6c92      	ldr	r2, [r2, #72]	; 0x48
200033f8:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
200033fc:	649a      	str	r2, [r3, #72]	; 0x48
    SYSREG->SOFT_RST_CR |= (SYSREG_GPIO_7_0_SOFTRESET_MASK |
200033fe:	f248 0300 	movw	r3, #32768	; 0x8000
20003402:	f2c4 0303 	movt	r3, #16387	; 0x4003
20003406:	f248 0200 	movw	r2, #32768	; 0x8000
2000340a:	f2c4 0203 	movt	r2, #16387	; 0x4003
2000340e:	6c92      	ldr	r2, [r2, #72]	; 0x48
20003410:	f042 72f0 	orr.w	r2, r2, #31457280	; 0x1e00000
20003414:	649a      	str	r2, [r3, #72]	; 0x48
                            SYSREG_GPIO_15_8_SOFTRESET_MASK |
                            SYSREG_GPIO_23_16_SOFTRESET_MASK |
                            SYSREG_GPIO_31_24_SOFTRESET_MASK);
                            
    /* Clear any previously pended MSS GPIO interrupt */
    for(inc = 0U; inc < NB_OF_GPIO; ++inc)
20003416:	f04f 0300 	mov.w	r3, #0
2000341a:	607b      	str	r3, [r7, #4]
2000341c:	e017      	b.n	2000344e <MSS_GPIO_init+0x6e>
    {
        NVIC_DisableIRQ(g_gpio_irqn_lut[inc]);
2000341e:	687a      	ldr	r2, [r7, #4]
20003420:	f643 4350 	movw	r3, #15440	; 0x3c50
20003424:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003428:	5c9b      	ldrb	r3, [r3, r2]
2000342a:	b25b      	sxtb	r3, r3
2000342c:	4618      	mov	r0, r3
2000342e:	f7ff ff9b 	bl	20003368 <NVIC_DisableIRQ>
        NVIC_ClearPendingIRQ(g_gpio_irqn_lut[inc]);
20003432:	687a      	ldr	r2, [r7, #4]
20003434:	f643 4350 	movw	r3, #15440	; 0x3c50
20003438:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000343c:	5c9b      	ldrb	r3, [r3, r2]
2000343e:	b25b      	sxtb	r3, r3
20003440:	4618      	mov	r0, r3
20003442:	f7ff ffaf 	bl	200033a4 <NVIC_ClearPendingIRQ>
                            SYSREG_GPIO_15_8_SOFTRESET_MASK |
                            SYSREG_GPIO_23_16_SOFTRESET_MASK |
                            SYSREG_GPIO_31_24_SOFTRESET_MASK);
                            
    /* Clear any previously pended MSS GPIO interrupt */
    for(inc = 0U; inc < NB_OF_GPIO; ++inc)
20003446:	687b      	ldr	r3, [r7, #4]
20003448:	f103 0301 	add.w	r3, r3, #1
2000344c:	607b      	str	r3, [r7, #4]
2000344e:	687b      	ldr	r3, [r7, #4]
20003450:	2b1f      	cmp	r3, #31
20003452:	d9e4      	bls.n	2000341e <MSS_GPIO_init+0x3e>
    {
        NVIC_DisableIRQ(g_gpio_irqn_lut[inc]);
        NVIC_ClearPendingIRQ(g_gpio_irqn_lut[inc]);
    }
    /* Take MSS GPIO hardware out of reset. */
    SYSREG->SOFT_RST_CR &= ~(SYSREG_GPIO_7_0_SOFTRESET_MASK |
20003454:	f248 0300 	movw	r3, #32768	; 0x8000
20003458:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000345c:	f248 0200 	movw	r2, #32768	; 0x8000
20003460:	f2c4 0203 	movt	r2, #16387	; 0x4003
20003464:	6c92      	ldr	r2, [r2, #72]	; 0x48
20003466:	f022 72f0 	bic.w	r2, r2, #31457280	; 0x1e00000
2000346a:	649a      	str	r2, [r3, #72]	; 0x48
                             SYSREG_GPIO_15_8_SOFTRESET_MASK |
                             SYSREG_GPIO_23_16_SOFTRESET_MASK |
                             SYSREG_GPIO_31_24_SOFTRESET_MASK);
    SYSREG->SOFT_RST_CR &= ~SYSREG_GPIO_SOFTRESET_MASK;
2000346c:	f248 0300 	movw	r3, #32768	; 0x8000
20003470:	f2c4 0303 	movt	r3, #16387	; 0x4003
20003474:	f248 0200 	movw	r2, #32768	; 0x8000
20003478:	f2c4 0203 	movt	r2, #16387	; 0x4003
2000347c:	6c92      	ldr	r2, [r2, #72]	; 0x48
2000347e:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
20003482:	649a      	str	r2, [r3, #72]	; 0x48
}
20003484:	f107 0708 	add.w	r7, r7, #8
20003488:	46bd      	mov	sp, r7
2000348a:	bd80      	pop	{r7, pc}

2000348c <MSS_GPIO_config>:
void MSS_GPIO_config
(
    mss_gpio_id_t port_id,
    uint32_t config
)
{
2000348c:	b480      	push	{r7}
2000348e:	b085      	sub	sp, #20
20003490:	af00      	add	r7, sp, #0
20003492:	4603      	mov	r3, r0
20003494:	6039      	str	r1, [r7, #0]
20003496:	71fb      	strb	r3, [r7, #7]
    uint32_t gpio_idx = (uint32_t)port_id;
20003498:	79fb      	ldrb	r3, [r7, #7]
2000349a:	60fb      	str	r3, [r7, #12]
    
    ASSERT(gpio_idx < NB_OF_GPIO);
2000349c:	68fb      	ldr	r3, [r7, #12]
2000349e:	2b1f      	cmp	r3, #31
200034a0:	d900      	bls.n	200034a4 <MSS_GPIO_config+0x18>
200034a2:	be00      	bkpt	0x0000

    if(gpio_idx < NB_OF_GPIO)
200034a4:	68fb      	ldr	r3, [r7, #12]
200034a6:	2b1f      	cmp	r3, #31
200034a8:	d808      	bhi.n	200034bc <MSS_GPIO_config+0x30>
    {
        *(g_config_reg_lut[gpio_idx]) = config;
200034aa:	68fa      	ldr	r2, [r7, #12]
200034ac:	f643 33d0 	movw	r3, #15312	; 0x3bd0
200034b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200034b4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
200034b8:	683a      	ldr	r2, [r7, #0]
200034ba:	601a      	str	r2, [r3, #0]
    }
}
200034bc:	f107 0714 	add.w	r7, r7, #20
200034c0:	46bd      	mov	sp, r7
200034c2:	bc80      	pop	{r7}
200034c4:	4770      	bx	lr
200034c6:	bf00      	nop

200034c8 <MSS_GPIO_set_output>:
void MSS_GPIO_set_output
(
    mss_gpio_id_t port_id,
    uint8_t value
)
{
200034c8:	b480      	push	{r7}
200034ca:	b085      	sub	sp, #20
200034cc:	af00      	add	r7, sp, #0
200034ce:	4602      	mov	r2, r0
200034d0:	460b      	mov	r3, r1
200034d2:	71fa      	strb	r2, [r7, #7]
200034d4:	71bb      	strb	r3, [r7, #6]
    uint32_t gpio_setting;
    uint32_t gpio_idx = (uint32_t)port_id;
200034d6:	79fb      	ldrb	r3, [r7, #7]
200034d8:	60fb      	str	r3, [r7, #12]
    
    ASSERT(gpio_idx < NB_OF_GPIO);
200034da:	68fb      	ldr	r3, [r7, #12]
200034dc:	2b1f      	cmp	r3, #31
200034de:	d900      	bls.n	200034e2 <MSS_GPIO_set_output+0x1a>
200034e0:	be00      	bkpt	0x0000
    
    if(gpio_idx < NB_OF_GPIO)
200034e2:	68fb      	ldr	r3, [r7, #12]
200034e4:	2b1f      	cmp	r3, #31
200034e6:	d822      	bhi.n	2000352e <MSS_GPIO_set_output+0x66>
    {
        gpio_setting = GPIO->GPIO_OUT;
200034e8:	f243 0300 	movw	r3, #12288	; 0x3000
200034ec:	f2c4 0301 	movt	r3, #16385	; 0x4001
200034f0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
200034f4:	60bb      	str	r3, [r7, #8]
        gpio_setting &= ~((uint32_t)0x01u << gpio_idx);
200034f6:	68fb      	ldr	r3, [r7, #12]
200034f8:	f04f 0201 	mov.w	r2, #1
200034fc:	fa02 f303 	lsl.w	r3, r2, r3
20003500:	ea6f 0303 	mvn.w	r3, r3
20003504:	68ba      	ldr	r2, [r7, #8]
20003506:	ea02 0303 	and.w	r3, r2, r3
2000350a:	60bb      	str	r3, [r7, #8]
        gpio_setting |= ((uint32_t)value & 0x01u) << gpio_idx;
2000350c:	79bb      	ldrb	r3, [r7, #6]
2000350e:	f003 0201 	and.w	r2, r3, #1
20003512:	68fb      	ldr	r3, [r7, #12]
20003514:	fa02 f303 	lsl.w	r3, r2, r3
20003518:	68ba      	ldr	r2, [r7, #8]
2000351a:	ea42 0303 	orr.w	r3, r2, r3
2000351e:	60bb      	str	r3, [r7, #8]
        GPIO->GPIO_OUT = gpio_setting;
20003520:	f243 0300 	movw	r3, #12288	; 0x3000
20003524:	f2c4 0301 	movt	r3, #16385	; 0x4001
20003528:	68ba      	ldr	r2, [r7, #8]
2000352a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    }
}
2000352e:	f107 0714 	add.w	r7, r7, #20
20003532:	46bd      	mov	sp, r7
20003534:	bc80      	pop	{r7}
20003536:	4770      	bx	lr

20003538 <MSS_GPIO_enable_irq>:
 */
void MSS_GPIO_enable_irq
(
    mss_gpio_id_t port_id
)
{
20003538:	b580      	push	{r7, lr}
2000353a:	b084      	sub	sp, #16
2000353c:	af00      	add	r7, sp, #0
2000353e:	4603      	mov	r3, r0
20003540:	71fb      	strb	r3, [r7, #7]
    uint32_t cfg_value;
    uint32_t gpio_idx = (uint32_t)port_id;
20003542:	79fb      	ldrb	r3, [r7, #7]
20003544:	60fb      	str	r3, [r7, #12]
    
    ASSERT(gpio_idx < NB_OF_GPIO);
20003546:	68fb      	ldr	r3, [r7, #12]
20003548:	2b1f      	cmp	r3, #31
2000354a:	d900      	bls.n	2000354e <MSS_GPIO_enable_irq+0x16>
2000354c:	be00      	bkpt	0x0000
    
    if(gpio_idx < NB_OF_GPIO)
2000354e:	68fb      	ldr	r3, [r7, #12]
20003550:	2b1f      	cmp	r3, #31
20003552:	d81d      	bhi.n	20003590 <MSS_GPIO_enable_irq+0x58>
    {
        cfg_value = *(g_config_reg_lut[gpio_idx]);
20003554:	68fa      	ldr	r2, [r7, #12]
20003556:	f643 33d0 	movw	r3, #15312	; 0x3bd0
2000355a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000355e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20003562:	681b      	ldr	r3, [r3, #0]
20003564:	60bb      	str	r3, [r7, #8]
        *(g_config_reg_lut[gpio_idx]) = (cfg_value | GPIO_INT_ENABLE_MASK);
20003566:	68fa      	ldr	r2, [r7, #12]
20003568:	f643 33d0 	movw	r3, #15312	; 0x3bd0
2000356c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003570:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20003574:	68ba      	ldr	r2, [r7, #8]
20003576:	f042 0208 	orr.w	r2, r2, #8
2000357a:	601a      	str	r2, [r3, #0]
        NVIC_EnableIRQ(g_gpio_irqn_lut[gpio_idx]);
2000357c:	68fa      	ldr	r2, [r7, #12]
2000357e:	f643 4350 	movw	r3, #15440	; 0x3c50
20003582:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003586:	5c9b      	ldrb	r3, [r3, r2]
20003588:	b25b      	sxtb	r3, r3
2000358a:	4618      	mov	r0, r3
2000358c:	f7ff fed0 	bl	20003330 <NVIC_EnableIRQ>
    }
}
20003590:	f107 0710 	add.w	r7, r7, #16
20003594:	46bd      	mov	sp, r7
20003596:	bd80      	pop	{r7, pc}

20003598 <MSS_GPIO_clear_irq>:
 */
void MSS_GPIO_clear_irq
(
    mss_gpio_id_t port_id
)
{
20003598:	b480      	push	{r7}
2000359a:	b085      	sub	sp, #20
2000359c:	af00      	add	r7, sp, #0
2000359e:	4603      	mov	r3, r0
200035a0:	71fb      	strb	r3, [r7, #7]
    uint32_t gpio_idx = (uint32_t)port_id;
200035a2:	79fb      	ldrb	r3, [r7, #7]
200035a4:	60fb      	str	r3, [r7, #12]
    
    ASSERT(gpio_idx < NB_OF_GPIO);
200035a6:	68fb      	ldr	r3, [r7, #12]
200035a8:	2b1f      	cmp	r3, #31
200035aa:	d900      	bls.n	200035ae <MSS_GPIO_clear_irq+0x16>
200035ac:	be00      	bkpt	0x0000
    
    if(gpio_idx < NB_OF_GPIO)
200035ae:	68fb      	ldr	r3, [r7, #12]
200035b0:	2b1f      	cmp	r3, #31
200035b2:	d80a      	bhi.n	200035ca <MSS_GPIO_clear_irq+0x32>
    {
        GPIO->GPIO_IRQ = ((uint32_t)1) << gpio_idx;
200035b4:	f243 0300 	movw	r3, #12288	; 0x3000
200035b8:	f2c4 0301 	movt	r3, #16385	; 0x4001
200035bc:	68fa      	ldr	r2, [r7, #12]
200035be:	f04f 0101 	mov.w	r1, #1
200035c2:	fa01 f202 	lsl.w	r2, r1, r2
200035c6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    }
    __ASM volatile ("dsb");
200035ca:	f3bf 8f4f 	dsb	sy

}
200035ce:	f107 0714 	add.w	r7, r7, #20
200035d2:	46bd      	mov	sp, r7
200035d4:	bc80      	pop	{r7}
200035d6:	4770      	bx	lr

200035d8 <GPIO_init>:
(
    gpio_instance_t *   this_gpio,
    addr_t              base_addr,
    gpio_apb_width_t    bus_width
)
{
200035d8:	b580      	push	{r7, lr}
200035da:	b086      	sub	sp, #24
200035dc:	af00      	add	r7, sp, #0
200035de:	60f8      	str	r0, [r7, #12]
200035e0:	60b9      	str	r1, [r7, #8]
200035e2:	4613      	mov	r3, r2
200035e4:	71fb      	strb	r3, [r7, #7]
    uint8_t i = 0;
200035e6:	f04f 0300 	mov.w	r3, #0
200035ea:	74fb      	strb	r3, [r7, #19]
    addr_t cfg_reg_addr = base_addr;
200035ec:	68bb      	ldr	r3, [r7, #8]
200035ee:	617b      	str	r3, [r7, #20]
    
    this_gpio->base_addr = base_addr;
200035f0:	68fb      	ldr	r3, [r7, #12]
200035f2:	68ba      	ldr	r2, [r7, #8]
200035f4:	601a      	str	r2, [r3, #0]
    this_gpio->apb_bus_width = bus_width;
200035f6:	68fb      	ldr	r3, [r7, #12]
200035f8:	79fa      	ldrb	r2, [r7, #7]
200035fa:	711a      	strb	r2, [r3, #4]
    
    /* Clear configuration. */
    for( i = 0, cfg_reg_addr = base_addr; i < NB_OF_GPIO; ++i )
200035fc:	f04f 0300 	mov.w	r3, #0
20003600:	74fb      	strb	r3, [r7, #19]
20003602:	68bb      	ldr	r3, [r7, #8]
20003604:	617b      	str	r3, [r7, #20]
20003606:	e00c      	b.n	20003622 <GPIO_init+0x4a>
    {
        HW_set_8bit_reg( cfg_reg_addr, 0 );
20003608:	6978      	ldr	r0, [r7, #20]
2000360a:	f04f 0100 	mov.w	r1, #0
2000360e:	f000 f93d 	bl	2000388c <HW_set_8bit_reg>
        cfg_reg_addr += 4;
20003612:	697b      	ldr	r3, [r7, #20]
20003614:	f103 0304 	add.w	r3, r3, #4
20003618:	617b      	str	r3, [r7, #20]
    
    this_gpio->base_addr = base_addr;
    this_gpio->apb_bus_width = bus_width;
    
    /* Clear configuration. */
    for( i = 0, cfg_reg_addr = base_addr; i < NB_OF_GPIO; ++i )
2000361a:	7cfb      	ldrb	r3, [r7, #19]
2000361c:	f103 0301 	add.w	r3, r3, #1
20003620:	74fb      	strb	r3, [r7, #19]
20003622:	7cfb      	ldrb	r3, [r7, #19]
20003624:	2b1f      	cmp	r3, #31
20003626:	d9ef      	bls.n	20003608 <GPIO_init+0x30>
    {
        HW_set_8bit_reg( cfg_reg_addr, 0 );
        cfg_reg_addr += 4;
    }
    /* Clear any pending interrupts */
    switch( this_gpio->apb_bus_width )
20003628:	68fb      	ldr	r3, [r7, #12]
2000362a:	791b      	ldrb	r3, [r3, #4]
2000362c:	2b01      	cmp	r3, #1
2000362e:	d00e      	beq.n	2000364e <GPIO_init+0x76>
20003630:	2b02      	cmp	r3, #2
20003632:	d002      	beq.n	2000363a <GPIO_init+0x62>
20003634:	2b00      	cmp	r3, #0
20003636:	d01d      	beq.n	20003674 <GPIO_init+0x9c>
20003638:	e041      	b.n	200036be <GPIO_init+0xe6>
    {
        case GPIO_APB_32_BITS_BUS:
            HAL_set_32bit_reg( this_gpio->base_addr, IRQ, CLEAR_ALL_IRQ32 );
2000363a:	68fb      	ldr	r3, [r7, #12]
2000363c:	681b      	ldr	r3, [r3, #0]
2000363e:	f103 0380 	add.w	r3, r3, #128	; 0x80
20003642:	4618      	mov	r0, r3
20003644:	f04f 31ff 	mov.w	r1, #4294967295
20003648:	f000 f8f0 	bl	2000382c <HW_set_32bit_reg>
            break;
2000364c:	e038      	b.n	200036c0 <GPIO_init+0xe8>
            
        case GPIO_APB_16_BITS_BUS:
            HAL_set_16bit_reg( this_gpio->base_addr, IRQ0, (uint16_t)CLEAR_ALL_IRQ16 );
2000364e:	68fb      	ldr	r3, [r7, #12]
20003650:	681b      	ldr	r3, [r3, #0]
20003652:	f103 0380 	add.w	r3, r3, #128	; 0x80
20003656:	4618      	mov	r0, r3
20003658:	f64f 71ff 	movw	r1, #65535	; 0xffff
2000365c:	f000 f8fe 	bl	2000385c <HW_set_16bit_reg>
            HAL_set_16bit_reg( this_gpio->base_addr, IRQ1, (uint16_t)CLEAR_ALL_IRQ16 );
20003660:	68fb      	ldr	r3, [r7, #12]
20003662:	681b      	ldr	r3, [r3, #0]
20003664:	f103 0384 	add.w	r3, r3, #132	; 0x84
20003668:	4618      	mov	r0, r3
2000366a:	f64f 71ff 	movw	r1, #65535	; 0xffff
2000366e:	f000 f8f5 	bl	2000385c <HW_set_16bit_reg>
            break;
20003672:	e025      	b.n	200036c0 <GPIO_init+0xe8>
            
        case GPIO_APB_8_BITS_BUS:
            HAL_set_8bit_reg( this_gpio->base_addr, IRQ0, (uint8_t)CLEAR_ALL_IRQ8 );
20003674:	68fb      	ldr	r3, [r7, #12]
20003676:	681b      	ldr	r3, [r3, #0]
20003678:	f103 0380 	add.w	r3, r3, #128	; 0x80
2000367c:	4618      	mov	r0, r3
2000367e:	f04f 01ff 	mov.w	r1, #255	; 0xff
20003682:	f000 f903 	bl	2000388c <HW_set_8bit_reg>
            HAL_set_8bit_reg( this_gpio->base_addr, IRQ1, (uint8_t)CLEAR_ALL_IRQ8 );
20003686:	68fb      	ldr	r3, [r7, #12]
20003688:	681b      	ldr	r3, [r3, #0]
2000368a:	f103 0384 	add.w	r3, r3, #132	; 0x84
2000368e:	4618      	mov	r0, r3
20003690:	f04f 01ff 	mov.w	r1, #255	; 0xff
20003694:	f000 f8fa 	bl	2000388c <HW_set_8bit_reg>
            HAL_set_8bit_reg( this_gpio->base_addr, IRQ2, (uint8_t)CLEAR_ALL_IRQ8 );
20003698:	68fb      	ldr	r3, [r7, #12]
2000369a:	681b      	ldr	r3, [r3, #0]
2000369c:	f103 0388 	add.w	r3, r3, #136	; 0x88
200036a0:	4618      	mov	r0, r3
200036a2:	f04f 01ff 	mov.w	r1, #255	; 0xff
200036a6:	f000 f8f1 	bl	2000388c <HW_set_8bit_reg>
            HAL_set_8bit_reg( this_gpio->base_addr, IRQ3, (uint8_t)CLEAR_ALL_IRQ8 );
200036aa:	68fb      	ldr	r3, [r7, #12]
200036ac:	681b      	ldr	r3, [r3, #0]
200036ae:	f103 038c 	add.w	r3, r3, #140	; 0x8c
200036b2:	4618      	mov	r0, r3
200036b4:	f04f 01ff 	mov.w	r1, #255	; 0xff
200036b8:	f000 f8e8 	bl	2000388c <HW_set_8bit_reg>
            break;
200036bc:	e000      	b.n	200036c0 <GPIO_init+0xe8>
            
        default:
            HAL_ASSERT(0);
200036be:	be00      	bkpt	0x0000
            break;
    }
}
200036c0:	f107 0718 	add.w	r7, r7, #24
200036c4:	46bd      	mov	sp, r7
200036c6:	bd80      	pop	{r7, pc}

200036c8 <GPIO_config>:
(
    gpio_instance_t *   this_gpio,
    gpio_id_t           port_id,
    uint32_t            config
)
{
200036c8:	b580      	push	{r7, lr}
200036ca:	b086      	sub	sp, #24
200036cc:	af00      	add	r7, sp, #0
200036ce:	60f8      	str	r0, [r7, #12]
200036d0:	460b      	mov	r3, r1
200036d2:	607a      	str	r2, [r7, #4]
200036d4:	72fb      	strb	r3, [r7, #11]
    HAL_ASSERT( port_id < NB_OF_GPIO );
200036d6:	7afb      	ldrb	r3, [r7, #11]
200036d8:	2b1f      	cmp	r3, #31
200036da:	d900      	bls.n	200036de <GPIO_config+0x16>
200036dc:	be00      	bkpt	0x0000
    
    if ( port_id < NB_OF_GPIO )
200036de:	7afb      	ldrb	r3, [r7, #11]
200036e0:	2b1f      	cmp	r3, #31
200036e2:	d814      	bhi.n	2000370e <GPIO_config+0x46>
    {
        uint32_t cfg_reg_addr = this_gpio->base_addr;
200036e4:	68fb      	ldr	r3, [r7, #12]
200036e6:	681b      	ldr	r3, [r3, #0]
200036e8:	617b      	str	r3, [r7, #20]
        cfg_reg_addr += (port_id * 4);
200036ea:	7afb      	ldrb	r3, [r7, #11]
200036ec:	ea4f 0383 	mov.w	r3, r3, lsl #2
200036f0:	697a      	ldr	r2, [r7, #20]
200036f2:	4413      	add	r3, r2
200036f4:	617b      	str	r3, [r7, #20]
        HW_set_32bit_reg( cfg_reg_addr, config );
200036f6:	6978      	ldr	r0, [r7, #20]
200036f8:	6879      	ldr	r1, [r7, #4]
200036fa:	f000 f897 	bl	2000382c <HW_set_32bit_reg>
         * back the expected value may indicate that the GPIO port was configured
         * as part of the hardware flow and cannot be modified through software.
         * It may also indicate that the base address passed as parameter to
         * GPIO_init() was incorrect.
         */
        HAL_ASSERT( HW_get_32bit_reg( cfg_reg_addr ) == config );
200036fe:	6978      	ldr	r0, [r7, #20]
20003700:	f000 f896 	bl	20003830 <HW_get_32bit_reg>
20003704:	4602      	mov	r2, r0
20003706:	687b      	ldr	r3, [r7, #4]
20003708:	429a      	cmp	r2, r3
2000370a:	d000      	beq.n	2000370e <GPIO_config+0x46>
2000370c:	be00      	bkpt	0x0000
    }
}
2000370e:	f107 0718 	add.w	r7, r7, #24
20003712:	46bd      	mov	sp, r7
20003714:	bd80      	pop	{r7, pc}
20003716:	bf00      	nop

20003718 <GPIO_enable_irq>:
void GPIO_enable_irq
(
    gpio_instance_t *   this_gpio,
    gpio_id_t           port_id
)
{
20003718:	b580      	push	{r7, lr}
2000371a:	b084      	sub	sp, #16
2000371c:	af00      	add	r7, sp, #0
2000371e:	6078      	str	r0, [r7, #4]
20003720:	460b      	mov	r3, r1
20003722:	70fb      	strb	r3, [r7, #3]
    uint32_t cfg_value;
    uint32_t cfg_reg_addr = this_gpio->base_addr;
20003724:	687b      	ldr	r3, [r7, #4]
20003726:	681b      	ldr	r3, [r3, #0]
20003728:	60fb      	str	r3, [r7, #12]
   
    HAL_ASSERT( port_id < NB_OF_GPIO );
2000372a:	78fb      	ldrb	r3, [r7, #3]
2000372c:	2b1f      	cmp	r3, #31
2000372e:	d900      	bls.n	20003732 <GPIO_enable_irq+0x1a>
20003730:	be00      	bkpt	0x0000
    
    if ( port_id < NB_OF_GPIO )
20003732:	78fb      	ldrb	r3, [r7, #3]
20003734:	2b1f      	cmp	r3, #31
20003736:	d812      	bhi.n	2000375e <GPIO_enable_irq+0x46>
    {
        cfg_reg_addr += (port_id * 4);
20003738:	78fb      	ldrb	r3, [r7, #3]
2000373a:	ea4f 0383 	mov.w	r3, r3, lsl #2
2000373e:	68fa      	ldr	r2, [r7, #12]
20003740:	4413      	add	r3, r2
20003742:	60fb      	str	r3, [r7, #12]
        cfg_value = HW_get_8bit_reg( cfg_reg_addr );
20003744:	68f8      	ldr	r0, [r7, #12]
20003746:	f000 f8a3 	bl	20003890 <HW_get_8bit_reg>
2000374a:	4603      	mov	r3, r0
2000374c:	60bb      	str	r3, [r7, #8]
        cfg_value |= GPIO_INT_ENABLE_MASK;
2000374e:	68bb      	ldr	r3, [r7, #8]
20003750:	f043 0308 	orr.w	r3, r3, #8
20003754:	60bb      	str	r3, [r7, #8]
        HW_set_8bit_reg( cfg_reg_addr, cfg_value );
20003756:	68f8      	ldr	r0, [r7, #12]
20003758:	68b9      	ldr	r1, [r7, #8]
2000375a:	f000 f897 	bl	2000388c <HW_set_8bit_reg>
    }
}
2000375e:	f107 0710 	add.w	r7, r7, #16
20003762:	46bd      	mov	sp, r7
20003764:	bd80      	pop	{r7, pc}
20003766:	bf00      	nop

20003768 <GPIO_clear_irq>:
void GPIO_clear_irq
(
    gpio_instance_t *   this_gpio,
    gpio_id_t           port_id
)
{
20003768:	b580      	push	{r7, lr}
2000376a:	b084      	sub	sp, #16
2000376c:	af00      	add	r7, sp, #0
2000376e:	6078      	str	r0, [r7, #4]
20003770:	460b      	mov	r3, r1
20003772:	70fb      	strb	r3, [r7, #3]
    uint32_t irq_clr_value = ((uint32_t)1) << ((uint32_t)port_id);
20003774:	78fb      	ldrb	r3, [r7, #3]
20003776:	f04f 0201 	mov.w	r2, #1
2000377a:	fa02 f303 	lsl.w	r3, r2, r3
2000377e:	60fb      	str	r3, [r7, #12]
    
    switch( this_gpio->apb_bus_width )
20003780:	687b      	ldr	r3, [r7, #4]
20003782:	791b      	ldrb	r3, [r3, #4]
20003784:	2b01      	cmp	r3, #1
20003786:	d00d      	beq.n	200037a4 <GPIO_clear_irq+0x3c>
20003788:	2b02      	cmp	r3, #2
2000378a:	d002      	beq.n	20003792 <GPIO_clear_irq+0x2a>
2000378c:	2b00      	cmp	r3, #0
2000378e:	d01d      	beq.n	200037cc <GPIO_clear_irq+0x64>
20003790:	e046      	b.n	20003820 <GPIO_clear_irq+0xb8>
    {
        case GPIO_APB_32_BITS_BUS:
            HAL_set_32bit_reg( this_gpio->base_addr, IRQ, irq_clr_value );
20003792:	687b      	ldr	r3, [r7, #4]
20003794:	681b      	ldr	r3, [r3, #0]
20003796:	f103 0380 	add.w	r3, r3, #128	; 0x80
2000379a:	4618      	mov	r0, r3
2000379c:	68f9      	ldr	r1, [r7, #12]
2000379e:	f000 f845 	bl	2000382c <HW_set_32bit_reg>
            break;
200037a2:	e03e      	b.n	20003822 <GPIO_clear_irq+0xba>
            
        case GPIO_APB_16_BITS_BUS:
            HAL_set_16bit_reg( this_gpio->base_addr, IRQ0, irq_clr_value );
200037a4:	687b      	ldr	r3, [r7, #4]
200037a6:	681b      	ldr	r3, [r3, #0]
200037a8:	f103 0380 	add.w	r3, r3, #128	; 0x80
200037ac:	4618      	mov	r0, r3
200037ae:	68f9      	ldr	r1, [r7, #12]
200037b0:	f000 f854 	bl	2000385c <HW_set_16bit_reg>
            HAL_set_16bit_reg( this_gpio->base_addr, IRQ1, irq_clr_value >> 16 );
200037b4:	687b      	ldr	r3, [r7, #4]
200037b6:	681b      	ldr	r3, [r3, #0]
200037b8:	f103 0284 	add.w	r2, r3, #132	; 0x84
200037bc:	68fb      	ldr	r3, [r7, #12]
200037be:	ea4f 4313 	mov.w	r3, r3, lsr #16
200037c2:	4610      	mov	r0, r2
200037c4:	4619      	mov	r1, r3
200037c6:	f000 f849 	bl	2000385c <HW_set_16bit_reg>
            break;
200037ca:	e02a      	b.n	20003822 <GPIO_clear_irq+0xba>
            
        case GPIO_APB_8_BITS_BUS:
            HAL_set_8bit_reg( this_gpio->base_addr, IRQ0, irq_clr_value );
200037cc:	687b      	ldr	r3, [r7, #4]
200037ce:	681b      	ldr	r3, [r3, #0]
200037d0:	f103 0380 	add.w	r3, r3, #128	; 0x80
200037d4:	4618      	mov	r0, r3
200037d6:	68f9      	ldr	r1, [r7, #12]
200037d8:	f000 f858 	bl	2000388c <HW_set_8bit_reg>
            HAL_set_8bit_reg( this_gpio->base_addr, IRQ1, irq_clr_value >> 8 );
200037dc:	687b      	ldr	r3, [r7, #4]
200037de:	681b      	ldr	r3, [r3, #0]
200037e0:	f103 0284 	add.w	r2, r3, #132	; 0x84
200037e4:	68fb      	ldr	r3, [r7, #12]
200037e6:	ea4f 2313 	mov.w	r3, r3, lsr #8
200037ea:	4610      	mov	r0, r2
200037ec:	4619      	mov	r1, r3
200037ee:	f000 f84d 	bl	2000388c <HW_set_8bit_reg>
            HAL_set_8bit_reg( this_gpio->base_addr, IRQ2, irq_clr_value >> 16 );
200037f2:	687b      	ldr	r3, [r7, #4]
200037f4:	681b      	ldr	r3, [r3, #0]
200037f6:	f103 0288 	add.w	r2, r3, #136	; 0x88
200037fa:	68fb      	ldr	r3, [r7, #12]
200037fc:	ea4f 4313 	mov.w	r3, r3, lsr #16
20003800:	4610      	mov	r0, r2
20003802:	4619      	mov	r1, r3
20003804:	f000 f842 	bl	2000388c <HW_set_8bit_reg>
            HAL_set_8bit_reg( this_gpio->base_addr, IRQ3, irq_clr_value >> 24 );
20003808:	687b      	ldr	r3, [r7, #4]
2000380a:	681b      	ldr	r3, [r3, #0]
2000380c:	f103 028c 	add.w	r2, r3, #140	; 0x8c
20003810:	68fb      	ldr	r3, [r7, #12]
20003812:	ea4f 6313 	mov.w	r3, r3, lsr #24
20003816:	4610      	mov	r0, r2
20003818:	4619      	mov	r1, r3
2000381a:	f000 f837 	bl	2000388c <HW_set_8bit_reg>
            break;
2000381e:	e000      	b.n	20003822 <GPIO_clear_irq+0xba>
            
        default:
            HAL_ASSERT(0);
20003820:	be00      	bkpt	0x0000
            break;
    }
}
20003822:	f107 0710 	add.w	r7, r7, #16
20003826:	46bd      	mov	sp, r7
20003828:	bd80      	pop	{r7, pc}
2000382a:	bf00      	nop

2000382c <HW_set_32bit_reg>:
2000382c:	6001      	str	r1, [r0, #0]
2000382e:	4770      	bx	lr

20003830 <HW_get_32bit_reg>:
20003830:	6800      	ldr	r0, [r0, #0]
20003832:	4770      	bx	lr

20003834 <HW_set_32bit_reg_field>:
20003834:	b50e      	push	{r1, r2, r3, lr}
20003836:	fa03 f301 	lsl.w	r3, r3, r1
2000383a:	ea03 0302 	and.w	r3, r3, r2
2000383e:	6801      	ldr	r1, [r0, #0]
20003840:	ea6f 0202 	mvn.w	r2, r2
20003844:	ea01 0102 	and.w	r1, r1, r2
20003848:	ea41 0103 	orr.w	r1, r1, r3
2000384c:	6001      	str	r1, [r0, #0]
2000384e:	bd0e      	pop	{r1, r2, r3, pc}

20003850 <HW_get_32bit_reg_field>:
20003850:	6800      	ldr	r0, [r0, #0]
20003852:	ea00 0002 	and.w	r0, r0, r2
20003856:	fa20 f001 	lsr.w	r0, r0, r1
2000385a:	4770      	bx	lr

2000385c <HW_set_16bit_reg>:
2000385c:	8001      	strh	r1, [r0, #0]
2000385e:	4770      	bx	lr

20003860 <HW_get_16bit_reg>:
20003860:	8800      	ldrh	r0, [r0, #0]
20003862:	4770      	bx	lr

20003864 <HW_set_16bit_reg_field>:
20003864:	b50e      	push	{r1, r2, r3, lr}
20003866:	fa03 f301 	lsl.w	r3, r3, r1
2000386a:	ea03 0302 	and.w	r3, r3, r2
2000386e:	8801      	ldrh	r1, [r0, #0]
20003870:	ea6f 0202 	mvn.w	r2, r2
20003874:	ea01 0102 	and.w	r1, r1, r2
20003878:	ea41 0103 	orr.w	r1, r1, r3
2000387c:	8001      	strh	r1, [r0, #0]
2000387e:	bd0e      	pop	{r1, r2, r3, pc}

20003880 <HW_get_16bit_reg_field>:
20003880:	8800      	ldrh	r0, [r0, #0]
20003882:	ea00 0002 	and.w	r0, r0, r2
20003886:	fa20 f001 	lsr.w	r0, r0, r1
2000388a:	4770      	bx	lr

2000388c <HW_set_8bit_reg>:
2000388c:	7001      	strb	r1, [r0, #0]
2000388e:	4770      	bx	lr

20003890 <HW_get_8bit_reg>:
20003890:	7800      	ldrb	r0, [r0, #0]
20003892:	4770      	bx	lr

20003894 <HW_set_8bit_reg_field>:
20003894:	b50e      	push	{r1, r2, r3, lr}
20003896:	fa03 f301 	lsl.w	r3, r3, r1
2000389a:	ea03 0302 	and.w	r3, r3, r2
2000389e:	7801      	ldrb	r1, [r0, #0]
200038a0:	ea6f 0202 	mvn.w	r2, r2
200038a4:	ea01 0102 	and.w	r1, r1, r2
200038a8:	ea41 0103 	orr.w	r1, r1, r3
200038ac:	7001      	strb	r1, [r0, #0]
200038ae:	bd0e      	pop	{r1, r2, r3, pc}

200038b0 <HW_get_8bit_reg_field>:
200038b0:	7800      	ldrb	r0, [r0, #0]
200038b2:	ea00 0002 	and.w	r0, r0, r2
200038b6:	fa20 f001 	lsr.w	r0, r0, r1
200038ba:	4770      	bx	lr

200038bc <__libc_init_array>:
200038bc:	b570      	push	{r4, r5, r6, lr}
200038be:	f643 4688 	movw	r6, #15496	; 0x3c88
200038c2:	f643 4588 	movw	r5, #15496	; 0x3c88
200038c6:	f2c2 0600 	movt	r6, #8192	; 0x2000
200038ca:	f2c2 0500 	movt	r5, #8192	; 0x2000
200038ce:	1b76      	subs	r6, r6, r5
200038d0:	10b6      	asrs	r6, r6, #2
200038d2:	d006      	beq.n	200038e2 <__libc_init_array+0x26>
200038d4:	2400      	movs	r4, #0
200038d6:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
200038da:	3401      	adds	r4, #1
200038dc:	4798      	blx	r3
200038de:	42a6      	cmp	r6, r4
200038e0:	d8f9      	bhi.n	200038d6 <__libc_init_array+0x1a>
200038e2:	f643 4588 	movw	r5, #15496	; 0x3c88
200038e6:	f643 468c 	movw	r6, #15500	; 0x3c8c
200038ea:	f2c2 0500 	movt	r5, #8192	; 0x2000
200038ee:	f2c2 0600 	movt	r6, #8192	; 0x2000
200038f2:	1b76      	subs	r6, r6, r5
200038f4:	f000 f9bc 	bl	20003c70 <_init>
200038f8:	10b6      	asrs	r6, r6, #2
200038fa:	d006      	beq.n	2000390a <__libc_init_array+0x4e>
200038fc:	2400      	movs	r4, #0
200038fe:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
20003902:	3401      	adds	r4, #1
20003904:	4798      	blx	r3
20003906:	42a6      	cmp	r6, r4
20003908:	d8f9      	bhi.n	200038fe <__libc_init_array+0x42>
2000390a:	bd70      	pop	{r4, r5, r6, pc}

2000390c <memcpy>:
2000390c:	2a03      	cmp	r2, #3
2000390e:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
20003912:	d80b      	bhi.n	2000392c <memcpy+0x20>
20003914:	b13a      	cbz	r2, 20003926 <memcpy+0x1a>
20003916:	2300      	movs	r3, #0
20003918:	f811 c003 	ldrb.w	ip, [r1, r3]
2000391c:	f800 c003 	strb.w	ip, [r0, r3]
20003920:	3301      	adds	r3, #1
20003922:	4293      	cmp	r3, r2
20003924:	d1f8      	bne.n	20003918 <memcpy+0xc>
20003926:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
2000392a:	4770      	bx	lr
2000392c:	1882      	adds	r2, r0, r2
2000392e:	460c      	mov	r4, r1
20003930:	4603      	mov	r3, r0
20003932:	e003      	b.n	2000393c <memcpy+0x30>
20003934:	f814 1c01 	ldrb.w	r1, [r4, #-1]
20003938:	f803 1c01 	strb.w	r1, [r3, #-1]
2000393c:	f003 0603 	and.w	r6, r3, #3
20003940:	4619      	mov	r1, r3
20003942:	46a4      	mov	ip, r4
20003944:	3301      	adds	r3, #1
20003946:	3401      	adds	r4, #1
20003948:	2e00      	cmp	r6, #0
2000394a:	d1f3      	bne.n	20003934 <memcpy+0x28>
2000394c:	f01c 0403 	ands.w	r4, ip, #3
20003950:	4663      	mov	r3, ip
20003952:	bf08      	it	eq
20003954:	ebc1 0c02 	rsbeq	ip, r1, r2
20003958:	d068      	beq.n	20003a2c <memcpy+0x120>
2000395a:	4265      	negs	r5, r4
2000395c:	f1c4 0a04 	rsb	sl, r4, #4
20003960:	eb0c 0705 	add.w	r7, ip, r5
20003964:	4633      	mov	r3, r6
20003966:	ea4f 0aca 	mov.w	sl, sl, lsl #3
2000396a:	f85c 6005 	ldr.w	r6, [ip, r5]
2000396e:	ea4f 08c4 	mov.w	r8, r4, lsl #3
20003972:	1a55      	subs	r5, r2, r1
20003974:	e008      	b.n	20003988 <memcpy+0x7c>
20003976:	f857 4f04 	ldr.w	r4, [r7, #4]!
2000397a:	4626      	mov	r6, r4
2000397c:	fa04 f40a 	lsl.w	r4, r4, sl
20003980:	ea49 0404 	orr.w	r4, r9, r4
20003984:	50cc      	str	r4, [r1, r3]
20003986:	3304      	adds	r3, #4
20003988:	185c      	adds	r4, r3, r1
2000398a:	2d03      	cmp	r5, #3
2000398c:	fa26 f908 	lsr.w	r9, r6, r8
20003990:	f1a5 0504 	sub.w	r5, r5, #4
20003994:	eb0c 0603 	add.w	r6, ip, r3
20003998:	dced      	bgt.n	20003976 <memcpy+0x6a>
2000399a:	2300      	movs	r3, #0
2000399c:	e002      	b.n	200039a4 <memcpy+0x98>
2000399e:	5cf1      	ldrb	r1, [r6, r3]
200039a0:	54e1      	strb	r1, [r4, r3]
200039a2:	3301      	adds	r3, #1
200039a4:	1919      	adds	r1, r3, r4
200039a6:	4291      	cmp	r1, r2
200039a8:	d3f9      	bcc.n	2000399e <memcpy+0x92>
200039aa:	e7bc      	b.n	20003926 <memcpy+0x1a>
200039ac:	f853 4c40 	ldr.w	r4, [r3, #-64]
200039b0:	f841 4c40 	str.w	r4, [r1, #-64]
200039b4:	f853 4c3c 	ldr.w	r4, [r3, #-60]
200039b8:	f841 4c3c 	str.w	r4, [r1, #-60]
200039bc:	f853 4c38 	ldr.w	r4, [r3, #-56]
200039c0:	f841 4c38 	str.w	r4, [r1, #-56]
200039c4:	f853 4c34 	ldr.w	r4, [r3, #-52]
200039c8:	f841 4c34 	str.w	r4, [r1, #-52]
200039cc:	f853 4c30 	ldr.w	r4, [r3, #-48]
200039d0:	f841 4c30 	str.w	r4, [r1, #-48]
200039d4:	f853 4c2c 	ldr.w	r4, [r3, #-44]
200039d8:	f841 4c2c 	str.w	r4, [r1, #-44]
200039dc:	f853 4c28 	ldr.w	r4, [r3, #-40]
200039e0:	f841 4c28 	str.w	r4, [r1, #-40]
200039e4:	f853 4c24 	ldr.w	r4, [r3, #-36]
200039e8:	f841 4c24 	str.w	r4, [r1, #-36]
200039ec:	f853 4c20 	ldr.w	r4, [r3, #-32]
200039f0:	f841 4c20 	str.w	r4, [r1, #-32]
200039f4:	f853 4c1c 	ldr.w	r4, [r3, #-28]
200039f8:	f841 4c1c 	str.w	r4, [r1, #-28]
200039fc:	f853 4c18 	ldr.w	r4, [r3, #-24]
20003a00:	f841 4c18 	str.w	r4, [r1, #-24]
20003a04:	f853 4c14 	ldr.w	r4, [r3, #-20]
20003a08:	f841 4c14 	str.w	r4, [r1, #-20]
20003a0c:	f853 4c10 	ldr.w	r4, [r3, #-16]
20003a10:	f841 4c10 	str.w	r4, [r1, #-16]
20003a14:	f853 4c0c 	ldr.w	r4, [r3, #-12]
20003a18:	f841 4c0c 	str.w	r4, [r1, #-12]
20003a1c:	f853 4c08 	ldr.w	r4, [r3, #-8]
20003a20:	f841 4c08 	str.w	r4, [r1, #-8]
20003a24:	f853 4c04 	ldr.w	r4, [r3, #-4]
20003a28:	f841 4c04 	str.w	r4, [r1, #-4]
20003a2c:	461c      	mov	r4, r3
20003a2e:	460d      	mov	r5, r1
20003a30:	3340      	adds	r3, #64	; 0x40
20003a32:	3140      	adds	r1, #64	; 0x40
20003a34:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
20003a38:	f1ac 0c40 	sub.w	ip, ip, #64	; 0x40
20003a3c:	dcb6      	bgt.n	200039ac <memcpy+0xa0>
20003a3e:	4621      	mov	r1, r4
20003a40:	462b      	mov	r3, r5
20003a42:	1b54      	subs	r4, r2, r5
20003a44:	e00f      	b.n	20003a66 <memcpy+0x15a>
20003a46:	f851 5c10 	ldr.w	r5, [r1, #-16]
20003a4a:	f843 5c10 	str.w	r5, [r3, #-16]
20003a4e:	f851 5c0c 	ldr.w	r5, [r1, #-12]
20003a52:	f843 5c0c 	str.w	r5, [r3, #-12]
20003a56:	f851 5c08 	ldr.w	r5, [r1, #-8]
20003a5a:	f843 5c08 	str.w	r5, [r3, #-8]
20003a5e:	f851 5c04 	ldr.w	r5, [r1, #-4]
20003a62:	f843 5c04 	str.w	r5, [r3, #-4]
20003a66:	2c0f      	cmp	r4, #15
20003a68:	460d      	mov	r5, r1
20003a6a:	469c      	mov	ip, r3
20003a6c:	f101 0110 	add.w	r1, r1, #16
20003a70:	f103 0310 	add.w	r3, r3, #16
20003a74:	f1a4 0410 	sub.w	r4, r4, #16
20003a78:	dce5      	bgt.n	20003a46 <memcpy+0x13a>
20003a7a:	ebcc 0102 	rsb	r1, ip, r2
20003a7e:	2300      	movs	r3, #0
20003a80:	e003      	b.n	20003a8a <memcpy+0x17e>
20003a82:	58ec      	ldr	r4, [r5, r3]
20003a84:	f84c 4003 	str.w	r4, [ip, r3]
20003a88:	3304      	adds	r3, #4
20003a8a:	195e      	adds	r6, r3, r5
20003a8c:	2903      	cmp	r1, #3
20003a8e:	eb03 040c 	add.w	r4, r3, ip
20003a92:	f1a1 0104 	sub.w	r1, r1, #4
20003a96:	dcf4      	bgt.n	20003a82 <memcpy+0x176>
20003a98:	e77f      	b.n	2000399a <memcpy+0x8e>
20003a9a:	bf00      	nop

20003a9c <memset>:
20003a9c:	2a03      	cmp	r2, #3
20003a9e:	b2c9      	uxtb	r1, r1
20003aa0:	b430      	push	{r4, r5}
20003aa2:	d807      	bhi.n	20003ab4 <memset+0x18>
20003aa4:	b122      	cbz	r2, 20003ab0 <memset+0x14>
20003aa6:	2300      	movs	r3, #0
20003aa8:	54c1      	strb	r1, [r0, r3]
20003aaa:	3301      	adds	r3, #1
20003aac:	4293      	cmp	r3, r2
20003aae:	d1fb      	bne.n	20003aa8 <memset+0xc>
20003ab0:	bc30      	pop	{r4, r5}
20003ab2:	4770      	bx	lr
20003ab4:	eb00 0c02 	add.w	ip, r0, r2
20003ab8:	4603      	mov	r3, r0
20003aba:	e001      	b.n	20003ac0 <memset+0x24>
20003abc:	f803 1c01 	strb.w	r1, [r3, #-1]
20003ac0:	f003 0403 	and.w	r4, r3, #3
20003ac4:	461a      	mov	r2, r3
20003ac6:	3301      	adds	r3, #1
20003ac8:	2c00      	cmp	r4, #0
20003aca:	d1f7      	bne.n	20003abc <memset+0x20>
20003acc:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
20003ad0:	ebc2 040c 	rsb	r4, r2, ip
20003ad4:	fb03 f301 	mul.w	r3, r3, r1
20003ad8:	e01f      	b.n	20003b1a <memset+0x7e>
20003ada:	f842 3c40 	str.w	r3, [r2, #-64]
20003ade:	f842 3c3c 	str.w	r3, [r2, #-60]
20003ae2:	f842 3c38 	str.w	r3, [r2, #-56]
20003ae6:	f842 3c34 	str.w	r3, [r2, #-52]
20003aea:	f842 3c30 	str.w	r3, [r2, #-48]
20003aee:	f842 3c2c 	str.w	r3, [r2, #-44]
20003af2:	f842 3c28 	str.w	r3, [r2, #-40]
20003af6:	f842 3c24 	str.w	r3, [r2, #-36]
20003afa:	f842 3c20 	str.w	r3, [r2, #-32]
20003afe:	f842 3c1c 	str.w	r3, [r2, #-28]
20003b02:	f842 3c18 	str.w	r3, [r2, #-24]
20003b06:	f842 3c14 	str.w	r3, [r2, #-20]
20003b0a:	f842 3c10 	str.w	r3, [r2, #-16]
20003b0e:	f842 3c0c 	str.w	r3, [r2, #-12]
20003b12:	f842 3c08 	str.w	r3, [r2, #-8]
20003b16:	f842 3c04 	str.w	r3, [r2, #-4]
20003b1a:	4615      	mov	r5, r2
20003b1c:	3240      	adds	r2, #64	; 0x40
20003b1e:	2c3f      	cmp	r4, #63	; 0x3f
20003b20:	f1a4 0440 	sub.w	r4, r4, #64	; 0x40
20003b24:	dcd9      	bgt.n	20003ada <memset+0x3e>
20003b26:	462a      	mov	r2, r5
20003b28:	ebc5 040c 	rsb	r4, r5, ip
20003b2c:	e007      	b.n	20003b3e <memset+0xa2>
20003b2e:	f842 3c10 	str.w	r3, [r2, #-16]
20003b32:	f842 3c0c 	str.w	r3, [r2, #-12]
20003b36:	f842 3c08 	str.w	r3, [r2, #-8]
20003b3a:	f842 3c04 	str.w	r3, [r2, #-4]
20003b3e:	4615      	mov	r5, r2
20003b40:	3210      	adds	r2, #16
20003b42:	2c0f      	cmp	r4, #15
20003b44:	f1a4 0410 	sub.w	r4, r4, #16
20003b48:	dcf1      	bgt.n	20003b2e <memset+0x92>
20003b4a:	462a      	mov	r2, r5
20003b4c:	ebc5 050c 	rsb	r5, r5, ip
20003b50:	e001      	b.n	20003b56 <memset+0xba>
20003b52:	f842 3c04 	str.w	r3, [r2, #-4]
20003b56:	4614      	mov	r4, r2
20003b58:	3204      	adds	r2, #4
20003b5a:	2d03      	cmp	r5, #3
20003b5c:	f1a5 0504 	sub.w	r5, r5, #4
20003b60:	dcf7      	bgt.n	20003b52 <memset+0xb6>
20003b62:	e001      	b.n	20003b68 <memset+0xcc>
20003b64:	f804 1b01 	strb.w	r1, [r4], #1
20003b68:	4564      	cmp	r4, ip
20003b6a:	d3fb      	bcc.n	20003b64 <memset+0xc8>
20003b6c:	e7a0      	b.n	20003ab0 <memset+0x14>
20003b6e:	bf00      	nop

20003b70 <C.23.3704>:
20003b70:	0003 000c 0030 00c0 0300 0c00 3000 c000     ....0........0..

20003b80 <C.22.3465>:
20003b80:	0001 0000 0003 0080 0001 0100 0003 0180     ................
20003b90:	0001 0200 0003 0280 0001 0300 0003 0380     ................
20003ba0:	0001 0400 0003 0400 0001 0480 0003 0480     ................
20003bb0:	0003 0500 0001 0580 0001 0600 0003 0600     ................
20003bc0:	0001 0680 0003 0680 0001 0700 0003 0780     ................

20003bd0 <g_config_reg_lut>:
20003bd0:	3000 4001 3004 4001 3008 4001 300c 4001     .0.@.0.@.0.@.0.@
20003be0:	3010 4001 3014 4001 3018 4001 301c 4001     .0.@.0.@.0.@.0.@
20003bf0:	3020 4001 3024 4001 3028 4001 302c 4001      0.@$0.@(0.@,0.@
20003c00:	3030 4001 3034 4001 3038 4001 303c 4001     00.@40.@80.@<0.@
20003c10:	3040 4001 3044 4001 3048 4001 304c 4001     @0.@D0.@H0.@L0.@
20003c20:	3050 4001 3054 4001 3058 4001 305c 4001     P0.@T0.@X0.@\0.@
20003c30:	3060 4001 3064 4001 3068 4001 306c 4001     `0.@d0.@h0.@l0.@
20003c40:	3070 4001 3074 4001 3078 4001 307c 4001     p0.@t0.@x0.@|0.@

20003c50 <g_gpio_irqn_lut>:
20003c50:	3332 3534 3736 3938 3b3a 3d3c 3f3e 4140     23456789:;<=>?@A
20003c60:	4342 4544 4746 4948 4b4a 4d4c 4f4e 5150     BCDEFGHIJKLMNOPQ

20003c70 <_init>:
20003c70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
20003c72:	bf00      	nop
20003c74:	bcf8      	pop	{r3, r4, r5, r6, r7}
20003c76:	bc08      	pop	{r3}
20003c78:	469e      	mov	lr, r3
20003c7a:	4770      	bx	lr

20003c7c <_fini>:
20003c7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
20003c7e:	bf00      	nop
20003c80:	bcf8      	pop	{r3, r4, r5, r6, r7}
20003c82:	bc08      	pop	{r3}
20003c84:	469e      	mov	lr, r3
20003c86:	4770      	bx	lr

20003c88 <__frame_dummy_init_array_entry>:
20003c88:	0505 2000                                   ... 

20003c8c <__do_global_dtors_aux_fini_array_entry>:
20003c8c:	04f1 2000                                   ... 
